{"meta":{"title":"Andrew的博客","subtitle":"practice makes perfect","description":"此为博客一枚。","author":"Andrew Li","url":"https://vlwq.github.io","root":"/"},"pages":[{"title":"相册","slug":"photos","date":"2022-03-02T09:31:31.287Z","updated":"2017-07-01T04:45:00.443Z","comments":false,"path":"photos/index.html","permalink":"https://vlwq.github.io/photos/index.html","excerpt":"","text":"Ins 摄影 图片来自instagram，正在加载中… (function() { var loadScript = function(path) { var $script = document.createElement('script') document.getElementsByTagName('body')[0].appendChild($script) $script.setAttribute('src', path) } setTimeout(function() { loadScript('./ins.js') }, 0) })()"},{"title":"关于","date":"2022-03-02T07:34:58.000Z","updated":"2022-03-02T07:35:48.701Z","comments":true,"path":"about/index.html","permalink":"https://vlwq.github.io/about/index.html","excerpt":"","text":""},{"title":"","date":"2022-03-02T09:31:31.286Z","updated":"2017-07-01T04:45:00.443Z","comments":true,"path":"photos/ins.json","permalink":"https://vlwq.github.io/photos/ins.json","excerpt":"","text":"{\"list\":[{\"date\":\"2016-12\",\"arr\":{\"year\":2016,\"month\":12,\"src\":[\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\"],\"link\":[\"BOAF_bbA9H0\",\"BN9ZdHuAqL1\",\"BN30BiDAVGo\",\"BN2CjzagYQK\",\"BNyLQGUgdma\",\"BNwOJYlgAOL\",\"BNtsL5QgEts\",\"BNn5V7oA_nc\"],\"text\":[\"末班车\",\"树影，好似一只黄鹂和蜣螂\",\"街拍 | 晴天\",\"“望”\",\"午睡\",\"“黄昏之时”\",\"枯萎的植物，最后的光\",\"街拍 | 也许是深圳最后的夏日\"],\"type\":[\"image\",\"image\",\"image\",\"image\",\"image\",\"image\",\"image\",\"image\"]}},{\"date\":\"2016-11\",\"arr\":{\"year\":2016,\"month\":11,\"src\":[\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\"],\"link\":[\"BNUaqEagioX\",\"BNTHIbUgigX\",\"BNRr9zBg0fu\",\"BNQHWSwA1Gy\",\"BNPbdVIg6gT\",\"BNOpXsKgU53\",\"BNBrozHAAV7\",\"BM8hsf-grvj\",\"BM8WO8xglvC\",\"BMy1VT3grFk\",\"BMrSxSNgpIN\",\"BMedxcZA0_g\",\"BMQLQvogqn7\"],\"text\":[\"“我是谁我爱谁我要谁我去哪”\",\"天都峰顶转一圈，站的地方巴掌大其实很慌…\",\"下了一夜雨，晚上没睡好，脑子里老想着天都峰关闭的事情。但风云变幻就在一瞬间，冥冥中必有回响，突如其来的晴天太过惊喜。峰顶走起\",\"上年没见着的雾凇突然出现，愿望兑现的感觉\",\"“不看岳”\",\"黄山行\",\"宿舍楼\",\"华科的秋天好像一条安静河流，慢慢扩散，了无声息，异常缓慢，又很具体。反正，时间还有很多，请随意\",\"又回我科，我科这个季节怎么拍都好看\",\"今夜月亮\",\"想过去改变，想过要离开，想过拍拍裤管就去远方。然后又想是不是先做出点事情，后来又突然有了点责任，再后来发现自己可以影响一些人… 它没有扼杀选择，反而让更多条路铺在我面前。所以，生日快乐，18岁。\",\"街拍 | 面对面\",\"一叶知秋\"],\"type\":[\"image\",\"video\",\"image\",\"image\",\"image\",\"image\",\"image\",\"image\",\"image\",\"image\",\"image\",\"image\",\"image\"]}},{\"date\":\"2016-10\",\"arr\":{\"year\":2016,\"month\":10,\"src\":[\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\"],\"link\":[\"BL_WXdxAM1Y\",\"BL6dTmIgecl\",\"BLv6COag1M6\",\"BLlf8WWgHcJ\",\"BLfzJ7gjj-8\",\"BLbaFJDAJ1i\",\"BLVHTFJgfg-\",\"BLTvxMWgKUn\",\"BLTd_nVAFQi\",\"BLP2UMKAGcn\",\"BLJIJCegCT3\",\"BLDZyq2g7Zr\",\"BLDSZ6pAsAZ\"],\"text\":[\"这年头不做作的民谣已经很少了……\",\"很久没去看那群留守的孩子了。他们还是很容易对每个人卸下心防，情绪会很强烈，所以开心时笑得特别大声，这让我想到悲伤会不会也成正比。不敢想。这世上，不一定所有问题都要去思考去直面，因为时间能帮你们解决很多问题。起码，在一起玩的时间。\",\"深圳雨，台风。小时候问大人，为什么我的风筝飞不起来？他们说要等大风。所以我期待着台风天。等了半年，台风来了，我却只能呆在窗户里往外看，也开始理解这场空欢喜。后来发现台风不单是种天气，还可以是一件事或一个人\",\"鸽子再也看不到无名山的高，你也不再是安和桥下清澈的水\",\"降低了预期，觉得滕王阁还不错。路遇一位玩摄影的大爷，教了许多东西，也听他说了许多往事。其实人得不得意都要尽欢，白不白头都要有那么一点青云之志\",\"东四变成了超市\\n东三变成了清真\\n神剪阁还在\\n绝望坡的小吃多到绝望\\n球场都翻修了\\n计科有钱了(辅导员说的)\\nofo小黄车已占领校园\\n学弟学妹主要玩lol和王者荣耀\\n光谷门对面依旧有鸡蛋灌饼和麻辣烫\\n韵苑食堂还是不怎么好吃\\n沁苑的猫又生了许多娃…\\n\\n来去匆匆，一些照片在：http://120.24.181.238/gallery/\",\"要是一个地方能称作图书馆，不单单是因为图书，还因为它收藏了太多的心事。\\n一语一念，虽不可借阅，愿永不过期。\",\"《深夜食堂》\",\"《返校日》\",\"旧时作\",\"和奶奶在一起。把轮椅推到广场下面玩，突然问我：你们厂生产什么？我：很难说，网络你知道吗… 奶奶：哦，卖绳子的啊\",\"19年前的我，就已经学会了爱恨分明……\",\"回老家，今天正好是“圩日”。村民一家老小，从竹林深处的罗江村出发，走过这条小桥，赶往市集。买到中意的衣服，或者零食，这就是完美的一天\"],\"type\":[\"video\",\"image\",\"image\",\"image\",\"image\",\"image\",\"image\",\"image\",\"image\",\"image\",\"image\",\"image\",\"image\"]}},{\"date\":\"2016-09\",\"arr\":{\"year\":2016,\"month\":9,\"src\":[\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\"],\"link\":[\"BK-l0eHgWep\",\"BK3W05HgBqP\",\"BK0nQcSARek\",\"BKx6pvkg5HE\",\"BKfNILQgNAO\",\"BKdn7vEAJJW\",\"BKcdEbPAWzk\",\"BKcCulagAx1\",\"BKazUfGAFlb\",\"BKayutggosw\",\"BKTJUOdgkLm\",\"BKIiijpAvmT\"],\"text\":[\"街拍 | 回望\",\"街拍 | 深拷贝…\",\"街拍 | 拷贝\",\"街拍 | 擦肩而过\",\"苗族妹子上来敬酒。以为只是普通米酒，一饮而尽，后来才跟我说有70度。那还怎样办？不走了。\",\"满城星星点点的灯火，当作你心心念念的生日蜡烛吧。生日快乐，永远单纯。\",\"以大为美的苗族银饰，近看却有许多复杂的细节\",\"迷了路找不见甲秀楼位置。干脆坐下来吃一碗哨脆面，听到对面歌舞升平，寻路过去果然找到了。道理就是，有地标的地方就有广场，有广场的地方就有广场舞。感谢大妈，感谢广场舞。\",\"眼中仿佛藏了一个宇宙\",\"曾经想仗剑走天涯\",\"…\",\"hello，好久不见\"],\"type\":[\"image\",\"image\",\"image\",\"image\",\"image\",\"image\",\"image\",\"image\",\"image\",\"image\"]}},{\"date\":\"2015-12\",\"arr\":{\"year\":2015,\"month\":12,\"src\":[\"https://scontent.cdninstagram.com/hphotos-xfa1/t51.2885-15/e15/12317949_812027942276002_800384968_n.jpg\"],\"link\":[\"-wSMLcI7sl\"],\"text\":[\"秦教练教学得很好，三小时已可征服中级场。滑雪真是项迷人的活动，还没回去就约好了下次再来\"],\"type\":[\"video\"]}},{\"date\":\"2015-11\",\"arr\":{\"year\":2015,\"month\":11,\"src\":[\"https://scontent.cdninstagram.com/hphotos-xft1/t51.2885-15/s640x640/sh0.08/e35/12269862_894338194013437_1805169379_n.jpg\",\"https://scontent.cdninstagram.com/hphotos-xpf1/t51.2885-15/s640x640/sh0.08/e35/12276891_172191463131445_911534090_n.jpg\",\"https://scontent.cdninstagram.com/hphotos-xtp1/t51.2885-15/s640x640/sh0.08/e35/12237527_913338585386151_2037194016_n.jpg\",\"https://scontent.cdninstagram.com/hphotos-xap1/t51.2885-15/e15/11934646_1088170014540783_209449183_n.jpg\"],\"link\":[\"-tqoLXo7v-\",\"-qKfKxo7nw\",\"-nE5BQo7uP\",\"9qjBpWI7lk\"],\"text\":[\"雪上鸦飞\",\"行走于结了冰的松花江上，遇到一群放生的人。佛经飘扬，鱼虾入河，河面转瞬又恢复了平静。而后在饭店，服务员说我们的鱼，就来自这松花江里。\\n\\n佛的安排奇妙又令人啼笑，鱼让俩群不同的人都收获了快乐？那么我想，鱼就是佛\",\"月上枝头\",\"在天黑后的日光岩顶呆了很久，一个人看一座岛，孤单也自由。后来遇到一位姑娘，我们一同下山。带着她逛遍整条龙头路找吃的，但她什么也不愿吃，问她，她说，想吃酸辣土豆丝。\\n\\n只有笑着承认，真是意料之外的答案。我出来玩，就是为了吃平时吃不到的东西，她则是觉得家乡的菜最熟悉，在哪都是愿意吃的。\\n\\n好吧，陪你吃。因为，离开武汉这么久，我也挺想念这道菜。\"],\"type\":[\"image\",\"image\",\"image\",\"video\"]}},{\"date\":\"2015-10\",\"arr\":{\"year\":2015,\"month\":10,\"src\":[\"https://scontent.cdninstagram.com/hphotos-xpt1/t51.2885-15/s640x640/sh0.08/e35/12145229_1722399741326075_2063247708_n.jpg\",\"https://scontent.cdninstagram.com/hphotos-xpt1/t51.2885-15/s640x640/sh0.08/e35/12080493_892409564169375_1626542651_n.jpg\",\"https://scontent.cdninstagram.com/hphotos-xtp1/t51.2885-15/s640x640/sh0.08/e35/11849199_203248513340142_1615092499_n.jpg\",\"https://scontent.cdninstagram.com/hphotos-xpt1/t51.2885-15/e15/12132912_162625974083441_1400003063_n.jpg\",\"https://scontent.cdninstagram.com/hphotos-xpt1/t51.2885-15/s640x640/sh0.08/e35/12135478_1700175696879683_933151519_n.jpg\"],\"link\":[\"9VYE8YI7sk\",\"9BkX3xo7od\",\"8-Ba4MI7lt\",\"88Neujo7r2\",\"8uKqhDo7vp\"],\"text\":[\"在路上\",\"11点的时候，不想睡，借一只手电，一人夜游古村。这事情很刺激，转角遇到的神像，榕树的垂枝，摇曳的灯笼，自己投射到土楼的巨大影子，莫名的恐惧自心底升起。然而后来又不怕了，却总是想起以前去的思溪源村…with my friends\",\"古城的砖瓦年代久了，就很容易长出猫来\",\"以前吉他老师说，对于一首天空之城，听过与弹过是完全不一样的。弹过后才知道，从开始的吉他2品就一直在递增，仿佛自身也在飞翔，云层渐开，空城显现，情绪是那么容易被调动。然而我的水平只够感动自己，要抓紧时间努力学习了。不说了，玩游戏去了\",\"海上日出\"],\"type\":[\"image\",\"image\",\"image\",\"video\",\"image\"]}},{\"date\":\"2015-9\",\"arr\":{\"year\":2015,\"month\":9,\"src\":[\"https://scontent.cdninstagram.com/hphotos-xtf1/t51.2885-15/s640x640/sh0.08/e35/11875445_885316994870904_706284789_n.jpg\",\"https://scontent.cdninstagram.com/hphotos-xpa1/t51.2885-15/s640x640/sh0.08/e35/11352715_138879086461968_2066668148_n.jpg\"],\"link\":[\"8NKC9RI7oZ\",\"8DOh_to7p0\"],\"text\":[\"沙滩总有数不完的沙子，数不完的故事。在这突然想起那本还没看完的《岛上书店》，是时候继续做些什么了\",\"陌上花开\"],\"type\":[\"image\",\"image\"]}},{\"date\":\"2015-6\",\"arr\":{\"year\":2015,\"month\":6,\"src\":[\"https://scontent.cdninstagram.com/hphotos-xft1/t51.2885-15/e15/11429225_720390118073037_768409912_n.jpg\",\"https://scontent.cdninstagram.com/hphotos-xap1/t51.2885-15/e15/11420780_1012574008772885_1569805305_n.jpg\",\"https://scontent.cdninstagram.com/hphotos-xtf1/t51.2885-15/e15/11252784_879698105429690_2109453469_n.jpg\",\"https://scontent.cdninstagram.com/hphotos-xfa1/t51.2885-15/e15/11267410_925161560884785_371811288_n.jpg\",\"https://scontent.cdninstagram.com/hphotos-xaf1/t51.2885-15/e15/11375982_491190547696110_2013240096_n.jpg\"],\"link\":[\"4T1Lfgo7gX\",\"3-mmN3o7mn\",\"3uts9do7jI\",\"3iK7kwI7j1\",\"3glBKbI7jm\"],\"text\":[\"大雨之后\",\"一脸无辜的王尼玛大哥，从肚腩来看，果然是正品？\",\"感觉迷上风筝了。有次做梦，想到一根根拉伸向上的线，像是在钓空中的鱼。而一个技术娴熟的“渔夫”，收杆时是这么干净利落。\",\"起飞\",\"小萝莉不愿回家，跟奶奶说：“再让我玩会，明天要学钢琴，后天要学跳舞，就来不了这儿玩了。”\"],\"type\":[\"image\",\"image\",\"video\",\"video\",\"image\"]}},{\"date\":\"2015-5\",\"arr\":{\"year\":2015,\"month\":5,\"src\":[\"https://scontent.cdninstagram.com/hphotos-xtp1/t51.2885-15/e15/11252751_1444216632541093_1558227860_n.jpg\",\"https://scontent.cdninstagram.com/hphotos-xfa1/t51.2885-15/e15/11226595_701075516681953_1354085958_n.jpg\"],\"link\":[\"24-dd6o7uB\",\"2uQeuaI7nv\"],\"text\":[\"风雨欲来\",\"野生海带\"],\"type\":[\"image\",\"video\"]}},{\"date\":\"2015-4\",\"arr\":{\"year\":2015,\"month\":4,\"src\":[\"https://scontent.cdninstagram.com/hphotos-xap1/t51.2885-15/e15/11142212_609961145801361_1913577076_n.jpg\",\"https://scontent.cdninstagram.com/hphotos-xfa1/t51.2885-15/e15/11049421_1375007652828983_401355534_n.jpg\",\"https://scontent.cdninstagram.com/hphotos-xaf1/t51.2885-15/e15/11137852_1649834698581861_1050691792_n.jpg\",\"https://scontent.cdninstagram.com/hphotos-xfa1/t51.2885-15/e15/11055751_1573536912901494_1683773508_n.jpg\",\"https://scontent.cdninstagram.com/hphotos-xtf1/t51.2885-15/e15/11055897_1407191599597961_1763496348_n.jpg\"],\"link\":[\"1IUZByo7vP\",\"1ISKRxo7r8\",\"1GPBzpo7qW\",\"1FtGO3I7kN\",\"1C03iPI7hZ\"],\"text\":[\"要回去啦，再见北流河\",\"灵芝get√\",\"这里的清明是个很重要的节日，子孙们都会回来，跋山涉水，竹排渡江，荒山寻路，凭集体的记忆寻找列祖列宗的宝地，寄哀思，也求福德。一路上可以听他们唠叨旧事，也有超级靠谱的风水科普\",\"为了部落\",\"在清明的山路遇到了天然松香\"],\"type\":[\"video\",\"image\",\"image\",\"image\",\"image\"]}},{\"date\":\"2015-3\",\"arr\":{\"year\":2015,\"month\":3,\"src\":[\"https://scontent.cdninstagram.com/hphotos-xft1/t51.2885-15/e15/11123665_1542600796003839_1576473443_n.jpg\",\"https://scontent.cdninstagram.com/hphotos-xfa1/t51.2885-15/e15/11008101_1593505510894691_369067449_n.jpg\"],\"link\":[\"04_8fwo7gL\",\"zzfe7Oo7uc\"],\"text\":[\"如果你飞得像月亮这么高，就不会搁浅在树上\",\"喜欢这个季节的天空，你找个草坪一躺，飞机，风筝，鸟儿就都在上边，天气好时还能看到白天的月亮\"],\"type\":[\"image\",\"image\"]}},{\"date\":\"2015-2\",\"arr\":{\"year\":2015,\"month\":2,\"src\":[\"https://scontent.cdninstagram.com/hphotos-xaf1/t51.2885-15/e15/10958252_1405701033068537_2023890854_n.jpg\",\"https://scontent.cdninstagram.com/hphotos-xtp1/t51.2885-15/e15/10832246_413065338853260_183697882_n.jpg\",\"https://scontent.cdninstagram.com/hphotos-xaf1/t51.2885-15/e15/10268927_436139166536328_1377561628_n.jpg\",\"https://scontent.cdninstagram.com/hphotos-xfa1/t51.2885-15/e15/11008343_410508022446936_713236389_n.jpg\"],\"link\":[\"zcWez6I7uo\",\"zRPazvI7ol\",\"zPN2LtI7sT\",\"zKrDWlo7gZ\"],\"text\":[\"很多东西随着慢慢长大，变得不像小时候那样盼望热切，比如巧克力麦当劳薯片雪糕。只有对担子粉的爱永远不变的说…\",\"据说是一年一度考验演技的时候…\",\"锈迹斑斑的香炉\",\"回老家了，小时候跟我打过玻璃珠的小伙伴们呢？你们一个在北京，一个在安徽，一个在澳洲，一个我都不知道了…但你们看到玻璃珠的时候，要想起我来啊\"],\"type\":[\"image\",\"image\",\"image\",\"image\"]}},{\"date\":\"2015-1\",\"arr\":{\"year\":2015,\"month\":1,\"src\":[\"https://scontent.cdninstagram.com/hphotos-xtf1/t51.2885-15/e15/10932550_620643038062978_1729442807_n.jpg\",\"https://scontent.cdninstagram.com/hphotos-xtp1/t51.2885-15/e15/891532_1563899373855738_1180535181_n.jpg\",\"https://scontent.cdninstagram.com/hphotos-prn/t51.2885-15/e15/10005439_338105566394046_854247264_n.jpg\",\"https://scontent.cdninstagram.com/hphotos-xap1/t51.2885-15/e15/10903312_693622147425934_1766884651_n.jpg\",\"https://scontent.cdninstagram.com/hphotos-xpt1/t51.2885-15/e15/10914460_1546003772305181_1301162053_n.jpg\",\"https://scontent.cdninstagram.com/hphotos-xaf1/t51.2885-15/e15/10903277_832760670116494_255352239_n.jpg\",\"https://scontent.cdninstagram.com/hphotos-xpa1/t51.2885-15/e15/924083_1539057536347062_2062767438_n.jpg\",\"https://scontent.cdninstagram.com/hphotos-xfa1/t51.2885-15/e15/10890944_765121966897759_2039585477_n.jpg\"],\"link\":[\"yb8uaCI7tt\",\"yKBopho7mX\",\"yAOcawI7pA\",\"x5U25kI7sN\",\"x1TTZUo7gW\",\"xeGbWuo7if\",\"xXr70fI7iD\",\"xUB4dOI7g1\"],\"text\":[\"草地上遗落的鞋子\",\"有位很久没联系的朋友寄来明信片，说：我很少看到海，正如你没见过几次雪\",\"深夜总是灵感乍现的最佳时期，只是几个设计方案都没法使自己满意。累了打开窗看到天上有个大月亮，只想用图章工具把它干掉。\",\"面朝大海冬暖花开\",\"分享日常不正常生活照一张\",\"其实我想，那些古老的渔民们，每天看着海岸线的日落日出，肯定是有人想过地球是圆的。而“想法”与“证明”之间，却跨越了一整条麦哲伦航道\",\"鱼山鱼海中，只有你，肯安静的趴在65厘米厚的亚克力板子上与我合影，大丑鱼\",\"新年单人旅行走起。其实从九洲港码头开始，珠海并没有给人很惊喜的感觉，包括盛名之下的沿海风光与渔女雕塑。倒是交通不通畅，从轮渡到公交都给我带来了许多麻烦。直到，晚上吃烤生蚝的第一口，我又觉得什么事情都是可以原谅的……\"],\"type\":[\"image\",\"image\",\"image\",\"image\",\"image\",\"image\",\"image\",\"image\"]}},{\"date\":\"2014-12\",\"arr\":{\"year\":2014,\"month\":12,\"src\":[\"https://scontent.cdninstagram.com/hphotos-prn/t51.2885-15/e15/10899183_999582293404177_745539859_n.jpg\",\"https://scontent.cdninstagram.com/hphotos-xaf1/t51.2885-15/e15/10894909_702627706517406_1277557620_n.jpg\",\"https://scontent.cdninstagram.com/hphotos-xtp1/t51.2885-15/e15/10831989_483313928477468_40906631_n.jpg\"],\"link\":[\"xRWN47I7pW\",\"xO3qREI7iW\",\"wEQykeo7tU\"],\"text\":[\"2014年最后的阳光\",\"最后一节吉他课结束后，马路上那风一直吹，才感觉南方的冬天终于是来了。其实吉他在冬天会有许多神奇的事情。比如琴弦如肌肉一样因冷而紧绷，发出比以往沉闷的低语；而空旷的大教室里，如有其他同伴拨响和弦，手中本已按灭的琴弦又会因共鸣微微颤动。像有生命一样。\",\"有棵丑树，我经常去看，又胖又歪，秃得可笑。在变冷的一天，它突然就开花了。冬天的花我知道得很少，南方没有梅花，那就是异木棉了\"],\"type\":[\"image\",\"image\",\"image\"]}},{\"date\":\"2014-11\",\"arr\":{\"year\":2014,\"month\":11,\"src\":[\"https://scontent.cdninstagram.com/hphotos-prn/t51.2885-15/e15/10784965_1518537748403855_176956695_n.jpg\",\"https://scontent.cdninstagram.com/hphotos-prn/t51.2885-15/e15/10735195_1505939246340704_1984926778_n.jpg\",\"https://scontent.cdninstagram.com/hphotos-prn/t51.2885-15/e15/10747711_429336373885590_422028037_n.jpg\"],\"link\":[\"vP2ywuo7pq\",\"vA68BLo7tN\",\"u7zEVxo7vw\"],\"text\":[\"通灵之术！\",\"现场气氛果然不一样，马上就可以看到小伞在大哥胯下疯狂输出…是时候来首选一记薇恩了\",\"有朋友跟我说，挪威的森林根本看不下去；又有朋友说，看这书一发不可收拾。差别好大呀！我倒觉得有个简单的方法：翻到开篇的这几个字，如果心中一紧，那就说明这本书适合你，否则请弃之\"],\"type\":[\"image\",\"image\",\"image\"]}},{\"date\":\"2014-10\",\"arr\":{\"year\":2014,\"month\":10,\"src\":[\"https://scontent.cdninstagram.com/hphotos-frc/t51.2885-15/e15/10735112_730529873702428_413107753_n.jpg\",\"https://scontent.cdninstagram.com/hphotos-prn/t51.2885-15/e15/10725177_573652486072155_1401604216_n.jpg\",\"https://scontent.cdninstagram.com/hphotos-xfp1/t51.2885-15/e15/10724868_302191016652312_2097904817_n.jpg\",\"https://scontent.cdninstagram.com/hphotos-xft1/t51.2885-15/e15/10731727_461314204008708_386749273_n.jpg\"],\"link\":[\"uu70zJo7qb\",\"uQnvluo7sK\",\"uLi56Wo7oO\",\"uEv-tCo7rJ\"],\"text\":[\"天下的小饼干遇到我，貌似就只有一种下场！！\",\"一个人，一支口琴，一片海，一瓶酒\",\"《论夜归，打的，以及发票的正确用法》\",\"童年真好。我以后一定不要跟孩子说：希望你快高长大这种傻话…\"],\"type\":[\"image\",\"image\",\"image\",\"image\"]}},{\"date\":\"2014-9\",\"arr\":{\"year\":2014,\"month\":9,\"src\":[\"https://scontent.cdninstagram.com/hphotos-frc/t51.2885-15/e15/10616983_1382591478697855_2107473552_n.jpg\",\"https://scontent.cdninstagram.com/hphotos-xpa1/t51.2885-15/e15/925287_1464119273867077_427071626_n.jpg\",\"https://scontent.cdninstagram.com/hphotos-xap1/t51.2885-15/e15/925284_1534308033454310_855505111_n.jpg\",\"https://scontent.cdninstagram.com/hphotos-xfp1/t51.2885-15/e15/10666267_1550871771803214_2074300649_n.jpg\",\"https://scontent.cdninstagram.com/hphotos-prn/t51.2885-15/e15/10693244_734401199942901_1572709880_n.jpg\",\"https://scontent.cdninstagram.com/hphotos-prn/t51.2885-15/e15/10693771_1517437541834868_665867908_n.jpg\",\"https://scontent.cdninstagram.com/hphotos-prn/t51.2885-15/e15/10693822_497709657032441_1125408654_n.jpg\",\"https://scontent.cdninstagram.com/hphotos-prn/t51.2885-15/e15/10683941_796597910390683_12441123_n.jpg\",\"https://scontent.cdninstagram.com/hphotos-ash/t51.2885-15/e15/10661142_164227523747936_1526737465_n.jpg\",\"https://scontent.cdninstagram.com/hphotos-xfa1/t51.2885-15/e15/10661182_550889531706942_2043749716_n.jpg\",\"https://scontent.cdninstagram.com/hphotos-ash/t51.2885-15/e15/10520334_1523531751215211_1344090061_n.jpg\",\"https://scontent.cdninstagram.com/hphotos-prn/t51.2885-15/e15/10693390_547748238660649_761529890_n.jpg\",\"https://scontent.cdninstagram.com/hphotos-prn/t51.2885-15/e15/10693650_837768039589771_1793184733_n.jpg\",\"https://scontent.cdninstagram.com/hphotos-xft1/t51.2885-15/e15/914812_1529561143923493_1662159287_n.jpg\",\"https://scontent.cdninstagram.com/hphotos-xfp1/t51.2885-15/e15/10644019_368509079979549_2085033896_n.jpg\",\"https://scontent.cdninstagram.com/hphotos-xta1/t51.2885-15/e15/10684161_918887498139099_2081383304_n.jpg\",\"https://scontent.cdninstagram.com/hphotos-ash/t51.2885-15/e15/10683828_327931784041264_894089329_n.jpg\",\"https://scontent.cdninstagram.com/hphotos-prn/t51.2885-15/e15/10666028_872988212713750_1345360858_n.jpg\",\"https://scontent.cdninstagram.com/hphotos-xpf1/t51.2885-15/e15/10665501_1452353738387652_2075798065_n.jpg\"],\"link\":[\"tXuIHso7qK\",\"tJjQlAo7kH\",\"tDYyUeo7oX\",\"tCBULHo7sW\",\"tB_Xmao7qG\",\"s8cKzLI7pM\",\"s6-lOFo7ip\",\"s5GifkI7q7\",\"s3uZcmo7uj\",\"s2bb5io7p-\",\"s2P72tI7o6\",\"s2FPpGI7o_\",\"s1LPQPo7v8\",\"szZP5Io7lY\",\"sr9rtNo7lM\",\"sr7gXKI7h_\",\"srG7fjo7sV\",\"spAnrio7oh\",\"sj4BGgI7t_\"],\"text\":[\"我的好朋友——超级高冷超级磨人的丝瓜\",\"沉眠的店主失眠的狗。想起大学的最后时光，宿舍24小时都有人醒着，自由的人生，自由的酒和曲终人散，大家通常没有另一半，没有钱，没有忧愁，爽成狗\",\"如果他是程序员…\\nvar date = lifetime;\\rif(rotate(mountain, water, stupa)){ /*return nextLifetime;*/ return meetyou(journey);\\r}\",\"听着山寨的民谣电子乐，看着美好的姑娘。功德无量。\",\"弥里塘太宁静。在这我一直想起每一个被深圳车水马龙声吵醒的早晨，真是光辉的岁月\",\"进藏。天空挂满着云，黑的白的都有。云朵转眼飘散，它却依然是蓝色。\",\"“音浪太强不晃会被撞到地上…”\",\"陌生的朋友，愿下次再能与你们相聚在丽江love wine & half。我无法融解你悲观现实的想法，你也无法说服我旅行并不是逃避。但这都很有意思。只是想起以前有个人叫我不能喝太多的酒，一想到这个呀我就越喝越多\",\"玉龙雪山\",\"以前想去丽江，但去过的人都灌输着你也许会失望的观念，因而甚至不敢动身。这是一种“怕”。有时候真得自己去看看才会了然。第一天在丽江，民谣吉他缓缓流过商业化的街道，原来没有惊喜，也没有失望，一切刚刚好。\",\"我注定要回到老路上\",\"彩云之南\",\"云南，向往已久的地方\",\"QQ同时在线人数破2亿纪念，作为一颗小小螺丝钉，名字正好镶到企鹅的大嘴巴上。这时觉得有一丝光荣，一种努力被实化的错觉；然后又有点不舒服，感觉此时的自己，和名字身边的人一样。可我想要的就是不一样。\",\"陪伴一定得是件漫长的事呵。和奶奶在一起的中秋节。\",\"中秋和家人一起去看孔明灯，热闹而安逸，这是小城市的美好。\",\"老家的葡萄藤，从我初中时就挂在这，再见已是十一年\",\"家里橄榄熟了，盐渍，暴晒，蘸蜜，简直人间美味!\",\"在一场太阳雨里回到家中\"],\"type\":[\"image\",\"image\",\"image\",\"image\",\"image\",\"image\",\"video\",\"image\",\"video\",\"image\",\"video\",\"image\",\"image\",\"image\",\"image\",\"video\",\"image\",\"image\",\"image\"]}},{\"date\":\"2014-8\",\"arr\":{\"year\":2014,\"month\":8,\"src\":[\"https://scontent.cdninstagram.com/hphotos-ash/t51.2885-15/e15/10654876_610857929023752_364709543_n.jpg\",\"https://scontent.cdninstagram.com/hphotos-xfa1/t51.2885-15/e15/10644013_777642448965989_544517718_n.jpg\",\"https://scontent.cdninstagram.com/hphotos-xap1/t51.2885-15/e15/924456_1471485796442896_1699836323_n.jpg\",\"https://scontent.cdninstagram.com/hphotos-xtp1/t51.2885-15/e15/10607913_692632367472666_1829853902_n.jpg\",\"https://scontent.cdninstagram.com/hphotos-xtf1/t51.2885-15/e15/10611052_1466241683635233_830264506_n.jpg\",\"https://scontent.cdninstagram.com/hphotos-frc/t51.2885-15/e15/10617144_829548960388746_1611410337_n.jpg\",\"https://scontent.cdninstagram.com/hphotos-xft1/t51.2885-15/e15/10453953_542161702576881_1621059386_n.jpg\"],\"link\":[\"sXa9g6I7jB\",\"sPt4u4I7kA\",\"sC18G0o7qb\",\"sAMmEWI7oC\",\"rzSow4o7lH\",\"ro28LPI7oc\",\"rR37wLo7iu\"],\"text\":[\"在书店的晚上终于把新专反复听完。太柔了…打一星两星的人肯定是真爱粉，这点有人敢怀疑？我不是，打四星！停不下来，直到书店响起:深圳即将入眠。但22点还是深圳的早晨呀\",\"慢三的华尔兹，大篇幅的爵士即兴。感觉生活得太浮躁。也太安逸。\",\"好久没看话剧，这部果然没让人失望。导演太会讲故事了，1024个赞\",\"纵有一万种悲伤的美丽，也比不过这段。\",\"在书城里看到的《后会无期》分镜图。电影那么美，分镜是这样，这就是现实~\",\"如果你从北京来看我，我会很感动;如果你像光，从太阳那头过来，我不以为然。因为光到地球只要8.3分钟。我们经常错用代价来衡量情感\",\"相聚总有时:)\"],\"type\":[\"image\",\"video\",\"image\",\"image\",\"image\",\"image\",\"image\"]}},{\"date\":\"2014-7\",\"arr\":{\"year\":2014,\"month\":7,\"src\":[\"https://scontent.cdninstagram.com/hphotos-xpa1/t51.2885-15/e15/925559_1482425071996009_1940959046_n.jpg\",\"https://scontent.cdninstagram.com/hphotos-frc/t51.2885-15/e15/10554006_501929086608023_917623457_n.jpg\",\"https://scontent.cdninstagram.com/hphotos-frc/t51.2885-15/e15/10576105_624878090953161_638111947_n.jpg\",\"https://scontent.cdninstagram.com/hphotos-xpf1/t51.2885-15/e15/10570119_332808380211109_125412512_n.jpg\",\"https://scontent.cdninstagram.com/hphotos-xpa1/t51.2885-15/e15/926536_828142997203682_1319760676_n.jpg\",\"https://scontent.cdninstagram.com/hphotos-xap1/t51.2885-15/e15/923702_252705761596555_721784545_n.jpg\",\"https://scontent.cdninstagram.com/hphotos-ash/t51.2885-15/e15/10549755_708603639175850_2095584541_n.jpg\",\"https://scontent.cdninstagram.com/hphotos-xtf1/t51.2885-15/e15/928307_1442957109299429_297849354_n.jpg\",\"https://scontent.cdninstagram.com/hphotos-ash/t51.2885-15/e15/10488451_303926969784787_1278259348_n.jpg\"],\"link\":[\"q5e2KpI7qn\",\"qyXXpNI7q5\",\"qxfUe0I7lp\",\"qq9usdo7hr\",\"qn4WCIo7hi\",\"ql0brho7vN\",\"qkiaYDo7t9\",\"qURC9fI7r-\",\"p4A8IuI7py\"],\"text\":[\"随便走走，发现世界还是很美好的。当拥有美好事物时，经常习惯性的熟视无睹;当努力抓住你想要的东西时，它又可能瞬间破碎。但依旧需要不妥协。\",\"荔枝——我心目中的水果之王（有之一）\",\"高中时代最新款的mp4，现已成了老古董\",\"台风来临时，刚好会是暑假。但我已没有暑假。\",\"看着一场雨由远及近的淋湿院子，太漂亮\",\"归来却空空的行囊 那故乡的云 那故乡的风 啦啦啦啦啦 啦啦啦。\",\"在今年第一个狂风大作的早上，回家去\",\"98年，世界杯第一次在我脑中留下记忆，和爸，围着那台很小的tcl。今天，爸还打电话给我，让我别看太晚影响到明天工作，但我知道他自己也会去看的。是的，我们爱足球，今生今世\",\"这几天深圳的天空很美，无论晴雨\"],\"type\":[\"image\",\"image\",\"image\",\"image\",\"image\",\"image\",\"image\",\"image\",\"image\"]}},{\"date\":\"2014-6\",\"arr\":{\"year\":2014,\"month\":6,\"src\":[\"https://scontent.cdninstagram.com/hphotos-xfa1/t51.2885-15/e15/10362316_1434933843444633_1187384207_n.jpg\",\"https://scontent.cdninstagram.com/hphotos-prn/t51.2885-15/e15/10471930_507725875994902_393186392_n.jpg\",\"https://scontent.cdninstagram.com/hphotos-xaf1/t51.2885-15/e15/10454011_484872768311603_738380027_n.jpg\",\"https://scontent.cdninstagram.com/hphotos-xaf1/t51.2885-15/e15/923661_248502122024084_2086692261_n.jpg\",\"https://scontent.cdninstagram.com/hphotos-xtp1/t51.2885-15/e15/10424605_774238262594769_78480252_n.jpg\"],\"link\":[\"p06uEZI7tG\",\"pytFNpo7sD\",\"poMFteI7q0\",\"pMt5tgI7vj\",\"o3eroFo7gK\"],\"text\":[\"“往事依稀浑似梦，都随风雨到心头”——梅表姐\",\"navy blue\",\"今天我遇到一朵枯玫瑰。她只是枯萎，从未凋零。\",\"上届卫冕冠军被打成筛子的…是热火…\",\"我和大神的差距——web工程师的自我修养\"],\"type\":[\"image\",\"image\",\"image\",\"image\",\"image\"]}},{\"date\":\"2014-5\",\"arr\":{\"year\":2014,\"month\":5,\"src\":[\"https://scontent.cdninstagram.com/hphotos-xat1/t51.2885-15/e15/10387796_255697041300477_753213015_n.jpg\",\"https://scontent.cdninstagram.com/hphotos-frc/t51.2885-15/e15/10005623_779769878723970_627922376_n.jpg\",\"https://scontent.cdninstagram.com/hphotos-xpf1/t51.2885-15/e15/10358172_1495900567292387_640174442_n.jpg\",\"https://scontent.cdninstagram.com/hphotos-xta1/t51.2885-15/e15/10369281_674379822637848_233362820_n.jpg\",\"https://scontent.cdninstagram.com/hphotos-xfa1/t51.2885-15/e15/928251_430572373746575_786910314_n.jpg\",\"https://scontent.cdninstagram.com/hphotos-frc/t51.2885-15/e15/10358301_256481271142988_1088114034_n.jpg\",\"https://scontent.cdninstagram.com/hphotos-xap1/t51.2885-15/e15/10296597_1413560715589179_392570057_n.jpg\",\"https://scontent.cdninstagram.com/hphotos-xtf1/t51.2885-15/e15/10299642_561366610636165_721929935_n.jpg\",\"https://scontent.cdninstagram.com/hphotos-xfa1/t51.2885-15/e15/10268965_1446530205590326_114108738_n.jpg\"],\"link\":[\"op03boo7lW\",\"ops-ZUI7t-\",\"ofqhBpI7mQ\",\"odP0cno7ue\",\"oLX-4GI7ne\",\"oBl6WtI7qC\",\"nvPChzI7vU\",\"ngAyz8o7qj\",\"ndTggdI7jn\"],\"text\":[\"突然发现我还是挺喜欢大晴天的\",\"单人旅行走起！开心\",\"不久就可以吃了\",\"黄昏时分\",\"大雨倾城\",\"今天路过公园，一朵玉兰掉在身边。想起小时候陪伴我的三棵树，两棵木棉，一棵玉兰。当然玉兰这名字是后来才知道的，记忆里的那朵永远叫做香花。三年级的某天放学，这三棵树一并倒下了。\",\"雨中深大。雨季再来不再来。\",\"say hey to may\",\"故事中的小黄花\"],\"type\":[\"image\",\"image\",\"image\",\"image\",\"image\",\"image\",\"image\",\"image\",\"image\"]}},{\"date\":\"2014-4\",\"arr\":{\"year\":2014,\"month\":4,\"src\":[\"https://scontent.cdninstagram.com/hphotos-ash/t51.2885-15/e15/10261258_711820055527911_220271949_n.jpg\",\"https://scontent.cdninstagram.com/hphotos-xpt1/t51.2885-15/e15/10249356_695726313802446_881680057_n.jpg\",\"https://scontent.cdninstagram.com/hphotos-ash/t51.2885-15/e15/10268929_597082527053970_1060360934_n.jpg\",\"https://scontent.cdninstagram.com/hphotos-ash/t51.2885-15/e15/10268941_490697914386538_1148834228_n.jpg\",\"https://scontent.cdninstagram.com/hphotos-xtf1/t51.2885-15/e15/10254195_545488182236276_1930978882_n.jpg\",\"https://scontent.cdninstagram.com/hphotos-xtp1/t51.2885-15/e15/917572_539124756205696_1549712749_n.jpg\",\"https://scontent.cdninstagram.com/hphotos-xaf1/t51.2885-15/e15/927273_657564254280429_578859844_n.jpg\",\"https://scontent.cdninstagram.com/hphotos-frc/t51.2885-15/e15/10175316_650834874981595_1358429831_n.jpg\",\"https://scontent.cdninstagram.com/hphotos-xaf1/t51.2885-15/e15/926422_245144379006241_1254093305_n.jpg\",\"https://scontent.cdninstagram.com/hphotos-xaf1/t51.2885-15/e15/891289_302574849898688_205313988_n.jpg\",\"https://scontent.cdninstagram.com/hphotos-frc/t51.2885-15/e15/10175309_510867459023322_1700312549_n.jpg\"],\"link\":[\"nOGNjUI7op\",\"nGJfYAo7lW\",\"nATIxlI7tR\",\"mxsNwto7pQ\",\"mm7JTUI7p0\",\"mhER0lo7oe\",\"mfvVUYI7hu\",\"mdF-nNo7pE\",\"mcVLQzo7nl\",\"mb5cFho7sd\",\"maqYInI7if\"],\"text\":[\"谢谢亲们的蛋糕和礼物;谢谢我们始终用“同学”来称呼彼此。\",\"处女座老榕树\",\"放风筝的人们\",\"现在我的状态，像极了一只被推上战场僵尸\",\"这几天我耳边是都是这样的话语:1、“就是敲敲键盘，挺清闲的哈！”2、“别太挑剔，给个一两千就先做着”3、“什么？你那一碗粉要十二块钱？！”我回深圳了，几天的清静生活，谢谢乡亲们的招待。\",\"good luck\",\"瓦上花开\",\"好吧，这是一艘船\",\"石表山，思罗河，四年后的清明我又来到了这儿\",\"清明，一路向西\",\"清明一回到家，老妈就开始炫耀她试验种的豆芽。愿君多采撷，此物最好吃？\"],\"type\":[\"image\",\"image\",\"image\",\"image\",\"image\",\"image\",\"image\",\"image\",\"image\",\"image\",\"image\"]}},{\"date\":\"2014-3\",\"arr\":{\"year\":2014,\"month\":3,\"src\":[\"https://scontent.cdninstagram.com/hphotos-xft1/t51.2885-15/e15/10012487_604746702952671_676907736_n.jpg\",\"https://scontent.cdninstagram.com/hphotos-xfa1/t51.2885-15/e15/1171265_389602547845527_1588547561_n.jpg\",\"https://scontent.cdninstagram.com/hphotos-xfa1/t51.2885-15/e15/11376491_1614984048759908_413209146_n.jpg\",\"https://scontent.cdninstagram.com/hphotos-xft1/t51.2885-15/e15/11251074_365441270314698_1015057085_n.jpg\",\"https://scontent.cdninstagram.com/hphotos-xft1/t51.2885-15/e15/11380079_1581430378786145_504181803_n.jpg\",\"https://scontent.cdninstagram.com/hphotos-xtf1/t51.2885-15/e15/11330604_837683999618217_506172540_n.jpg\",\"https://scontent.cdninstagram.com/hphotos-xpa1/t51.2885-15/e15/11273047_110162449318540_1639646034_n.jpg\",\"https://scontent.cdninstagram.com/hphotos-xap1/t51.2885-15/e15/11375356_908792249164254_112740693_n.jpg\",\"https://scontent.cdninstagram.com/hphotos-xfa1/t51.2885-15/e15/11357539_388432694679963_1281450994_n.jpg\",\"https://scontent.cdninstagram.com/hphotos-xpa1/t51.2885-15/e15/11311124_1611430865770700_1482115931_n.jpg\"],\"link\":[\"mIgOdio7jT\",\"mIAS5lo7hb\",\"lrhVmio7lF\",\"lmADv6I7rU\",\"lhPFVeI7g6\",\"lcyrKSI7h_\",\"lSda6Ko7nG\",\"lSSxd8I7kB\",\"lK0xswI7s6\",\"lA4KaBI7go\"],\"text\":[\"转角遇到戏台，耳熟却不知道是哪一出了。想起爷爷以前的二胡与杨琴，自己精削细磨的琴竹，还有他组织的“菊山楼”粤剧队，真是一晃好些年。今年清明，一定回去。\",\"这本书超赞！好书好书好书\",\"四五点写程序太累，就不写了。不告诉任何人，跑到这个立交桥底，我已来过好几回。这里有一棵白色的紫荆花，满墙爬山虎，和刚放学的小朋友，出去，右拐，再右拐，转角可以遇到你，我的肉夹馍…\",\"越来越认生了，到步行街买衣服，找到比较适合的，却因为店员太过热情…跑了出来。闹市中居然藏有一古庙，还是这里自在，漫天神佛只是笑笑，不理物我，无论喜悲。对了我来这干嘛\",\"爬山的好处:强身健体，磨砺意志，开阔胸怀…坏处是:没有wifi。\",\"又见回南天\",\"老妈说，今天要我送个礼物！离家万里，只好迅速开发出这个app，摇后就会播放我唱的真的爱你。可惜她说摇后没反应，后来才知道，她拿的ipad在摇…但我是真的爱你\",\"今天下雨，的士司机都不肯理我。头上路灯光芒遥不可及，脚下路面棱角冰冷鲜明\",\"起风吧，明天。喜欢偏冷的日子，假如是春天，假如是风大，太完美了\",\"腾讯的凌晨四点半。第一次在此过夜，听着耳熟不能详的歌，看着平静不微笑的人。然后记起，家里打来被我按掉的电话，忘了回\"],\"type\":[\"image\",\"image\",\"image\",\"image\",\"image\",\"image\",\"image\",\"image\",\"image\",\"image\"]}},{\"date\":\"2014-2\",\"arr\":{\"year\":2014,\"month\":2,\"src\":[\"https://scontent.cdninstagram.com/hphotos-ash/t51.2885-15/e15/1737225_591794970889160_1849235580_n.jpg\",\"https://scontent.cdninstagram.com/hphotos-prn/t51.2885-15/e15/1741200_451260698337036_577792061_n.jpg\"],\"link\":[\"kv3jNgI7sw\",\"kr8sW8I7nR\"],\"text\":[\"“不能吃太胖喔，会被杀掉的！”\",\"今晚，已经看到两个小女生在问，这里有《九云梦》吗？\"],\"type\":[\"image\",\"image\"]}}]}"},{"title":"","date":"2022-03-02T09:31:31.285Z","updated":"2017-07-01T04:45:00.443Z","comments":true,"path":"photos/ins.css","permalink":"https://vlwq.github.io/photos/ins.css","excerpt":"","text":"#post-instagram{ padding: 30px; } #post-instagram .article-entry{ padding-right: 0; } .instagram{ position: relative; min-height: 500px; } .instagram img { width: 100%; } .instagram .year { font-size: 16px; } .instagram .open-ins{ padding: 10px 0; color: #cdcdcd; } .instagram .open-ins:hover{ color: #657b83; } .instagram .year{ display: inline; } .instagram .thumb { width: 25%; height: 0; padding-bottom: 25%; position: relative; display: inline-block; text-align: center; background: #ededed; outline: 1px solid #ddd; } .instagram .thumb a { position: relative; } .instagram .album h1 em{ font-style: normal; font-size: 14px; margin-left: 10px; } .instagram .album ul{ display: flex; flex-wrap: wrap; clear: both; width: 100%; text-align: left; } .instagram .album li{ list-style: none; display: inline-block; box-sizing: border-box; padding: 0 5px; margin-bottom: -10px; height: 0; width: 25%; position: relative; padding-bottom: 25%; } .instagram .album li:before{ display: none; } .instagram .album div.img-box{ position: absolute; width: 90%; height: 90%; -webkit-box-shadow: 0 1px 0 rgba(255,255,255,0.4), 0 1px 0 1px rgba(255,255,255,0.1); -moz-box-shadow: 0 1px 0 rgba(255,255,255,0.4), 0 1px 0 1px rgba(255,255,255,0.1); box-shadow: 0 1px 0 rgba(255,255,255,0.4), 0 1px 0 1px rgba(255,255,255,0.1); } .instagram .album div.img-box img{ width: 100%; height: 100%; position: absolute; z-index: 2; } .instagram .album div.img-box .img-bg{ position: absolute; top: 0; left: 0; bottom: 0px; width: 100%; margin: -5px; padding: 5px; -webkit-box-shadow: 0 0 0 1px rgba(0,0,0,.04), 0 1px 5px rgba(0,0,0,0.1); -moz-box-shadow: 0 0 0 1px rgba(0,0,0,.04), 0 1px 5px rgba(0,0,0,0.1); box-shadow: 0 0 0 1px rgba(0,0,0,.04), 0 1px 5px rgba(0,0,0,0.1); -webkit-transition: all 0.15s ease-out 0.1s; -moz-transition: all 0.15s ease-out 0.1s; -o-transition: all 0.15s ease-out 0.1s; transition: all 0.15s ease-out 0.1s; opacity: 0.2; cursor: pointer; display: block; z-index: 3; } .instagram .album div.img-box .icon { font-size: 14px; position: absolute; left: 50%; top: 50%; margin-left: -7px; margin-top: -7px; color: #999; z-index: 1; } .instagram .album div.img-box .img-bg:hover{ opacity: 0; } .photos-btn-wrap { border-bottom: 1px solid #e5e5e5; margin-bottom: 20px; } .photos-btn { font-size: 16px; color: #333; margin-bottom: -4px; padding: 5px 8px 3px; } .photos-btn.active { color: #08c; border: 1px solid #e5e5e5; border-bottom: 5px solid #fff; } @media screen and (max-width:600px) { .instagram .thumb { width: 50%; padding-bottom: 50%; } .instagram .album li { width: 100%; position: relative; padding-bottom: 100%; text-align: center; } .instagram .album div.img-box{ margin: 0; width: 90%; height: 90%; } }"},{"title":"","date":"2022-03-02T09:31:31.288Z","updated":"2017-07-01T04:45:00.443Z","comments":true,"path":"photos/lazyload.min.js","permalink":"https://vlwq.github.io/photos/lazyload.min.js","excerpt":"","text":""},{"title":"标签","date":"2017-10-25T14:05:00.000Z","updated":"2022-03-02T07:32:56.615Z","comments":true,"path":"tags/index.html","permalink":"https://vlwq.github.io/tags/index.html","excerpt":"","text":""},{"title":"","date":"2022-03-03T03:45:31.954Z","updated":"2022-03-03T03:45:31.954Z","comments":true,"path":"photos/ins.js","permalink":"https://vlwq.github.io/photos/ins.js","excerpt":"","text":"/******/ (function(modules) { // webpackBootstrap /******/ // The module cache /******/ var installedModules = {}; /******/ /******/ // The require function /******/ function __webpack_require__(moduleId) { /******/ /******/ // Check if module is in cache /******/ if (installedModules[moduleId]) /******/ return installedModules[moduleId].exports; /******/ /******/ // Create a new module (and put it into the cache) /******/ var module = installedModules[moduleId] = { /******/ exports: {}, /******/ id: moduleId, /******/ loaded: false /******/ }; /******/ /******/ // Execute the module function /******/ modules[moduleId].call(module.exports, module, module.exports, __webpack_require__); /******/ /******/ // Flag the module as loaded /******/ module.loaded = true; /******/ /******/ // Return the exports of the module /******/ return module.exports; /******/ } /******/ /******/ /******/ // expose the modules object (__webpack_modules__) /******/ __webpack_require__.m = modules; /******/ /******/ // expose the module cache /******/ __webpack_require__.c = installedModules; /******/ /******/ // __webpack_public_path__ /******/ __webpack_require__.p = \"/dist/\"; /******/ /******/ // Load entry module and return exports /******/ return __webpack_require__(0); /******/ }) /************************************************************************/ /******/ ([ /* 0 */ /***/ function(module, exports, __webpack_require__) { 'use strict'; __webpack_require__(1); var _view = __webpack_require__(2); var _view2 = _interopRequireDefault(_view); function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; } /** * @name impush-client * @description 这个项目让我发家致富… * @date 2015others-12-1 */ var _collection = []; var _count = 0; var searchData; function addMask(elem) { var rect = elem.getBoundingClientRect(); var style = getComputedStyle(elem, null); var mask = document.createElement('i'); mask.className = 'icon-film'; mask.style.color = '#fff'; mask.style.fontSize = '26px'; mask.style.position = 'absolute'; mask.style.right = '10px'; mask.style.bottom = '10px'; mask.style.zIndex = 1; elem.parentNode.appendChild(mask); } var createVideoIncon = function createVideoIncon() { var $videoImg = document.querySelectorAll('.thumb a[data-type=\"video\"]'); for (var i = 0, len = $videoImg.length; i < len; i++) { addMask($videoImg[i]); } }; var render = function render(res) { var ulTmpl = \"\"; for (var j = 0, len2 = res.list.length; j < len2; j++) { var data = res.list[j].arr; var liTmpl = \"\"; for (var i = 0, len = data.link.length; i < len; i++) { var minSrc = 'http://litten.me/ins-min/' + data.link[i] + '.min.jpg'; var src = 'http://litten.me/ins/' + data.link[i]; var type = data.type[i]; var target = src + (type === 'video' ? '.mp4' : '.jpg'); src += '.jpg'; liTmpl += '\\ \\ \\ \\ ' + data.text[i] + '\\ '; } ulTmpl = ulTmpl + '' + data.year + '' + data.month + '月\\ ' + liTmpl + '\\ '; } document.querySelector('.instagram').innerHTML = '' + ulTmpl + ''; createVideoIncon(); _view2.default.init(); }; var replacer = function replacer(str) { var arr = str.split(\"/\"); return \"/assets/ins/\" + arr[arr.length - 1]; }; var ctrler = function ctrler(data) { var imgObj = {}; for (var i = 0, len = data.length; i < len; i++) { var y = data[i].y; var m = data[i].m; var src = replacer(data[i].src); var text = data[i].text; var key = y + \"\" + ((m + \"\").length == 1 ? \"0\" + m : m); if (imgObj[key]) { imgObj[key].srclist.push(src); imgObj[key].text.push(text); } else { imgObj[key] = { year: y, month: m, srclist: [src], text: [text] }; } } render(imgObj); }; function loadData(success) { if (!searchData) { var xhr = new XMLHttpRequest(); xhr.open('GET', './ins.json?t=' + +new Date(), true); xhr.onload = function() { if (this.status >= 200 && this.status < 300) { var res = JSON.parse(this.response); searchData = res; success(searchData); } else { console.error(this.statusText); } }; xhr.onerror = function() { console.error(this.statusText); }; xhr.send(); } else { success(searchData); } } var Ins = { init: function init() { loadData(function(data) { render(data); }); } }; Ins.init(); // export default impush; /***/ }, /* 1 */ /***/ function(module, exports, __webpack_require__) { /* WEBPACK VAR INJECTION */ (function(global) { 'use strict'; var inViewport = __webpack_require__(3); var lazyAttrs = ['data-src']; global.lzld = lazyload(); // Provide libs using getAttribute early to get the good src // and not the fake data-src replaceGetAttribute('Image'); replaceGetAttribute('IFrame'); function registerLazyAttr(attr) { if (indexOf.call(lazyAttrs, attr) === -1) { lazyAttrs.push(attr); } } function lazyload(opts) { opts = merge({ 'offset': 333, 'src': 'data-src', 'container': false }, opts || {}); if (typeof opts.src === 'string') { registerLazyAttr(opts.src); } var elts = []; function show(elt) { var src = findRealSrc(elt); if (src) { elt.src = src; } elt.setAttribute('data-lzled', true); elts[indexOf.call(elts, elt)] = null; } function findRealSrc(elt) { if (typeof opts.src === 'function') { return opts.src(elt); } return elt.getAttribute(opts.src); } function register(elt) { elt.onload = null; elt.removeAttribute('onload'); elt.onerror = null; elt.removeAttribute('onerror'); if (indexOf.call(elts, elt) === -1) { inViewport(elt, opts, show); } } return register; } function replaceGetAttribute(elementName) { var fullname = 'HTML' + elementName + 'Element'; if (fullname in global === false) { return; } var original = global[fullname].prototype.getAttribute; global[fullname].prototype.getAttribute = function(name) { if (name === 'src') { var realSrc; for (var i = 0, max = lazyAttrs.length; i < max; i++) { realSrc = original.call(this, lazyAttrs[i]); if (realSrc) { break; } } return realSrc || original.call(this, name); } // our own lazyloader will go through theses lines // because we use getAttribute(opts.src) return original.call(this, name); }; } function merge(defaults, opts) { for (var name in defaults) { if (opts[name] === undefined) { opts[name] = defaults[name]; } } return opts; } // http://webreflection.blogspot.fr/2011/06/partial-polyfills.html function indexOf(value) { for (var i = this.length; i-- && this[i] !== value;) {} return i; } module.exports = lazyload; // export default impush; /* WEBPACK VAR INJECTION */ }.call(exports, (function() { return this; }()))) /***/ }, /* 2 */ /***/ function(module, exports) { 'use strict'; var initPhotoSwipeFromDOM = function initPhotoSwipeFromDOM(gallerySelector) { // parse slide data (url, title, size ...) from DOM elements // (children of gallerySelector) var parseThumbnailElements = function parseThumbnailElements(el) { el = el.parentNode.parentNode; var thumbElements = el.getElementsByClassName('thumb'), numNodes = thumbElements.length, items = [], figureEl, linkEl, size, type, // video or not target, item; for (var i = 0; i < numNodes; i++) { figureEl = thumbElements[i]; // // include only element nodes if (figureEl.nodeType !== 1) { continue; } linkEl = figureEl.children[0]; // size = linkEl.getAttribute('data-size').split('x'); type = linkEl.getAttribute('data-type'); target = linkEl.getAttribute('data-target'); // create slide object item = { src: linkEl.getAttribute('href'), w: parseInt(size[0], 10), h: parseInt(size[1], 10) }; if (figureEl.children.length > 1) { item.title = figureEl.children[1].innerHTML; } if (linkEl.children.length > 0) { item.msrc = linkEl.children[0].getAttribute('src'); item.type = type; item.target = target; item.html = ''; if (type === 'video') { //item.src = null; } } item.el = figureEl; // save link to element for getThumbBoundsFn items.push(item); } return items; }; // find nearest parent element var closest = function closest(el, fn) { return el && (fn(el) ? el : closest(el.parentNode, fn)); }; // triggers when user clicks on thumbnail var onThumbnailsClick = function onThumbnailsClick(e) { e = e || window.event; e.preventDefault ? e.preventDefault() : e.returnValue = false; var eTarget = e.target || e.srcElement; // find root element of slide var clickedListItem = closest(eTarget, function(el) { return el.tagName && el.tagName.toUpperCase() === 'FIGURE'; }); if (!clickedListItem) { return; } // find index of clicked item by looping through all child nodes // alternatively, you may define index via data- attribute var clickedGallery = clickedListItem.parentNode, // childNodes = clickedListItem.parentNode.childNodes, // numChildNodes = childNodes.length, childNodes = document.getElementsByClassName('thumb'), numChildNodes = childNodes.length, nodeIndex = 0, index; for (var i = 0; i < numChildNodes; i++) { if (childNodes[i].nodeType !== 1) { continue; } if (childNodes[i] === clickedListItem) { index = nodeIndex; break; } nodeIndex++; } if (index >= 0) { // open PhotoSwipe if valid index found openPhotoSwipe(index, clickedGallery); } return false; }; // parse picture index and gallery index from URL (#&pid=1&gid=2) var photoswipeParseHash = function photoswipeParseHash() { var hash = window.location.hash.substring(1), params = {}; if (hash.length < 5) { return params; } var vars = hash.split('&'); for (var i = 0; i < vars.length; i++) { if (!vars[i]) { continue; } var pair = vars[i].split('='); if (pair.length < 2) { continue; } params[pair[0]] = pair[1]; } if (params.gid) { params.gid = parseInt(params.gid, 10); } return params; }; var openPhotoSwipe = function openPhotoSwipe(index, galleryElement, disableAnimation, fromURL) { var pswpElement = document.querySelectorAll('.pswp')[0], gallery, options, items; items = parseThumbnailElements(galleryElement); // define options (if needed) options = { // define gallery index (for URL) galleryUID: galleryElement.getAttribute('data-pswp-uid'), getThumbBoundsFn: function getThumbBoundsFn(index) { // See Options -> getThumbBoundsFn section of documentation for more info var thumbnail = items[index].el.getElementsByTagName('img')[0], // find thumbnail pageYScroll = window.pageYOffset || document.documentElement.scrollTop, rect = thumbnail.getBoundingClientRect(); return { x: rect.left, y: rect.top + pageYScroll, w: rect.width }; } }; // PhotoSwipe opened from URL if (fromURL) { if (options.galleryPIDs) { // parse real index when custom PIDs are used // http://photoswipe.com/documentation/faq.html#custom-pid-in-url for (var j = 0; j < items.length; j++) { if (items[j].pid == index) { options.index = j; break; } } } else { // in URL indexes start from 1 options.index = parseInt(index, 10) - 1; } } else { options.index = parseInt(index, 10); } // exit if index not found if (isNaN(options.index)) { return; } if (disableAnimation) { options.showAnimationDuration = 0; } // Pass data to PhotoSwipe and initialize it gallery = new PhotoSwipe(pswpElement, PhotoSwipeUI_Default, items, options); gallery.init(); var $tempVideo; var stopVideoHandle = function stopVideoHandle() { if ($tempVideo) { $tempVideo.remove(); $tempVideo = null; } }; var changeHandle = function changeHandle() { var item = gallery.currItem; stopVideoHandle(); if (item.type === 'video') { var $ctn = item.container; var style = $ctn.getElementsByClassName('pswp__img')[0].style; var $video = document.createElement('video'); $video.setAttribute('autoplay', 'autoplay'); $video.setAttribute('controls', 'controls'); $video.setAttribute('src', item.target); $video.style.width = style.width; $video.style.height = style.height; $video.style.position = 'absolute'; $video.style.zIndex = 2; $tempVideo = $video; $ctn.appendChild($video); } }; gallery.listen('initialZoomIn', changeHandle); gallery.listen('afterChange', changeHandle); gallery.listen('initialZoomOut', stopVideoHandle); }; // loop through all gallery elements and bind events var galleryElements = document.querySelectorAll(gallerySelector); for (var i = 0, l = galleryElements.length; i < l; i++) { galleryElements[i].setAttribute('data-pswp-uid', i + 1); galleryElements[i].onclick = onThumbnailsClick; } // Parse URL and open gallery if it contains #&pid=3&gid=1 var hashData = photoswipeParseHash(); if (hashData.pid && hashData.gid) { openPhotoSwipe(hashData.pid, galleryElements[hashData.gid - 1], true, true); } }; var Viewer = function() { function init() { initPhotoSwipeFromDOM('.photos'); } return { init: init }; }(); module.exports = Viewer; /***/ }, /* 3 */ /***/ function(module, exports) { /* WEBPACK VAR INJECTION */ (function(global) { module.exports = inViewport; var instances = []; var supportsMutationObserver = typeof global.MutationObserver === 'function'; function inViewport(elt, params, cb) { var opts = { container: global.document.body, offset: 0 }; if (params === undefined || typeof params === 'function') { cb = params; params = {}; } var container = opts.container = params.container || opts.container; var offset = opts.offset = params.offset || opts.offset; for (var i = 0; i < instances.length; i++) { if (instances[i].container === container) { return instances[i].isInViewport(elt, offset, cb); } } return instances[ instances.push(createInViewport(container)) - 1 ].isInViewport(elt, offset, cb); } function addEvent(el, type, fn) { if (el.attachEvent) { el.attachEvent('on' + type, fn); } else { el.addEventListener(type, fn, false); } } function debounce(func, wait, immediate) { var timeout; return function() { var context = this, args = arguments; var callNow = immediate && !timeout; clearTimeout(timeout); timeout = setTimeout(later, wait); if (callNow) func.apply(context, args); function later() { timeout = null; if (!immediate) func.apply(context, args); } }; } // https://github.com/jquery/sizzle/blob/3136f48b90e3edc84cbaaa6f6f7734ef03775a07/sizzle.js#L708 var contains = function() { if (!global.document) { return true; } return global.document.documentElement.compareDocumentPosition ? function(a, b) { return !!(a.compareDocumentPosition(b) & 16); } : global.document.documentElement.contains ? function(a, b) { return a !== b && (a.contains ? a.contains(b) : false); } : function(a, b) { while (b = b.parentNode) { if (b === a) { return true; } } return false; }; } function createInViewport(container) { var watches = createWatches(); var scrollContainer = container === global.document.body ? global : container; var debouncedCheck = debounce(watches.checkAll(watchInViewport), 15); addEvent(scrollContainer, 'scroll', debouncedCheck); if (scrollContainer === global) { addEvent(global, 'resize', debouncedCheck); } if (supportsMutationObserver) { observeDOM(watches, container, debouncedCheck); } // failsafe check, every 200ms we check for visible images // usecase: a hidden parent containing eleements // when the parent becomes visible, we have no event that the children // became visible setInterval(debouncedCheck, 150); function isInViewport(elt, offset, cb) { if (!cb) { return isVisible(elt, offset); } var remote = createRemote(elt, offset, cb); remote.watch(); return remote; } function createRemote(elt, offset, cb) { function watch() { watches.add(elt, offset, cb); } function dispose() { watches.remove(elt); } return { watch: watch, dispose: dispose }; } function watchInViewport(elt, offset, cb) { if (isVisible(elt, offset)) { watches.remove(elt); cb(elt); } } function isVisible(elt, offset) { if (!contains(global.document.documentElement, elt) || !contains(global.document.documentElement, container)) { return false; } // Check if the element is visible // https://github.com/jquery/jquery/blob/740e190223d19a114d5373758127285d14d6b71e/src/css/hiddenVisibleSelectors.js if (!elt.offsetWidth || !elt.offsetHeight) { return false; } var eltRect = elt.getBoundingClientRect(); var viewport = {}; if (container === global.document.body) { viewport = { top: -offset, left: -offset, right: global.document.documentElement.clientWidth + offset, bottom: global.document.documentElement.clientHeight + offset }; } else { var containerRect = container.getBoundingClientRect(); viewport = { top: containerRect.top - offset, left: containerRect.left - offset, right: containerRect.right + offset, bottom: containerRect.bottom + offset }; } // The element must overlap with the visible part of the viewport var visible = ( (eltRect.right > viewport.left) && (eltRect.left < viewport.right) && (eltRect.bottom > viewport.top) && (eltRect.top < viewport.bottom) ); return visible; } return { container: container, isInViewport: isInViewport }; } function createWatches() { var watches = []; function add(elt, offset, cb) { if (!isWatched(elt)) { watches.push([elt, offset, cb]); } } function remove(elt) { var pos = indexOf(elt); if (pos !== -1) { watches.splice(pos, 1); } } function indexOf(elt) { for (var i = watches.length - 1; i >= 0; i--) { if (watches[i][0] === elt) { return i; } } return -1; } function isWatched(elt) { return indexOf(elt) !== -1; } function checkAll(cb) { return function() { for (var i = watches.length - 1; i >= 0; i--) { cb.apply(this, watches[i]); } }; } return { add: add, remove: remove, isWatched: isWatched, checkAll: checkAll }; } function observeDOM(watches, container, cb) { var observer = new MutationObserver(watch); var filter = Array.prototype.filter; var concat = Array.prototype.concat; observer.observe(container, { childList: true, subtree: true, // changes like style/width/height/display will be catched attributes: true }); function watch(mutations) { // some new DOM nodes where previously watched // we should check their positions if (mutations.some(knownNodes) === true) { setTimeout(cb, 0); } } function knownNodes(mutation) { var nodes = concat.call([], Array.prototype.slice.call(mutation.addedNodes), mutation.target ); return filter.call(nodes, watches.isWatched).length > 0; } } /* WEBPACK VAR INJECTION */ }.call(exports, (function() { return this; }()))) /***/ } /******/ ]);"},{"title":"","date":"2022-03-02T09:31:31.279Z","updated":"2017-07-01T04:45:00.412Z","comments":true,"path":"assets/demo/jiugongge_demo.html","permalink":"https://vlwq.github.io/assets/demo/jiugongge_demo.html","excerpt":"","text":"jiugongge_demo *{ margin:0; padding: 0; } table{ margin: 30px; border-collapse: collapse; } #test0{ margin: 30px; width: 200px; height: 200px; } #test0 div{ width: 50px; height: 50px; float: left; background: #eee; border: 5px solid #00f; text-align: center; line-height: 50px; color: #090; position: relative; } #test0 .lr_indent{ margin-left: -5px; margin-right: -5px; } #test0 .tb_indent{ margin-top: -5px; margin-bottom: -5px; } #test0 div:hover{ border: 5px solid #f00; z-index: 999; background: #eee; } #test1 td{ width: 50px; height: 50px; background: #eee; position: relative; border: 5px solid #00f; text-align: center; } #test1 td span{ color: #090; display:block; width: 50px; height: 50px; position: absolute; top: 0; left: 0; line-height: 50px; } #test1 td span:hover{ border: 5px solid #f00; margin-top:-5px; margin-left: -5px; } #test2 td{ width: 50px; height: 50px; background: #eee; border: 5px solid #00f; text-align: center; vertical-align: top; } #test2 td div{ position:relative; width: 50px; height: 50px; } #test2 td div span{ color: #090; display:block; width: 50px; height: 50px; position: absolute; top: 0; left: 0; line-height: 50px; } #test2 td div span:hover{ border: 5px solid #f00; margin-left: -5px; margin-top: -5px; } 1) div+负margin实现 1 2 3 4 5 6 7 8 9 2.1) table border-collapse: collapse实现 1 2 3 4 5 6 7 8 9 2.2) table思路改进 1 2 3 4 5 6 7 8 9"},{"title":"","date":"2022-03-02T09:31:31.280Z","updated":"2017-07-01T04:45:00.412Z","comments":true,"path":"assets/demo/jiugongge_demo2.html","permalink":"https://vlwq.github.io/assets/demo/jiugongge_demo2.html","excerpt":"","text":"九宫格（二）demo #main{ width: 170px; height:170px; background: blue; margin: 0 auto; } #main div{ width: 50px; line-height: 50px; text-align:center; background: #AAA; margin:5px 5px 0 0; } #main a{ width: 55px; line-height: 55px; float: left; padding: 0 0 5px 5px; margin: 0 -5px -5px 0; text-decoration: none; } #main a:hover{ background: red; } 1 2 3 4 5 6 7 8 9"},{"title":"","date":"2022-03-02T09:31:31.272Z","updated":"2017-07-01T04:45:00.412Z","comments":true,"path":"assets/demo/hack_demo.html","permalink":"https://vlwq.github.io/assets/demo/hack_demo.html","excerpt":"","text":"h3,h4{ text-align: center; } #main{ width: 350px; height: 100px; border: 1px solid #000; margin: 0 auto; } #main .box{ width: 100px; height: 100px; margin-left: 10px; position: relative; float: left; background: #333; color:#ddd; } #main .task1:hover{ z-index: 999; } #main .task2:hover{ z-index: 999; background: #999; } #main .task3:hover{ z-index: 999; background: #333; } 三个background为#333的box - 请在IE6，IE7中触发hover - box1 - 未设置backgorund box2 - background: #999 box3 - background: #333"},{"title":"","date":"2022-03-02T09:31:31.268Z","updated":"2017-07-01T04:45:00.396Z","comments":true,"path":"assets/demo/border1px.html","permalink":"https://vlwq.github.io/assets/demo/border1px.html","excerpt":"","text":"日语50音 /*main*/ html{color:#000;background:#FFF}body,div,dl,dt,dd,ul,ol,li,h1,h2,h3,h4,h5,h6,pre,code,form,fieldset,legend,input,textarea,p,blockquote,th,td,menu{margin:0;padding:0}table{border-collapse:collapse;border-spacing:0}fieldset,img{border:0}address,caption,cite,code,dfn,em,strong,th,var{font-style:normal;font-weight:400}ol,ul{list-style:none}caption,th{text-align:left}h1,h2,h3,h4,h5,h6{font-size:100%;font-weight:400}q:before,q:after{content:''}abbr,acronym{border:0;font-variant:normal}sup{vertical-align:text-top}sub{vertical-align:text-bottom}input,textarea,select{font-family:inherit;font-size:inherit;font-weight:inherit}input,textarea,select{*font-size:100%}legend{color:#000}html,body{-webkit-text-size-adjust:none;-webkit-touch-callout:none;vertical-align:middle;font-size:16px;background:#e6e6e6;position:relative;height:100%;font-family:Tahoma,Arial,\"Microsoft Yahei\",sans-serif}.clearfix:after{content:\" \";display:block;clear:both;visibility:hidden;line-height:0;height:0}input::-webkit-input-placeholder{color:#aaa}a,div{-webkit-tap-highlight-color:rgba(0,0,0,0)}a,a:active,a:hover{color:#0057af;text-decoration:none}header,.header{width:215px;height:58px;background:url(http://3.url.cn/qun/create_iphone/img/sprite.png) no-repeat transparent 0 0;color:#fff;line-height:58px;padding-left:64px;font-size:24px;-webkit-transform:scale(0.82) scale(0.82);-webkit-transform-origin:0 50%}.input-group{overflow:hidden;vertical-align:middle;line-height:16px;background-color:#fff;}#main-section{position:relative;height:100%;min-height:370px;overflow:hidden;}.input-group label{width:100px;padding:10px 0 10px 12px;display:inline-block;border-right:0;float:left;color:gray;-webkit-appearance:none;height:24px;line-height:24px;}.input-group .ui-select{margin-left:115px;padding:10px 24px 10px 15px;position:relative;}.input-group .select-btn{width:100%;height:24px;line-height:24px;color:#aaa;}.input-group .select-btn span.ui-text{text-align:right;display:inline-block;width:100%;white-space:nowrap;overflow:inherit;text-overflow:ellipsis;pointer-events:none;}.input-group .select-btn span.ui-icon{display:inline-block;position:absolute;top:50%;margin:-10px 0 0 -3px;width:18px;height:20px;right:7px;}.input-group .select-btn span.ui-icon .arrow{width:18px;height:18px;position:relative;display:inline-block;float:right;background:transparent;margin-right:-5px;margin-top:1px;}.input-group .select-btn span.ui-icon .arrow div{background:#ccc;position:absolute;width:3px;height:12px;}.input-group .select-btn span.ui-icon .arrow div.arrow1{left:19px;top:12px;-webkit-transform:rotate(-45deg) translate(0,-142%);}.input-group .select-btn span.ui-icon .arrow div.arrow2{left:-5px;top:19px;-webkit-transform:rotate(45deg) translate(0,-142%);}.seg-words{color:#6d6d72;height:20px;font-size:1em;text-shadow:0 1px #fff;padding:3px 0 6px 14px;} /*border-1px 部分*/ .border-1px{ position: relative; } .border-1px:before, .border-1px:after{ border-top: 1px solid #c8c7cc; content: ' '; display: block; width: 100%; position: absolute; left: 0; } .border-1px:before{ top: 0; display: none; } .border-1px:after{ bottom: 0; } @media (-webkit-min-device-pixel-ratio:1.5), (min-device-pixel-ratio: 1.5){ .border-1px:after,.border-1px:before{ -webkit-transform: scaleY(.7); -webkit-transform-origin: 0 0; transform: scaleY(.7); } .border-1px:after{ -webkit-transform-origin: left bottom; } } @media (-webkit-min-device-pixel-ratio:2), (min-device-pixel-ratio: 2){ .border-1px:after,.border-1px:before{ -webkit-transform: scaleY(.5); transform: scaleY(.5); } } あ行 あ ア (a) い イ (i) う ウ (u) え エ (e) お オ (o) か行 か カ (ka) き キ (ki) く ク (ku) け ケ (ke) こ コ (ko) さ行 さ サ (sa) し シ (shi) す ス (su) せ セ (se) そ ソ (so) た行 た タ (ta) ち チ (chi) つ ツ (tsu) て テ (te) と ト (to) な行 な ナ (na) に ニ (ni) ぬ ヌ (nu) ね ネ (ne) の ノ (no) は行 は ハ (ha) ひ ヒ (hi) ふ フ (fu) へ ヘ (he) ほ ホ (ho) ま行 ま マ (ma) み ミ (mi) む ム (mu) め メ (me) も モ (mo) や行 や ヤ (ya) い イ (i) ゆ ユ (yu) え エ (e) よ ヨ (yo) ら行 ら ラ (ra) り リ (ri) る ル (ru) れ レ (re) ろ ロ (ro) わ行 わ ワ (wa) い イ (i) う ウ (u) え エ (e) を ヲ (wo) ん ん ン (n)"},{"title":"","date":"2022-03-02T09:31:31.270Z","updated":"2017-07-01T04:45:00.412Z","comments":true,"path":"assets/demo/coffee_pc_demo/pro-con.js","permalink":"https://vlwq.github.io/assets/demo/coffee_pc_demo/pro-con.js","excerpt":"","text":"// Generated by CoffeeScript 1.4.0 (function() { var N, ProCon, func, procon; N = 10; func = function(a, b) { if (a == null) { a = 4; } if (b == null) { b = 6; } return a + b; }; ProCon = (function() { function ProCon() {} ProCon.prototype.data = { mutex: 1, empty: N, full: 0, front: 0, rear: 0, buf: [] }; ProCon.prototype.init = function() { var i, newDom, _this = this; i = 0; while (i < N) { newDom = $('' + i + '' + i + ''); $('#buf').append(newDom); this.data.buf.push('e'); i++; } $('#produce').click(function() { return _this.producer(); }); return $('#consume').click(function() { return _this.consumer(); }); }; ProCon.prototype.p = function(num) { return --num; }; ProCon.prototype.v = function(num) { return ++num; }; ProCon.prototype.produceItem = function() { $('生产了产品').insertBefore($(\"#des p:first\")); return 'm'; }; ProCon.prototype.consumeItem = function() { return $('消费了产品').insertBefore($(\"#des p:first\")); }; ProCon.prototype.enterItem = function(item) { var str; this.data.front = (this.data.front + 1) % N; this.data.buf[this.data.front] = item; str = \"存入产品\" + this.data.buf[this.data.front] + \"到缓冲区\" + this.data.front; $(\"\" + str + \"\").insertBefore($(\"#des p:first\")); return $($('.bufCover')[this.data.front]).animate({ \"height\": \"50px\" }); }; ProCon.prototype.removeItem = function() { var str; this.data.rear = (this.data.rear + 1) % N; this.data.buf[this.data.rear] = 'e'; str = \"取出产品\" + this.data.buf[this.data.rear] + \"从缓冲区\" + this.data.rear; $(\"\" + str + \"\").insertBefore($(\"#des p:first\")); return $($('.bufCover')[this.data.rear]).animate({ \"height\": \"0px\" }); }; ProCon.prototype.producer = function() { var item; if (this.data.full === N) { $(\"缓冲区已全满\").insertBefore($(\"#des p:first\")); return; } item = this.produceItem(); this.data.empty = this.p(this.data.empty); this.data.mutex = this.p(this.data.mutex); this.enterItem(item); this.data.mutex = this.v(this.data.mutex); return this.data.full = this.v(this.data.full); }; ProCon.prototype.consumer = function() { if (this.data.empty === N) { $(\"缓冲区已空\").insertBefore($(\"#des p:first\")); return; } this.data.full = this.p(this.data.full); this.data.mutex = this.p(this.data.mutex); this.removeItem(); this.data.mutex = this.v(this.data.mutex); this.data.empty = this.v(this.data.empty); return this.consumeItem(); }; return ProCon; })(); procon = new ProCon; procon.init(); }).call(this);"},{"title":"","date":"2022-03-02T09:31:31.258Z","updated":"2017-07-01T04:45:00.427Z","comments":true,"path":"assets/demo/mediator/demo.html","permalink":"https://vlwq.github.io/assets/demo/mediator/demo.html","excerpt":"","text":"*{ margin:0; padding:0; } #textBox{ position: absolute; left: 0; top: 0; z-index: -999; } #bg{ background: url(sgws.jpg) -50px; width:500px; height: 314px; text-align: center; position: relative; -webkit-animation:roll 3s infinite ease ; -moz-animation:roll 3s infinite ease ; -ms-animation:roll 3s infinite ease ; -o-animation:roll 3s infinite ease ; animation:roll 3s infinite ease ; } #barHome{ width: 300px; height: 10px; background: #f00; overflow: hidden; position: absolute; bottom: 45px; left: 50%; margin-left: -150px; } #barGuest{ width: 150px; height: 10px; background: #00f; } #results{ width: 300px; position: absolute; bottom: 65px; left: 50%; margin-left: -150px; color: #fff; } #results span{ margin: 50px; } @-webkit-keyframes roll {0%{background-position: -90px;}50%{background-position: -10px;}100%{background-position: -90px;}} @-moz-keyframes roll {0%{background-position: -90px;}50%{background-position: -10px;}100%{background-position: -90px;}} @-ms-keyframes roll {0%{background-position: -90px;}50%{background-position: -10px;}100%{background-position: -90px;}} @-o-keyframes roll {0%{background-position: -90px;}50%{background-position: -10px;}100%{background-position: -90px;}} @keyframes roll {0%{background-position: -90px;}50%{background-position: -10px;}100%{background-position: -90px;}} mediator 请按F键与J键"},{"title":"","date":"2022-03-02T09:31:31.267Z","updated":"2017-07-01T04:45:00.427Z","comments":true,"path":"assets/demo/pre_css3_demo/demo.html","permalink":"https://vlwq.github.io/assets/demo/pre_css3_demo/demo.html","excerpt":"","text":"*{ margin:0; padding: 0; } body{ overflow: hidden; } #textBox{ position: absolute; left: 0; top: 0; z-index: -999; } .showRoll #frame { border-color: hsl(0,0%,70%); position: absolute; } #box{ width: 641px; height: 483px; background: url(bg.jpg); border: 1px solid #ddd; position: relative; color: #fff; overflow: hidden; } #frame { width: 70px; height: 92px; left:370px; top:240px; position: absolute; border: 1px solid transparent; background: url(mhxy.png) no-repeat left top; -webkit-animation: anm-down 1s steps(8) infinite; -moz-animation: anm-down 1s steps(8) infinite; -ms-animation: anm-down 1s steps(8) infinite; -o-animation: anm-down 1s steps(8) infinite; animation: anm-down 1s steps(8) infinite; } @-webkit-keyframes anm-down { 0% { background-position: 0px 0; } 100% { background-position: -560px 0; } } @-moz-keyframes anm-down { 0% { background-position: 0px 0; } 100% { background-position: -560px 0; } } @-ms-keyframes anm-down { 0% { background-position: 0px 0; } 100% { background-position: -560px 0; } } @-o-keyframes anm-down { 0% { background-position: 0px 0; } 100% { background-position: -560px 0; } } @keyframes anm-down { 0% { background-position: 0px 0; } 100% { background-position: -560px 0; } } @-webkit-keyframes anm-left { 0% { background-position: 0px -92px; } 100% { background-position: -560px -92px; } } @-moz-keyframes anm-left { 0% { background-position: 0px -92px; } 100% { background-position: -560px -92px; } } @-ms-keyframes anm-left { 0% { background-position: 0px -92px; } 100% { background-position: -560px -92px; } } @-o-keyframes anm-left { 0% { background-position: 0px -92px; } 100% { background-position: -560px -92px; } } @keyframes anm-left { 0% { background-position: 0px -92px; } 100% { background-position: -560px -92px; } } @-webkit-keyframes anm-right { 0% { background-position: 0px -184px; } 100% { background-position: -560px -184px; } } @-moz-keyframes anm-right { 0% { background-position: 0px -184px; } 100% { background-position: -560px -184px; } } @-ms-keyframes anm-right { 0% { background-position: 0px -184px; } 100% { background-position: -560px -184px; } } @-o-keyframes anm-right { 0% { background-position: 0px -184px; } 100% { background-position: -560px -184px; } } @keyframes anm-right { 0% { background-position: 0px -184px; } 100% { background-position: -560px -184px; } } @-webkit-keyframes anm-up { 0% { background-position: 0px -276px; } 100% { background-position: -560px -276px; } } @-moz-keyframes anm-up { 0% { background-position: 0px -276px; } 100% { background-position: -560px -276px; } } @-ms-keyframes anm-up { 0% { background-position: 0px -276px; } 100% { background-position: -560px -276px; } } @-o-keyframes anm-up { 0% { background-position: 0px -276px; } 100% { background-position: -560px -276px; } } @keyframes anm-up { 0% { background-position: 0px -276px; } 100% { background-position: -560px -276px; } } @-webkit-keyframes anm-ld { 0% { background-position: 0px -368px; } 100% { background-position: -560px -368px; } } @-moz-keyframes anm-ld { 0% { background-position: 0px -368px; } 100% { background-position: -560px -368px; } } @-ms-keyframes anm-ld { 0% { background-position: 0px -368px; } 100% { background-position: -560px -368px; } } @-o-keyframes anm-ld { 0% { background-position: 0px -368px; } 100% { background-position: -560px -368px; } } @keyframes anm-ld { 0% { background-position: 0px -368px; } 100% { background-position: -560px -368px; } } @-webkit-keyframes anm-rd { 0% { background-position: 0px -460px; } 100% { background-position: -560px -460px; } } @-moz-keyframes anm-rd { 0% { background-position: 0px -460px; } 100% { background-position: -560px -460px; } } @-ms-keyframes anm-rd { 0% { background-position: 0px -460px; } 100% { background-position: -560px -460px; } } @-o-keyframes anm-rd { 0% { background-position: 0px -460px; } 100% { background-position: -560px -460px; } } @keyframes anm-rd { 0% { background-position: 0px -460px; } 100% { background-position: -560px -460px; } } @-webkit-keyframes anm-lu { 0% { background-position: 0px -552px; } 100% { background-position: -560px -552px; } } @-moz-keyframes anm-lu { 0% { background-position: 0px -552px; } 100% { background-position: -560px -552px; } } @-ms-keyframes anm-lu { 0% { background-position: 0px -552px; } 100% { background-position: -560px -552px; } } @-o-keyframes anm-lu { 0% { background-position: 0px -552px; } 100% { background-position: -560px -552px; } } @keyframes anm-lu { 0% { background-position: 0px -552px; } 100% { background-position: -560px -552px; } } @-webkit-keyframes anm-ru { 0% { background-position: 0px -644px; } 100% { background-position: -560px -644px; } } @-moz-keyframes anm-ru { 0% { background-position: 0px -644px; } 100% { background-position: -560px -644px; } } @-ms-keyframes anm-ru { 0% { background-position: 0px -644px; } 100% { background-position: -560px -644px; } } @-o-keyframes anm-ru { 0% { background-position: 0px -644px; } 100% { background-position: -560px -644px; } } @keyframes anm-ru { 0% { background-position: 0px -644px; } 100% { background-position: -560px -644px; } } test function setAnm (str){ switch (str){ case 'left':{ $(\"#frame\").css({\"animation\":\"anm-left 1s steps(8) infinite\"}); break; } case 'right':{ $(\"#frame\").css({\"animation\":\"anm-right 1s steps(8) infinite\"}); break; } case 'up':{ $(\"#frame\").css({\"animation\":\"anm-up 1s steps(8) infinite\"}); break; } case 'down':{ $(\"#frame\").css({\"animation\":\"anm-down 1s steps(8) infinite\"}); break; } case 'lu':{ $(\"#frame\").css({\"animation\":\"anm-lu 1s steps(8) infinite\"}); break; } case 'ld':{ $(\"#frame\").css({\"animation\":\"anm-ld 1s steps(8) infinite\"}); break; } case 'ru':{ $(\"#frame\").css({\"animation\":\"anm-ru 1s steps(8) infinite\"}); break; } case 'rd':{ $(\"#frame\").css({\"animation\":\"anm-rd 1s steps(8) infinite\"}); break; } } } var data = { x:0, y:0, l:false, r:false, u:false, d:false, time:null } function move(){ trans = \"translate(\"+data.x*50+\"px,\"+data.y*50+\"px)\"; $('#frame').css({\"transform\":trans,\"transition\":\"all 0.3s linear\"}); } function diff(){ var newTime = +new Date; if(!data.time){ data.time = newTime; } var diff = newTime-data.time; return diff; } $(window).keydown(function(event){ var keycode = event.which; if(keycode==37){ if(data.l) return; var isRun = diff(); console.log(isRun); data.l=true; if(data.u){ setAnm(\"lu\"); data.x--; if(isRun>480) data.y--; }else if(data.d){ setAnm(\"ld\"); data.x--; if(isRun>480) data.y++; }else{ setAnm(\"left\"); data.x--; } }else if(keycode==38){ if(data.u) return; var isRun = diff(); console.log(isRun); data.u=true; if(data.l){ setAnm(\"lu\"); if(isRun>480) data.x--; data.y--; }else if(data.r){ setAnm(\"ru\"); if(isRun>480) data.x++; data.y--; }else{ setAnm(\"up\"); data.y--; } }else if(keycode==39){ if(data.r) return; var isRun = diff(); console.log(isRun); data.r=true; if(data.u){ setAnm(\"ru\"); data.x++; if(isRun>480) data.y--; }else if(data.d){ setAnm(\"rd\"); data.x++; if(isRun>480) data.y++; }else{ setAnm(\"right\"); data.x++; } }else if(keycode==40){ if(data.d) return; var isRun = diff(); console.log(isRun); data.d=true; if(data.l){ setAnm(\"ld\"); if(isRun>480) data.x--; data.y++; }else if(data.r){ setAnm(\"rd\"); if(isRun>480) data.x++; data.y++; }else{ setAnm(\"down\"); data.y++; } } move(); }).keyup(function(){ data.l = data.r = data.u = data.d = false; data.time = null; });"},{"title":"","date":"2022-03-02T09:31:31.259Z","updated":"2017-07-01T04:45:00.427Z","comments":true,"path":"assets/demo/mediator/mediator.js","permalink":"https://vlwq.github.io/assets/demo/mediator/mediator.js","excerpt":"","text":"// Generated by CoffeeScript 1.4.0 (function() { var Player, mediator, scoreboard; Player = function(name) { this.points = 0; return this.name = name; }; Player.prototype.play = function() { this.points++; return mediator.played(); }; scoreboard = { element: document.getElementById(\"results\"), update: function(score) { var diff, key, msg, value; msg = ''; for (key in score) { value = score[key]; if (score.hasOwnProperty(key)) { msg = msg + (\"\" + key + \":\" + value + \"\"); } } this.element.innerHTML = msg; diff = score.Home - score.Guest; if (diff > 15) { alert(\"Home Win!\"); return location.reload(); } else if (diff < -15) { alert(\"Guest Win!\"); return location.reload(); } else { return document.getElementById('barGuest').style.width = 150 + (diff * 10) + 'px'; } } }; mediator = { players: {}, setup: function() { var players; players = this.players; players.home = new Player('Home'); return players.guest = new Player('Guest'); }, played: function() { var players, score; players = this.players; score = { Home: players.home.points, Guest: players.guest.points }; return scoreboard.update(score); }, keypress: function(e) { var keycode; e = e || window.event; keycode = e.which; if (keycode === 102) { mediator.players.home.play(); return; } if (keycode === 106) { mediator.players.guest.play(); } } }; mediator.setup(); window.onkeypress = mediator.keypress; }).call(this);"},{"title":"","date":"2022-03-02T09:31:31.271Z","updated":"2017-07-01T04:45:00.396Z","comments":true,"path":"assets/demo/coffee_pc_demo/pro-con.html","permalink":"https://vlwq.github.io/assets/demo/coffee_pc_demo/pro-con.html","excerpt":"","text":"body{ background: #fff; } .bufBox{ float: left; width: 50px; height: 50px; background: #ddd; border-radius: 5px; text-align: center; line-height: 50px; margin: 0 5px; position:relative; overflow: hidden; } .bufCover{ width: 100%; height: 0; background: #f0f; border-radius: 5px; position: absolute; } #buf{ height: 60px; } #des p{ padding: 4px 0; margin: 0; font-size: 14px; } #des .desPro{ color: #333; background: #EEE; } #des .desCon{ color: #EEE; background: #333; } #des .desSpe{ background: #BBB; } 生产 消费"},{"title":"","date":"2022-03-02T09:31:31.278Z","updated":"2017-07-01T04:45:00.427Z","comments":true,"path":"assets/demo/my_news_reader/index.html","permalink":"https://vlwq.github.io/assets/demo/my_news_reader/index.html","excerpt":"","text":"myReader *{ margin: 0; padding: 0; } body{ background: #eee; overflow-x : hidden; overflow-y : hidden; } #container{ width: 600px; height: 400px; background: #eee; position: relative; } .tag{ position: absolute; } 点击变化布局"},{"title":"","date":"2022-03-02T09:31:31.247Z","updated":"2017-07-01T04:45:00.412Z","comments":true,"path":"assets/demo/gift/css/reset.css","permalink":"https://vlwq.github.io/assets/demo/gift/css/reset.css","excerpt":"","text":"html{color:#000}blockquote,body,code,dd,div,dl,dt,fieldset,form,h1,h2,h3,h4,h5,h6,input,legend,li,menu,ol,p,pre,td,textarea,th,ul{margin:0;padding:0}table{border-collapse:collapse;border-spacing:0}fieldset,img{border:0}address,caption,cite,code,dfn,em,strong,th,var{font-style:normal;font-weight:400}ol,ul{list-style:none}caption,th{text-align:left}h1,h2,h3,h4,h5,h6{font-size:100%;font-weight:400}q:after,q:before{content:''}abbr,acronym{border:0;font-variant:normal}sup{vertical-align:text-top}sub{vertical-align:text-bottom}input,select,textarea{font-family:inherit;font-size:inherit;font-weight:inherit;*font-size:100%}legend{color:#000}body,html{-webkit-text-size-adjust:none;-webkit-touch-callout:none;vertical-align:middle;font-size:16px;background:#e6e6e6;position:relative;height:100%;font-family:Tahoma,Arial,\"Microsoft Yahei\",sans-serif}.clearfix:after{content:\" \";display:block;clear:both;visibility:hidden;line-height:0;height:0}input::-webkit-input-placeholder{color:#aaa}a,div{-webkit-tap-highlight-color:rgba(0,0,0,0)}a,a:active,a:hover{color:#0057af;text-decoration:none}"},{"title":"","date":"2022-03-02T09:31:31.244Z","updated":"2017-07-01T04:45:00.412Z","comments":true,"path":"assets/demo/gift/js/index.main.js","permalink":"https://vlwq.github.io/assets/demo/gift/js/index.main.js","excerpt":"","text":""},{"title":"","date":"2022-03-02T09:31:31.255Z","updated":"2017-07-01T04:45:00.412Z","comments":true,"path":"assets/demo/gift/index.html","permalink":"https://vlwq.github.io/assets/demo/gift/index.html","excerpt":"","text":"礼物 - 3.8 3.8节礼物，来了… 首先，你要输入我的生日 接着，摇一摇… 最后，这就是见证奇迹的时刻… 3.8节快乐！ 祝身体健康,平安长乐 请打开音量收听… var Main = (function() { function playAudio(src) { if (typeof Audio != \"undefined\") { new Audio(src).play() ; } else if (typeof device != \"undefined\") { if (device.platform == 'Android') { console.log(src); } var mediaRes = new Media(src, function onSuccess() { mediaRes.release(); }, function onError(e){ console.log(\"error playing sound: \" + JSON.stringify(e)); }); mediaRes.play(); } else { alert(\"no sound API to play: \" + src); } } window.addEventListener('shake', autoRun, false); function autoRun(){ if($(\"#myBir\").val() == \"0425\"){ $(\"#se1\").hide(); $(\"#se2\").show(); playAudio(\"media/gift.ogg\"); }else{ alert(\"生日错误\"); } } var init = function() { } return { init: init } })(); $(Main.init());"},{"title":"","date":"2022-03-02T09:31:31.242Z","updated":"2017-07-01T04:45:00.412Z","comments":true,"path":"assets/demo/gift/js/shake.js","permalink":"https://vlwq.github.io/assets/demo/gift/js/shake.js","excerpt":"","text":"/* * * Find more about this plugin by visiting * http://alxgbsn.co.uk/ * * Copyright (c) 2010-2012 Alex Gibson * Released under MIT license * */ (function (window, document) { function Shake() { //feature detect this.hasDeviceMotion = 'ondevicemotion' in window; //default velocity threshold for shake to register this.threshold = 15; //use date to prevent multiple shakes firing this.lastTime = new Date(); //accelerometer values this.lastX = null; this.lastY = null; this.lastZ = null; //create custom event if (typeof document.CustomEvent === \"function\") { this.event = new document.CustomEvent('shake', { bubbles: true, cancelable: true }); } else if (typeof document.createEvent === \"function\") { this.event = document.createEvent('Event'); this.event.initEvent('shake', true, true); } else { return false; } } //reset timer values Shake.prototype.reset = function () { this.lastTime = new Date(); this.lastX = null; this.lastY = null; this.lastZ = null; }; //start listening for devicemotion Shake.prototype.start = function () { this.reset(); if (this.hasDeviceMotion) { window.addEventListener('devicemotion', this, false); } }; //stop listening for devicemotion Shake.prototype.stop = function () { if (this.hasDeviceMotion) { window.removeEventListener('devicemotion', this, false); } this.reset(); }; //calculates if shake did occur Shake.prototype.devicemotion = function (e) { var current = e.accelerationIncludingGravity, currentTime, timeDifference, deltaX = 0, deltaY = 0, deltaZ = 0; if ((this.lastX === null) && (this.lastY === null) && (this.lastZ === null)) { this.lastX = current.x; this.lastY = current.y; this.lastZ = current.z; return; } deltaX = Math.abs(this.lastX - current.x); deltaY = Math.abs(this.lastY - current.y); deltaZ = Math.abs(this.lastZ - current.z); if (((deltaX > this.threshold) && (deltaY > this.threshold)) || ((deltaX > this.threshold) && (deltaZ > this.threshold)) || ((deltaY > this.threshold) && (deltaZ > this.threshold))) { //calculate time in milliseconds since last shake registered currentTime = new Date(); timeDifference = currentTime.getTime() - this.lastTime.getTime(); if (timeDifference > 1000) { window.dispatchEvent(this.event); this.lastTime = new Date(); } } this.lastX = current.x; this.lastY = current.y; this.lastZ = current.z; }; //event handler Shake.prototype.handleEvent = function (e) { if (typeof (this[e.type]) === 'function') { return this[e.type](e); } }; //create a new instance of shake.js. var myShakeEvent = new Shake(); myShakeEvent && myShakeEvent.start(); }(window, document));"},{"title":"","date":"2022-03-02T09:31:31.243Z","updated":"2017-07-01T04:45:00.412Z","comments":true,"path":"assets/demo/gift/js/zepto.min.js","permalink":"https://vlwq.github.io/assets/demo/gift/js/zepto.min.js","excerpt":"","text":"/* Zepto v1.1.3 - zepto event ajax form ie - zeptojs.com/license */ var Zepto=function(){function L(t){return null==t?String(t):j[T.call(t)]||\"object\"}function Z(t){return\"function\"==L(t)}function $(t){return null!=t&&t==t.window}function _(t){return null!=t&&t.nodeType==t.DOCUMENT_NODE}function D(t){return\"object\"==L(t)}function R(t){return D(t)&&!$(t)&&Object.getPrototypeOf(t)==Object.prototype}function M(t){return\"number\"==typeof t.length}function k(t){return s.call(t,function(t){return null!=t})}function z(t){return t.length>0?n.fn.concat.apply([],t):t}function F(t){return t.replace(/::/g,\"/\").replace(/([A-Z]+)([A-Z][a-z])/g,\"$1_$2\").replace(/([a-z\\d])([A-Z])/g,\"$1_$2\").replace(/_/g,\"-\").toLowerCase()}function q(t){return t in f?f[t]:f[t]=new RegExp(\"(^|\\\\s)\"+t+\"(\\\\s|$)\")}function H(t,e){return\"number\"!=typeof e||c[F(t)]?e:e+\"px\"}function I(t){var e,n;return u[t]||(e=a.createElement(t),a.body.appendChild(e),n=getComputedStyle(e,\"\").getPropertyValue(\"display\"),e.parentNode.removeChild(e),\"none\"==n&&(n=\"block\"),u[t]=n),u[t]}function V(t){return\"children\"in t?o.call(t.children):n.map(t.childNodes,function(t){return 1==t.nodeType?t:void 0})}function U(n,i,r){for(e in i)r&&(R(i[e])||A(i[e]))?(R(i[e])&&!R(n[e])&&(n[e]={}),A(i[e])&&!A(n[e])&&(n[e]=[]),U(n[e],i[e],r)):i[e]!==t&&(n[e]=i[e])}function B(t,e){return null==e?n(t):n(t).filter(e)}function J(t,e,n,i){return Z(e)?e.call(t,n,i):e}function X(t,e,n){null==n?t.removeAttribute(e):t.setAttribute(e,n)}function W(e,n){var i=e.className,r=i&&i.baseVal!==t;return n===t?r?i.baseVal:i:void(r?i.baseVal=n:e.className=n)}function Y(t){var e;try{return t?\"true\"==t||(\"false\"==t?!1:\"null\"==t?null:/^0/.test(t)||isNaN(e=Number(t))?/^[\\[\\{]/.test(t)?n.parseJSON(t):t:e):t}catch(i){return t}}function G(t,e){e(t);for(var n in t.childNodes)G(t.childNodes[n],e)}var t,e,n,i,C,N,r=[],o=r.slice,s=r.filter,a=window.document,u={},f={},c={\"column-count\":1,columns:1,\"font-weight\":1,\"line-height\":1,opacity:1,\"z-index\":1,zoom:1},l=/^\\s*]*>/,h=/^(?:|)$/,p=/]*)\\/>/gi,d=/^(?:body|html)$/i,m=/([A-Z])/g,g=[\"val\",\"css\",\"html\",\"text\",\"data\",\"width\",\"height\",\"offset\"],v=[\"after\",\"prepend\",\"before\",\"append\"],y=a.createElement(\"table\"),x=a.createElement(\"tr\"),b={tr:a.createElement(\"tbody\"),tbody:y,thead:y,tfoot:y,td:x,th:x,\"*\":a.createElement(\"div\")},w=/complete|loaded|interactive/,E=/^[\\w-]*$/,j={},T=j.toString,S={},O=a.createElement(\"div\"),P={tabindex:\"tabIndex\",readonly:\"readOnly\",\"for\":\"htmlFor\",\"class\":\"className\",maxlength:\"maxLength\",cellspacing:\"cellSpacing\",cellpadding:\"cellPadding\",rowspan:\"rowSpan\",colspan:\"colSpan\",usemap:\"useMap\",frameborder:\"frameBorder\",contenteditable:\"contentEditable\"},A=Array.isArray||function(t){return t instanceof Array};return S.matches=function(t,e){if(!e||!t||1!==t.nodeType)return!1;var n=t.webkitMatchesSelector||t.mozMatchesSelector||t.oMatchesSelector||t.matchesSelector;if(n)return n.call(t,e);var i,r=t.parentNode,o=!r;return o&&(r=O).appendChild(t),i=~S.qsa(r,e).indexOf(t),o&&O.removeChild(t),i},C=function(t){return t.replace(/-+(.)?/g,function(t,e){return e?e.toUpperCase():\"\"})},N=function(t){return s.call(t,function(e,n){return t.indexOf(e)==n})},S.fragment=function(e,i,r){var s,u,f;return h.test(e)&&(s=n(a.createElement(RegExp.$1))),s||(e.replace&&(e=e.replace(p,\"\")),i===t&&(i=l.test(e)&&RegExp.$1),i in b||(i=\"*\"),f=b[i],f.innerHTML=\"\"+e,s=n.each(o.call(f.childNodes),function(){f.removeChild(this)})),R(r)&&(u=n(s),n.each(r,function(t,e){g.indexOf(t)>-1?u[t](e):u.attr(t,e)})),s},S.Z=function(t,e){return t=t||[],t.__proto__=n.fn,t.selector=e||\"\",t},S.isZ=function(t){return t instanceof S.Z},S.init=function(e,i){var r;if(!e)return S.Z();if(\"string\"==typeof e)if(e=e.trim(),\""},{"title":"","date":"2022-03-02T09:31:31.275Z","updated":"2017-07-01T04:45:00.427Z","comments":true,"path":"assets/demo/my_news_reader/js/main.js","permalink":"https://vlwq.github.io/assets/demo/my_news_reader/js/main.js","excerpt":"","text":"function H$(i){return document.getElementById(i);} function H$$(c,p){ if(p) return p.getElementsByTagName(c); else return document.getElementsByTagName(c); } var tagElems = []; (function() { function ranOrNot(e, t) { var n = []; typeof t == \"undefined\" && (t = e, e = 0); for (; e < t; e++) n.push(e); return n } Array.prototype.randomEach = function(t) { if (typeof t != \"function\") throw new TypeError; var n = this.length, r = ranOrNot(n); while (n) { var i = Math.floor(Math.random() * n--); if (t(this[r[i]]) === !1) break; r[i] = r[n] } }, Array.prototype.forEach || (Array.prototype.forEach = function(e) { var t = this.length; if (typeof e != \"function\") throw new TypeError; var n = arguments[1]; for (var r = 0; r < t; r++) r in this && e.call(n, this[r], r, this) }) } )(); function _shadowClone(e) { var t = {}; for (var n in e) e.hasOwnProperty(n) && (t[n] = e[n]); return t; } function attrStyle(elem,attr){ if(elem.style[attr]){ return elem.style[attr]; }else if(elem.currentStyle){ return elem.currentStyle[attr]; }else if(document.defaultView && document.defaultView.getComputedStyle){ attr=attr.replace(/([A-Z])/g,'-$1').toLowerCase(); return document.defaultView.getComputedStyle(elem,null).getPropertyValue(attr); }else{ return null; } } /////////////////////////// function AutoLoader(fun, timeout) { if (typeof fun != \"function\") throw new TypeError; this._generator = fun; this._timeout = timeout; this._context = arguments[2]; this._pool = []; } AutoLoader.prototype._load = function() { var e = this; clearTimeout(this._loading); this._loading = setTimeout(function() { e._pool.push(e._generator.apply(e._context)) }, this._timeout); } AutoLoader.prototype.get = function() { var e; clearTimeout(this._loading); this._pool.length > 0 ? e = this._pool.pop() : e = this._generator.apply(this._context); return e; } function _cutGrid(tag, funcJudge) { function a(a) { function h(cutLength) { var u, a = _shadowClone(cutLength); c++, u = c === l ? tag[cutType2.measure] - s: Math.floor(cutLength[cutType2.measure] * tag[cutType2.measure] / 100), a[cutType1.offset] = i + tag[cutType1.offset], a[cutType2.offset] = s + tag[cutType2.offset], a[cutType1.measure] = f, a[cutType2.measure] = u, a.colorPattern = tag.colorPattern, funcJudge(a), s += u } var f, l = a[cutType2.name].length, c = 0; u++, f = u === cutLength ? tag[cutType1.measure] - i: Math.floor(a[cutType1.measure] * tag[cutType1.measure] / 100), a.random === !1 ? a[cutType2.name].forEach(h) : a[cutType2.name].randomEach(h), s = 0, i += f } /*根据大块是否有rows属性，定义两种切割方式*/ var cutType1, cutType2; tag.rows ? (cutType1 = { name: \"rows\", measure: \"height\", offset: \"top\" }, cutType2 = { name: \"cols\", measure: \"width\", offset: \"left\" }) : (cutType1 = { name: \"cols\", measure: \"width\", offset: \"left\" }, cutType2 = { name: \"rows\", measure: \"height\", offset: \"top\" }); var i = 0, s = 0, cutLength = tag[cutType1.name].length, u = 0; tag.random === !1 ? tag[cutType1.name].forEach(a) : tag[cutType1.name].randomEach(a) } function _getGrids(tag) { var t = [], colorCount = 0, fontScale = .18, colorArr = tag.colorPatterns[0]; _cutGrid(tag.pageLayout, function(tag) { /*如果是新的大块，则colorPattern不存在，使用新的颜色。*/ tag.colorPattern || (tag.colorPattern = colorArr[colorCount++]); /*tagConfig本来没有rows或cols，是大块。执行else部分*/ if (tag.rows || tag.cols) { _cutGrid(tag, arguments.callee); } else { var s = tag.colorPattern, o = s.backgrounds, u = o.length, a = s.fontColor; tag.fontSize = Math.floor(Math.sqrt(tag.width * tag.height) * fontScale); tag.backgroundColor = o[Math.floor(Math.random() * u)]; tag.fontColor = a; t.push(tag); } } ); return t; } var myReader = function(){ function inits(o){ this.dom = H$(o.domId); this.len = o.len; this.block = o.block; this.fillStage(H$(\"container\")); this.clickEve(); } inits.prototype={ clickEve:function(){ var _this=this; var dom = H$$(\"button\"); dom[0].onclick=function(){ H$(\"container\").innerHTML=\"\"; _this.fillStage(H$(\"container\")); } }, reflowTagElem:function(dom, t,sw,sh) { dom.style.top = t.top*sh + \"px\"; dom.style.left = t.left*sw + \"px\"; dom.style.width = t.width*sw - 2 + \"px\"; dom.style.height = t.height*sh - 2 + \"px\"; dom.style.fontSize = t.fontSize*sw + \"px\"; dom.style.color = t.fontColor; dom.style.backgroundColor = t.backgroundColor; dom.order = t.width*sw * t.height*sh; }, fillStage:function(dom) { var _this=this; var data = _getGrids(window.tagConfig); data.forEach(function(data) { var div = document.createElement(\"div\"); div.className = \"tag\"; _this.reflowTagElem(div, data,6,4); dom.appendChild(div); tagElems.push(div); }); } } return inits; }(); var myData = { domId:\"container\" } new myReader(myData);"},{"title":"","date":"2022-03-02T09:31:31.246Z","updated":"2017-07-01T04:45:00.412Z","comments":true,"path":"assets/demo/gift/css/index.css","permalink":"https://vlwq.github.io/assets/demo/gift/css/index.css","excerpt":"","text":"body{background:#f7f7f5;font-family:\"Helvetica Neue\",Helvetica,STHeiTi,sans-serif}header{height:44px;border-bottom:1px solid #000;background:#272c2f}header p{color:#fff;text-align:center;font-size:20px;line-height:40px}.hide{display:none}.paper-t{display:block;height:16px;width:100%;background:url(../img/paper.jpg) repeat-x;background-size:320px 15px}.paper-b{display:block;height:19px;width:100%;background:url(../img/paper-b.jpg) repeat-x;background-size:100% 19px;position:absolute;bottom:0px}.main{color:#2495e1;margin:-61px 8px 0px;height:100%;position:relative}.main .main-top{padding-top:61px;font-weight:500}.main .main-top .main-top-l{float:left}.main .main-top .main-top-r{float:right}.main .main-top:after{content:\"\";display:block;clear:both}.main .main-middle{font-size:98px;font-weight:500;text-align:center;line-height:141px}.main .main-bottom{width:100%;position:absolute;bottom:8px}.main .main-bottom nav{border:1px solid #2495e1;border-radius:3px;height:25px}.main .main-bottom nav span{float:left;display:inline-block;border-right:1px solid #2495e1;height:100%;width:33.1%;text-align:center;font-size:14px;line-height:26px}.main .main-bottom nav span:last-child{border-right:none}.main .main-bottom nav span.cur{background:#2495e1;color:#fff}.main .main-bottom .good-bad{height:140px;padding:20px 10px 10px}.main .main-bottom .good-bad em{display:inline-block;width:30px;height:30px;border-radius:15px;color:#fff;background:#2495e1;text-align:center;line-height:30px;float:left}.main .main-bottom .good-bad ul{padding-left:45px}.main .main-bottom .good-bad ul li{margin-bottom:13px}.main .main-bottom .good-bad ul p{font-size:18px;font-weight:500}.main .main-bottom .good-bad ul h3{font-size:30px;margin:23px 0px}.main .main-bottom .good-bad ul span{font-size:13px;color:#808080;margin-left:12px;display:block}.main .main-bottom .good-bad ul span:before{width:13px;height:11px;font-size:20px;font-weight:400;font-family:Georgia;content:\"\\201C\";position:absolute;color:#808080;left:56px}.main .main-bottom .good{border-bottom:1px solid #dfdfdf}.main .main-bottom .nav-chose .good{border-bottom:1px solid rgba(0,0,0,0)}.nav-chose .good-bad{text-align:center}.nav-chose .good-bad img{width:130px;margin-top:28px}.nav-chose .good-bad h2{margin:4px}.nav-chose .good-bad span{color:#666;margin:0 5px}.nav-chose .good-bad section{display:none}.nav-chose .good-bad section h3{display:none}.nav-chose .good-bad section.active{display:block} .top2{ text-align: center; margin-top: 40px; } .top2 p{ margin: 10px 0px; color:#2495e1; } .top2 input{ height: 30px; padding: 5px; border-radius: 3px; border: 2px solid #2495e1; outline: none; } .top2 img{ width: 43%; }"},{"title":"","date":"2022-03-02T09:31:31.277Z","updated":"2017-07-01T04:45:00.427Z","comments":true,"path":"assets/demo/my_news_reader/js/tagConfig.js","permalink":"https://vlwq.github.io/assets/demo/my_news_reader/js/tagConfig.js","excerpt":"","text":"window.tagConfig = { areas: { cols_40_60: [{ width: 40, rows: [{ height: 100 }] }, { width: 60, rows: [{ height: 100 }] }], cols_50_50: [{ width: 50, rows: [{ height: 100 }] }, { width: 50, rows: [{ height: 100 }] }], cols_32_32_36: [{ width: 32, rows: [{ height: 100 }] }, { width: 32, rows: [{ height: 100 }] }, { width: 36, rows: [{ height: 100 }] }] } }, window.tagConfig.pageLayout = { top: 0, left: 0, width: 100, height: 100, random: !1, cols: [{ width: 45, rows: [{ random: !1, height: 100, rows: [{ height: 45, cols: [{ width: 100 }] }, { height: 30, cols: [{ width: 100 }] }, { height: 25, cols: [{ width: 100, cols: [{ width: 35, rows: [{ height: 100 }] }, { width: 25, rows: [{ height: 30 }, { height: 40 }, { height: 30 }] }, { width: 15, rows: [{ height: 40 }, { height: 60 }] }, { width: 25, rows: [{ height: 35 }, { height: 25 }, { height: 40 }] }] }] }] }] }, { width: 55, random: !1, rows: [{ height: 50, cols: [{ width: 45, rows: [{ height: 35, cols: window.tagConfig.areas.cols_50_50 }, { height: 35, cols: window.tagConfig.areas.cols_40_60 }, { height: 30 }] }, { width: 55, rows: [{ height: 50 }, { height: 50 }] }] }, { height: 28, cols: [{ width: 30, rows: [{ height: 100 }] }, { width: 30, rows: [{ height: 40 }, { height: 60, cols: window.tagConfig.areas.cols_40_60 }] }, { width: 40, rows: [{ height: 50, cols: window.tagConfig.areas.cols_50_50 }, { height: 50, cols: window.tagConfig.areas.cols_32_32_36 }] }] }, { height: 22, cols: [{ width: 35, rows: [{ height: 100 }] }, { width: 15, rows: [{ height: 50 }, { height: 50 }] }, { width: 15, rows: [{ height: 50 }, { height: 50 }] }, { width: 20, rows: [{ height: 32 }, { height: 32 }, { height: 36 }] }, { width: 15, rows: [{ height: 50 }, { height: 50 }] }] }] }] }, window.tagConfig.colorPatterns = [[{ backgrounds: [\"#ce5f52\", \"#e37063\"], fontColor: \"#FFF\", borderColor: \"#5c666f\" }, { backgrounds: [\"#6c5d56\", \"#746760\"], fontColor: \"#FFF\", borderColor: \"#5c666f\" }, { backgrounds: [\"#c8b66a\", \"#dbc877\"], fontColor: \"#FFF\", borderColor: \"#5c666f\" }, { backgrounds: [\"#6e96b1\", \"#82a8bf\"], fontColor: \"#FFF\", borderColor: \"#5c666f\" }]];"},{"title":"","date":"2022-03-02T09:31:31.261Z","updated":"2017-07-01T04:45:00.427Z","comments":true,"path":"assets/demo/jquery.js","permalink":"https://vlwq.github.io/assets/demo/jquery.js","excerpt":"","text":"/*! jQuery v@1.8.0 jquery.com | jquery.org/license */ (function(a,b){function G(a){var b=F[a]={};return p.each(a.split(s),function(a,c){b[c]=!0}),b}function J(a,c,d){if(d===b&&a.nodeType===1){var e=\"data-\"+c.replace(I,\"-$1\").toLowerCase();d=a.getAttribute(e);if(typeof d==\"string\"){try{d=d===\"true\"?!0:d===\"false\"?!1:d===\"null\"?null:+d+\"\"===d?+d:H.test(d)?p.parseJSON(d):d}catch(f){}p.data(a,c,d)}else d=b}return d}function K(a){var b;for(b in a){if(b===\"data\"&&p.isEmptyObject(a[b]))continue;if(b!==\"toJSON\")return!1}return!0}function ba(){return!1}function bb(){return!0}function bh(a){return!a||!a.parentNode||a.parentNode.nodeType===11}function bi(a,b){do a=a[b];while(a&&a.nodeType!==1);return a}function bj(a,b,c){b=b||0;if(p.isFunction(b))return p.grep(a,function(a,d){var e=!!b.call(a,d,a);return e===c});if(b.nodeType)return p.grep(a,function(a,d){return a===b===c});if(typeof b==\"string\"){var d=p.grep(a,function(a){return a.nodeType===1});if(be.test(b))return p.filter(b,d,!c);b=p.filter(b,d)}return p.grep(a,function(a,d){return p.inArray(a,b)>=0===c})}function bk(a){var b=bl.split(\"|\"),c=a.createDocumentFragment();if(c.createElement)while(b.length)c.createElement(b.pop());return c}function bC(a,b){return a.getElementsByTagName(b)[0]||a.appendChild(a.ownerDocument.createElement(b))}function bD(a,b){if(b.nodeType!==1||!p.hasData(a))return;var c,d,e,f=p._data(a),g=p._data(b,f),h=f.events;if(h){delete g.handle,g.events={};for(c in h)for(d=0,e=h[c].length;d"}],"posts":[{"title":"Nodejs 识别图片类型","slug":"2017node/20200403","date":"2021-04-02T16:00:00.000Z","updated":"2022-03-02T10:19:40.534Z","comments":true,"path":"2021/04/03/2017node/20200403/","link":"","permalink":"https://vlwq.github.io/2021/04/03/2017node/20200403/","excerpt":"通过切文件名称后缀来获得图片格式的方式是不准确的，因为文件后缀是可以被强行更改的，这样一个.gif 图片也可以被保存成.jpg, 那么在 Node 上我们如何做文件类型的校验呢 ##通过文件头标识判断图片格式其实很简单，每个图片文件都有文件头标识，各种格式的图片的文件头标识都是不一样，所以可以通过判断文件头的标识来识别图片格式。 通过在网上找资料，汇总了如下的 图片文件头标识: 1234567891011121.JPEG/JPG - 文件头标识 (2 bytes): ff, d8 文件结束标识 (2 bytes): ff, d92.TGA - 未压缩的前 5 字节 00 00 02 00 00 - RLE 压缩的前 5 字节 00 00 10 00 003.PNG - 文件头标识 (8 bytes) 89 50 4E 47 0D 0A 1A 0A4.GIF - 文件头标识 (6 bytes) 47 49 46 38 39(37) 615.BMP - 文件头标识 (2 bytes) 42 4D B M6.PCX - 文件头标识 (1 bytes) 0A7.TIFF - 文件头标识 (2 bytes) 4D 4D 或 49 498.ICO - 文件头标识 (8 bytes) 00 00 01 00 01 00 20 209.CUR - 文件头标识 (8 bytes) 00 00 02 00 01 00 20 2010.IFF - 文件头标识 (4 bytes) 46 4F 52 4D11.ANI - 文件头标识 (4 bytes) 52 49 46 46知识点: 1 字节(bytes) = 8 bits,上面的数字均为 16 进制也就占 4bits 空间,每两个 16 进制数字占一字节","text":"通过切文件名称后缀来获得图片格式的方式是不准确的，因为文件后缀是可以被强行更改的，这样一个.gif 图片也可以被保存成.jpg, 那么在 Node 上我们如何做文件类型的校验呢 ##通过文件头标识判断图片格式其实很简单，每个图片文件都有文件头标识，各种格式的图片的文件头标识都是不一样，所以可以通过判断文件头的标识来识别图片格式。 通过在网上找资料，汇总了如下的 图片文件头标识: 1234567891011121.JPEG/JPG - 文件头标识 (2 bytes): ff, d8 文件结束标识 (2 bytes): ff, d92.TGA - 未压缩的前 5 字节 00 00 02 00 00 - RLE 压缩的前 5 字节 00 00 10 00 003.PNG - 文件头标识 (8 bytes) 89 50 4E 47 0D 0A 1A 0A4.GIF - 文件头标识 (6 bytes) 47 49 46 38 39(37) 615.BMP - 文件头标识 (2 bytes) 42 4D B M6.PCX - 文件头标识 (1 bytes) 0A7.TIFF - 文件头标识 (2 bytes) 4D 4D 或 49 498.ICO - 文件头标识 (8 bytes) 00 00 01 00 01 00 20 209.CUR - 文件头标识 (8 bytes) 00 00 02 00 01 00 20 2010.IFF - 文件头标识 (4 bytes) 46 4F 52 4D11.ANI - 文件头标识 (4 bytes) 52 49 46 46知识点: 1 字节(bytes) = 8 bits,上面的数字均为 16 进制也就占 4bits 空间,每两个 16 进制数字占一字节 ##如何判断通过将图片资源的二进制流与该标识做比对，即可判断图片格式。 因为实现逻辑非常简单，具体的实现逻辑看代码和注释就就好，在这里贡献出来给大家参考，方便大家开发使用。 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950function getImageSuffix(fileBuffer) &#123; // 将上文提到的 文件标识头 按 字节 整理到数组中 const imageBufferHeaders = [ &#123; bufBegin: [0xff, 0xd8], bufEnd: [0xff, 0xd9], suffix: &#x27;.jpg&#x27; &#125;, &#123; bufBegin: [0x00, 0x00, 0x02, 0x00, 0x00], suffix: &#x27;.tga&#x27; &#125;, &#123; bufBegin: [0x00, 0x00, 0x10, 0x00, 0x00], suffix: &#x27;.rle&#x27; &#125;, &#123; bufBegin: [0x89, 0x50, 0x4e, 0x47, 0x0d, 0x0a, 0x1a, 0x0a], suffix: &#x27;.png&#x27; &#125;, &#123; bufBegin: [0x47, 0x49, 0x46, 0x38, 0x39, 0x61], suffix: &#x27;.gif&#x27; &#125;, &#123; bufBegin: [0x47, 0x49, 0x46, 0x38, 0x37, 0x61], suffix: &#x27;.gif&#x27; &#125;, &#123; bufBegin: [0x42, 0x4d], suffix: &#x27;.bmp&#x27; &#125;, &#123; bufBegin: [0x0a], suffix: &#x27;.pcx&#x27; &#125;, &#123; bufBegin: [0x49, 0x49], suffix: &#x27;.tif&#x27; &#125;, &#123; bufBegin: [0x4d, 0x4d], suffix: &#x27;.tif&#x27; &#125;, &#123; bufBegin: [0x00, 0x00, 0x01, 0x00, 0x01, 0x00, 0x20, 0x20], suffix: &#x27;.ico&#x27; &#125;, &#123; bufBegin: [0x00, 0x00, 0x02, 0x00, 0x01, 0x00, 0x20, 0x20], suffix: &#x27;.cur&#x27; &#125;, &#123; bufBegin: [0x46, 0x4f, 0x52, 0x4d], suffix: &#x27;.iff&#x27; &#125;, &#123; bufBegin: [0x52, 0x49, 0x46, 0x46], suffix: &#x27;.ani&#x27; &#125; ] for (const imageBufferHeader of imageBufferHeaders) &#123; let isEqual // 判断标识头前缀 if (imageBufferHeader.bufBegin) &#123; const buf = Buffer.from(imageBufferHeader.bufBegin) isEqual = buf.equals( //使用 buffer.slice 方法 对 buffer 以字节为单位切割 fileBuffer.slice(0, imageBufferHeader.bufBegin.length) ) &#125; // 判断标识头后缀 if (isEqual &amp;&amp; imageBufferHeader.bufEnd) &#123; const buf = Buffer.from(imageBufferHeader.bufEnd) isEqual = buf.equals(fileBuffer.slice(-imageBufferHeader.bufEnd.length)) &#125; if (isEqual) &#123; return imageBufferHeader.suffix &#125; &#125; // 未能识别到该文件类型 return &#x27;&#x27;&#125;","categories":[],"tags":[{"name":"node","slug":"node","permalink":"https://vlwq.github.io/tags/node/"}]},{"title":"Random alpha-numeric string in JavaScript","slug":"2017node/20200606","date":"2020-06-05T16:00:00.000Z","updated":"2022-03-02T09:59:01.238Z","comments":true,"path":"2020/06/06/2017node/20200606/","link":"","permalink":"https://vlwq.github.io/2020/06/06/2017node/20200606/","excerpt":"I just came across this as a really nice and elegant solution: 1Math.random().toString(36).slice(2) Notes on this implementation:","text":"I just came across this as a really nice and elegant solution: 1Math.random().toString(36).slice(2) Notes on this implementation: This will produce a string anywhere between zero and 12 characters long, usually 11 characters, due to the fact that floating point stringification removes trailing zeros.It won’t generate capital letters, only lower-case and numbers.Because the randomness comes from Math.random(), the output may be predictable and therefore not necessarily unique.Even assuming an ideal implementation, the output has at most 52 bits of entropy, which means you can expect a duplicate after around 70M strings generated.","categories":[],"tags":[{"name":"node","slug":"node","permalink":"https://vlwq.github.io/tags/node/"}]},{"title":"Docker: 上传镜像至私有仓库","slug":"2016linux/20200512","date":"2020-05-11T16:00:00.000Z","updated":"2022-03-03T03:43:22.792Z","comments":true,"path":"2020/05/12/2016linux/20200512/","link":"","permalink":"https://vlwq.github.io/2020/05/12/2016linux/20200512/","excerpt":"上传镜像要上传镜像到私有仓库，需要在镜像的 tag 上加入仓库地址： 1docker tag express-app 111.111.111.111:5000/sunhengzhe/express-app:v1 为了不与其他镜像冲突，可以加入命名空间如 sunhengzhe，另外最好给镜像打上 tag 如 v1。 注意仓库地址没有加协议部分，docker 默认的安全策略需要仓库是支持 https 的，如果服务器只能使用 http 传输，那么直接上传会失败，需要在 docker 客户端的配置文件中进行声明。","text":"上传镜像要上传镜像到私有仓库，需要在镜像的 tag 上加入仓库地址： 1docker tag express-app 111.111.111.111:5000/sunhengzhe/express-app:v1 为了不与其他镜像冲突，可以加入命名空间如 sunhengzhe，另外最好给镜像打上 tag 如 v1。 注意仓库地址没有加协议部分，docker 默认的安全策略需要仓库是支持 https 的，如果服务器只能使用 http 传输，那么直接上传会失败，需要在 docker 客户端的配置文件中进行声明。 推送镜像打完 tag 后使用 push 命令推送即可： 1docker push 111.111.111.111:5000/sunhengzhe/express-app:v1","categories":[],"tags":[{"name":"linux","slug":"linux","permalink":"https://vlwq.github.io/tags/linux/"}]},{"title":"删除 Docker 镜像","slug":"2016linux/20200511","date":"2020-05-10T16:00:00.000Z","updated":"2022-03-03T03:43:12.692Z","comments":true,"path":"2020/05/11/2016linux/20200511/","link":"","permalink":"https://vlwq.github.io/2020/05/11/2016linux/20200511/","excerpt":"Docker rmidocker rmi 通过镜像的 ID 删除镜像。 要删除镜像，首先需要列出所有镜像以获取镜像的 ID，镜像的名称和其他详细信息。 运行简单的命令 docker images -a 或 docker images。之后，明确要删除哪个镜像，然后执行简单命令 docker rmi 。然后，列出所有镜像并检查，可以确认镜像是否已删除。 一次删除多张镜像当你要一次删除多张镜像时，可以使用一种方法。首先只需列出镜像即可获取镜像的 ID，然后执行简单的命令： docker rmi … 列出镜像的 ID，每个 ID 之间留一个空格。 一次删除所有镜像要删除所有镜像，有一个简单的命令可以做到： docker rmi $(docker images -q)。 在上面的命令中，有两个命令，第一个在 $() 中执行的命令是 shell 语法，返回以该执行的结果。然后，-q- 是一个选项，用于返回唯一的 ID。$() 返回镜像 ID 的结果，然后 docker rmi 删除所有这些镜像。","text":"Docker rmidocker rmi 通过镜像的 ID 删除镜像。 要删除镜像，首先需要列出所有镜像以获取镜像的 ID，镜像的名称和其他详细信息。 运行简单的命令 docker images -a 或 docker images。之后，明确要删除哪个镜像，然后执行简单命令 docker rmi 。然后，列出所有镜像并检查，可以确认镜像是否已删除。 一次删除多张镜像当你要一次删除多张镜像时，可以使用一种方法。首先只需列出镜像即可获取镜像的 ID，然后执行简单的命令： docker rmi … 列出镜像的 ID，每个 ID 之间留一个空格。 一次删除所有镜像要删除所有镜像，有一个简单的命令可以做到： docker rmi $(docker images -q)。 在上面的命令中，有两个命令，第一个在 $() 中执行的命令是 shell 语法，返回以该执行的结果。然后，-q- 是一个选项，用于返回唯一的 ID。$() 返回镜像 ID 的结果，然后 docker rmi 删除所有这些镜像。 Docker rmdocker rm 根据容器的名称或者 ID 来删除容器。 如果 Docker 容器正在运行，你在删除它们之前需要先停止运行。 停止所有容器运行： docker stop $(docker ps -a -q) 删除所有停止运行的容器： docker rm $(docker ps -a -q) 删除多个容器你可以通过向命令传递要删除的容器列表来停止和删除多个容器。shell 语法 $() 返回括号中执行的任何结果。因此，你可以在其中创建容器列表，以传递给 stop 和 rm 命令。 docker ps -a -q 分解docker ps 列出容器。-a 这个选项用于列出所有容器，包括停止运行的。如果没有这个选项，则默认只列出在运行的容器。-q 这个选项列出容器的数字 ID，而不是容器的所有信息。","categories":[],"tags":[{"name":"linux","slug":"linux","permalink":"https://vlwq.github.io/tags/linux/"}]},{"title":"How to squash all commits on branch","slug":"2018git/20200510","date":"2020-05-09T16:00:00.000Z","updated":"2022-03-03T03:43:01.714Z","comments":true,"path":"2020/05/10/2018git/20200510/","link":"","permalink":"https://vlwq.github.io/2020/05/10/2018git/20200510/","excerpt":"Another way to squash all your commits is to reset the index to master: 1234git checkout yourBranchgit reset $(git merge-base master $(git branch --show-current))git add -Agit commit -m &quot;one commit on yourBranch&quot; This isn’t perfect as it implies you know from which branch “yourBranch” is coming from.Note: finding that origin branch isn’t easy&#x2F;possible with Git (the visual way is often the easiest, as seen here). Note: git branch --show-current has been introduced with Git 2.22 (Q1 20219). EDIT: you will need to use git push --force Karlotcha Hoa adds in the comments: For the reset, you can do 1git reset $(git merge-base master $(git rev-parse --abbrev-ref HEAD)) [That] automatically uses the branch you are currently on.And if you use that, you can also use an alias, as the command doesn’t rely on the branch name. sschoof adds in the comments: Since my default branch is called main and my search had multi times brought me here:To copy it for my next time 1git reset $(git merge-base main $(git rev-parse --abbrev-ref HEAD))","text":"Another way to squash all your commits is to reset the index to master: 1234git checkout yourBranchgit reset $(git merge-base master $(git branch --show-current))git add -Agit commit -m &quot;one commit on yourBranch&quot; This isn’t perfect as it implies you know from which branch “yourBranch” is coming from.Note: finding that origin branch isn’t easy&#x2F;possible with Git (the visual way is often the easiest, as seen here). Note: git branch --show-current has been introduced with Git 2.22 (Q1 20219). EDIT: you will need to use git push --force Karlotcha Hoa adds in the comments: For the reset, you can do 1git reset $(git merge-base master $(git rev-parse --abbrev-ref HEAD)) [That] automatically uses the branch you are currently on.And if you use that, you can also use an alias, as the command doesn’t rely on the branch name. sschoof adds in the comments: Since my default branch is called main and my search had multi times brought me here:To copy it for my next time 1git reset $(git merge-base main $(git rev-parse --abbrev-ref HEAD))","categories":[],"tags":[{"name":"git","slug":"git","permalink":"https://vlwq.github.io/tags/git/"}]},{"title":"001 中国社会各阶级的分析","slug":"2019毛选1/20190501","date":"2019-05-01T02:36:00.000Z","updated":"2022-03-03T03:49:57.337Z","comments":true,"path":"2019/05/01/2019毛选1/20190501/","link":"","permalink":"https://vlwq.github.io/2019/05/01/2019%E6%AF%9B%E9%80%891/20190501/","excerpt":"","text":"001 中国社会各阶级的分析 （一九二五年十二月一日） 毛泽东此文是为反对当时党内存在着的两种倾向而写的。当时党内的第一种倾向，以陈独秀为代表，只注意同国民党合作，忘记了农民，这是右倾机会主义。第二种倾向，以张国焘为代表，只注意工人运动，同样忘记了农民，这是“左”倾机会主义。这两种机会主义都感觉自己力量不足，而不知道到何处去寻找力量，到何处去取得广大的同盟军。毛泽东指出中国无产阶级的最广大和最忠实的同盟军是农民，这样就解决了中国革命中的最主要的同盟军问题。毛泽东并且预见到当时的民族资产阶级是一个动摇的阶级，他们在革命高涨时将要分化，其右翼将要跑到帝国主义方面去。一九二七年所发生的事变，证明了这一点。 谁是我们的敌人？谁是我们的朋友？这个问题是革命的首要问题。中国过去一切革命斗争成效甚少，其基本原因就是因为不能团结真正的朋友，以攻击真正的敌人。革命党是群众的向导，在革命中未有革命党领错了路而革命不失败的。我们的革命要有不领错路和一定成功的把握，不可不注意团结我们的真正的朋友，以攻击我们的真正的敌人。我们要分辨真正的敌友，不可不将中国社会各阶级的经济地位及其对于革命的态度，作一个大概的分析。 中国社会各阶级的情况是怎样的呢？ 地主阶级和买办阶级。在经济落后的半殖民地的中国，地主阶级和买办阶级完全是国际资产阶级的附庸，其生存和发展，是附属于帝国主义的。这些阶级代表中国最落后的和最反动的生产关系，阻碍中国生产力的发展。他们和中国革命的目的完全不相容。特别是大地主阶级和大买办阶级，他们始终站在帝国主义一边，是极端的反革命派。其政治代表是国家主义派⑴和国民党右派。 中产阶级。这个阶级代表中国城乡资本主义的生产关系。中产阶级主要是指民族资产阶级，他们对于中国革命具有矛盾的态度：他们在受外资打击、军阀压迫感觉痛苦时，需要革命，赞成反帝国主义反军阀的革命运动；但是当着革命在国内有本国无产阶级的勇猛参加，在国外有国际无产阶级的积极援助，对于其欲达到大资产阶级地位的阶级的发展感觉到威胁时，他们又怀疑革命。其政治主张为实现民族资产阶级一阶级统治的国家。有一个自称为戴季陶⑵“真实信徒”的，在北京《晨报》⑶上发表议论说：“举起你的左手打倒帝国主义，举起你的右手*****。”这两句话，画出了这个阶级的矛盾惶遽状态。他们反对以阶级斗争学说解释国民党的民生主义，他们反对国民党联俄和容纳共产党⑷及左派分子。但是这个阶级的企图——实现民族资产阶级统治的国家，是完全行不通的，因为现在世界上的局面，是革命和反革命两大势力作最后斗争的局面。这两大势力竖起了两面大旗：一面是红色的革命的大旗，第三国际⑸高举着，号召全世界一切被压迫阶级集合于其旗帜之下；一面是白色的反革命的大旗，国际联盟⑹高举着，号召全世界一切反革命分子集合于其旗帜之下。那些中间阶级，必定很快地分化，或者向左跑入革命派，或者向右跑入反革命派，没有他们“独立”的余地。所以，中国的中产阶级，以其本阶级为主体的“独立”革命思想，仅仅是一个幻想。 小资产阶级。如自耕农⑺，手工业主，小知识阶层——学生界、中小学教员、小员司、小事务员、小律师，小商人等都属于这一类。这一个阶级，在人数上，在阶级性上，都值得大大注意。自耕农和手工业主所经营的，都是小生产的经济。这个小资产阶级内的各阶层虽然同处在小资产阶级经济地位，但有三个不同的部分。第一部分是有余钱剩米的，即用其体力或脑力劳动所得，除自给外，每年有余剩。这种人发财观念极重，对赵公元帅礼拜最勤，虽不妄想发大财，却总想爬上中产阶级地位。他们看见那些受人尊敬的小财东，往往垂着一尺长的涎水。这种人胆子小，他们怕官，也有点怕革命。因为他们的经济地位和中产阶级颇接近，故对于中产阶级的宣传颇相信，对于革命取怀疑的态度。这一部分人在小资产阶级中占少数，是小资产阶级的右翼。第二部分是在经济上大体上可以自给的。这一部分人比较第一部分人大不相同，他们也想发财，但是赵公元帅⑻总不让他们发财，而且因为近年以来帝国主义、军阀、封建地主、买办大资产阶级的压迫和剥削，他们感觉现在的世界已经不是从前的世界。他们觉得现在如果只使用和从前相等的劳动，就会不能维持生活。必须增加劳动时间，每天起早散晚，对于职业加倍注意，方能维持生活。他们有点骂人了，骂洋人叫“洋鬼子”，骂军阀叫“抢钱司令”，骂土豪劣绅叫“为富不仁”。对于反帝国主义反军阀的运动，仅怀疑其未必成功（理由是：洋人和军阀的来头那么大），不肯贸然参加，取了中立的态度，但是绝不反对革命。这一部分人数甚多，大概占小资产阶级的一半。第三部分是生活下降的。这一部分人好些大概原先是所谓殷实人家，渐渐变得仅仅可以保住，渐渐变得生活下降了。他们每逢年终结账一次，就吃惊一次，说：“咳，又亏了！”这种人因为他们过去过着好日子，后来逐年下降，负债渐多，渐次过着凄凉的日子，“瞻念前途，不寒而栗”。这种人在精神上感觉的痛苦很大，因为他们有一个从前和现在相反的比较。这种人在革命运动中颇要紧，是一个数量不小的群众，是小资产阶级的左翼。以上所说小资产阶级的三部分，对于革命的态度，在平时各不相同；但到战时，即到革命潮流高涨、可以看得见胜利的曙光时，不但小资产阶级的左派参加革命，中派亦可参加革命，即右派分子受了无产阶级和小资产阶级左派的革命大潮所裹挟，也只得附和着革命。我们从一九二五年的五卅运动⑼和各地农民运动的经验看来，这个断定是不错的。 半无产阶级。此处所谓半无产阶级，包含：（一）绝大部分半自耕农⑽，（二）贫农，（三）小手工业者，（四）店员⑾，（五）小贩等五种。绝大部分半自耕农和贫农是农村中一个数量极大的群众。所谓农民问题，主要就是他们的问题。半自耕农、贫农和小手工业者所经营的，都是更细小的小生产的经济。绝大部分半自耕农和贫农虽同属半无产阶级，但其经济状况仍有上、中、下三个细别。半自耕农，其生活苦于自耕农，因其食粮每年大约有一半不够，须租别人田地，或者出卖一部分劳动力，或经营小商，以资弥补。春夏之间，青黄不接，高利向别人借债，重价向别人籴粮，较之自耕农的无求于人，自然景遇要苦，但是优于贫农。因为贫农无土地，每年耕种只得收获之一半或不足一半；半自耕农则租于别人的部分虽只收获一半或不足一半，然自有的部分却可全得。故半自耕农的革命性优于自耕农而不及贫农。贫农是农村中的佃农，受地主的剥削。其经济地位又分两部分。一部分贫农有比较充足的农具和相当数量的资金。此种农民，每年劳动结果，自己可得一半。不足部分，可以种杂粮、捞鱼虾、饲鸡豕，或出卖一部分劳动力，勉强维持生活，于艰难竭蹶之中，存聊以卒岁之想。故其生活苦于半自耕农，然较另一部分贫农为优。其革命性，则优于半自耕农而不及另一部分贫农。所谓另一部分贫农，则既无充足的农具，又无资金，肥料不足，土地歉收，送租之外，所得无几，更需要出卖一部分劳动力。荒时暴月，向亲友乞哀告怜，借得几斗几升，敷衍三日五日，债务丛集，如牛负重。他们是农民中极艰苦者，极易接受革命的宣传。小手工业者所以称为半无产阶级，是因为他们虽然自有简单的生产手段，且系一种自由职业，但他们也常常被迫出卖一部分劳动力，其经济地位略与农村中的贫农相当。因其家庭负担之重，工资和生活费用之不相称，时有贫困的压迫和失业的恐慌，和贫农亦大致相同。店员是商店的雇员，以微薄的薪资，供家庭的费用，物价年年增长，薪给往往须数年一增，偶与此辈倾谈，便见叫苦不迭。其地位和贫农及小手工业者不相上下，对于革命宣传极易接受。小贩不论肩挑叫卖，或街畔摊售，总之本小利微，吃着不够。其地位和贫农不相上下，其需要一个变更现状的革命，也和贫农相同。 无产阶级。现代工业无产阶级约二百万人。中国因经济落后，故现代工业无产阶级人数不多。二百万左右的产业工人中，主要为铁路、矿山、海运、纺织、造船五种产业的工人，而其中很大一个数量是在外资产业的奴役下。工业无产阶级人数虽不多，却是中国新的生产力的代表者，是近代中国最进步的阶级，做了革命运动的领导力量。我们看四年以来的罢工运动，如海员罢工⑿、铁路罢工⒀、开滦和焦作煤矿罢工⒁、沙面罢工⒂以及“五卅”后上海香港两处的大罢工⒃所表现的力量，就可知工业无产阶级在中国革命中所处地位的重要。他们所以能如此，第一个原因是集中。无论哪种人都不如他们的集中。第二个原因是经济地位低下。他们失了生产手段，剩下两手，绝了发财的望，又受着帝国主义、军阀、资产阶级的极残酷的待遇，所以他们特别能战斗。都市苦力工人的力量也很可注意。以码头搬运夫和人力车夫占多数，粪夫清道夫等亦属于这一类。他们除双手外，别无长物，其经济地位和产业工人相似，惟不及产业工人的集中和在生产上的重要。中国尚少新式的资本主义的农业。所谓农村无产阶级，是指长工、月工、零工等雇农而言。此等雇农不仅无土地，无农具，又无丝毫资金，只得营工度日。其劳动时间之长，工资之少，待遇之薄，职业之不安定，超过其他工人。此种人在乡村中是最感困难者，在农民运动中和贫农处于同一紧要的地位。 此外，还有数量不小的游民无产者，为失了土地的农民和失了工作机会的手工业工人。他们是人类生活中最不安定者。他们在各地都有秘密组织，如闽粤的“三合会”，湘鄂黔蜀的“哥老会”，皖豫鲁等省的“大刀会”，直隶及东三省的“在理会”，上海等处的“青帮”⒄，都曾经是他们的政治和经济斗争的互助团体。处置这一批人，是中国的困难的问题之一。这一批人很能勇敢奋斗，但有破坏性，如引导得法，可以变成一种革命力量。 综上所述，可知一切勾结帝国主义的军阀、官僚、买办阶级、大地主阶级以及附属于他们的一部分反动知识界，是我们的敌人。工业无产阶级是我们革命的领导力量。一切半无产阶级、小资产阶级，是我们最接近的朋友。那动摇不定的中产阶级，其右翼可能是我们的敌人，其左翼可能是我们的朋友——但我们要时常提防他们，不要让他们扰乱了我们的阵线。 注 释 〔1〕 国家主义派指中国青年党，当时以其外围组织“中国国家主义青年团”的名义公开进行活动。组织这个政团的是一些反动政客，他们投靠帝国主义和当权的反动派，把反对中国共产党和苏联当作职业。 〔2〕 戴季陶（一八九一——一九四九），又名传贤，原籍浙江湖州，生于四川广汉。早年参加中国同盟会，从事过反对清政府和袁世凯的活动。后曾和蒋介石在上海共同经营交易所的投机事业。一九二五年随着孙中山的逝世和革命高潮的到来，他歪曲孙中山学说的革命内容，散布反对国共合作、反对工农革命运动的谬论，为后来蒋介石的反共活动作了准备。一九二七年南京国民政府成立后，历任国民政府委员、考试院院长等职。一九四九年二月，蒋介石的统治即将崩溃，戴季陶感到绝望而自杀。 〔3〕 北京《晨报》，初名《晨钟报》，一九一六年八月创刊于北京，一九一八年十二月改名为《晨报》，一九二八年六月停刊。 〔4〕 一九二二年和一九二三年间，孙中山在共产党人的帮助下，决定改组国民党，实行国共合作，容纳共产党人参加国民党，并于一九二四年一月在广州召开国民党第一次全国代表大会，实行联俄、联共、扶助农工的三大政策。李大钊、谭平山、毛泽东、林伯渠、瞿秋白等共产党人参加了这次大会。他们曾经被选为国民党中央执行委员会的委员或候补委员，担任过国民党的许多领导工作，对于帮助国民党走上革命的道路，起了重大的作用。 〔5〕 第三国际即共产国际，一九一九年三月在列宁领导下成立。一九二二年中国共产党参加共产国际，成为它的一个支部。一九四三年五月，共产国际执行委员会主席团通过决定，提议解散共产国际，同年六月共产国际正式宣布解散。 〔6〕 国际联盟简称国联，一九二○年一月正式成立。先后参加的有六十多个国家。国际联盟标榜以“促进国际合作，维持国际和平与安全”为目的，实际上日益成为帝国主义国家推行侵略政策的工具。第二次世界大战爆发后无形瓦解，一九四六年四月正式宣布解散。 〔7〕 这里是指中农。 〔8〕 赵公元帅是中国民间传说的财神，叫赵公明。 〔9〕 指一九二五年五月三十日爆发的反帝爱国运动。一九二五年五月间，上海、青岛的日本纱厂先后发生工人罢工的斗争，遭到日本帝国主义和北洋军阀的镇压。上海内外棉第七厂日本资本家在五月十五日枪杀了工人顾正红，并伤工人十余人。二十九日青岛工人被反动政府屠杀八人。五月三十日，上海二千余学生分头在公共租界各马路进行宣传讲演，一百余名遭巡捕（租界内的警察）逮捕，被拘押在南京路老闸巡捕房内，引起了学生和市民的极大愤慨，有近万人聚集在巡捕房门口，要求释放被捕学生。英帝国主义的巡捕向群众开枪，打死打伤许多人。这就是震惊中外的五卅惨案。六月，英日等帝国主义在上海和其他地方继续进行屠杀。这些屠杀事件激起了全国人民的公愤。广大的工人、学生和部分工商业者，在许多城市和县镇举行游行示威和罢工、罢课、罢市，形成了全国规模的反帝爱国运动高潮。 〔10〕 这里是指自己有一部分土地，同时租种一部分土地，或出卖一部分劳动力，或兼营小商的贫农。 〔11〕 店员有不同的阶层，他们一般不占有生产资料，生活来源的全部或者主要部分是依靠向店主出卖劳动力所取得的工资。毛泽东在这里所指的是店员中的一部分，还有一部分下层店员过着无产阶级的生活。 〔12〕 指一九二二年香港和上海的海员罢工。香港海员罢工爆发于一月十二日，坚持了八个星期。最后，香港英帝国主义当局被迫答应增加工资，恢复原工会，释放被捕工人，抚恤在罢工中死难烈士的家属。上海海员罢工于八月五日开始，坚持了三个星期，也得到胜利。 〔13〕 指一九二二年和一九二三年中国共产党领导的各主要铁路线的工人罢工。在罢工过程中，工人群众的觉悟迅速提高，要求改善生活的经济斗争迅速发展为反对军阀的政治斗争。一九二三年二月四日，京汉铁路工人为争取组织总工会的自由，举行总罢工。其他许多铁路的工人也纷纷响应。二月七日，英帝国主义支持的北洋军阀吴佩孚、萧耀南等，残酷地屠杀京汉铁路的工人，造成了二七惨案。 〔14〕 开滦煤矿是直隶省（今河北省）开平、滦县一带煤矿的总称，当时为英帝国主义者所控制。开滦罢工指一九二二年十月、十一月间矿工三万余人举行的大罢工。英帝国主义者和北洋军阀对这次罢工进行残酷的镇压，工人死伤很多，但是仍然坚持斗争。最后，英帝国主义者不得不答应给工人增加一部分工资。焦作煤矿，在河南省北部，当时也为英帝国主义者所控制。焦作罢工指一九二五年七月爆发的罢工。这次罢工是为响应五卅运动而发动的，前后坚持七个多月。最后，英帝国主义者不得不承认工会有代表工人的权利，并且被迫接受增加工资、不无故开除工人和补偿工人因罢工所受的损失等项条件。 〔15〕 沙面当时是英法帝国主义在广州的租界。一九二四年七月，统治沙面的帝国主义者颁布新警律，规定沙面的中国人出入租界必须携带贴有本人相片的执照，在租界内行动必须受各种苛刻的限制，但是外国人却可以自由出入活动。沙面工人于七月十五日宣告罢工，抗议这些无理措施。这次沙面罢工迫使英法帝国主义者取消了新警律。 〔16〕 指一九二五年六月一日开始的上海大罢工和六月十九日开始的香港大罢工。这两处罢工是当时全国反帝爱国运动的支柱。前者有二十多万工人参加，坚持了三四个月；后者有二十五万工人参加，坚持了一年零四个月，是截至当时为止的世界工人运动史中时间最长的一次罢工。 〔17〕 三合会、哥老会、大刀会、在理会、青帮是旧中国的一些民间秘密团体，参加者主要的是破产农民、失业手工业工人和流氓无产者。这类团体大都用宗教迷信为团聚成员的工具，采取家长制的组织形式，有的还拥有武装。参加这类团体的人，在社会生活中有互相援助的义务，有时还共同反抗压迫他们的地主、官僚和外国侵略者。但是，农民和手工业工人不可能依靠这类团体得到出路。同时，由于这类团体带有严重的封建性和盲目的破坏性，它们又往往容易被反动统治阶级和帝国主义势力所操纵和利用。随着工人阶级力量的壮大和中国共产党的成立，农民和手工业工人在共产党的领导之下逐步地建立了完全新式的群众组织，这类落后的团体就失掉了它们的存在价值。 作者：账号已注销 https://www.bilibili.com/read/cv7925952/?from=readlist 出处：bilibili","categories":[],"tags":[{"name":"git","slug":"git","permalink":"https://vlwq.github.io/tags/git/"}]},{"title":"lodash array to object","slug":"2017node/20180301","date":"2018-02-28T16:00:00.000Z","updated":"2022-03-02T06:53:06.996Z","comments":true,"path":"2018/03/01/2017node/20180301/","link":"","permalink":"https://vlwq.github.io/2018/03/01/2017node/20180301/","excerpt":"","text":"123456789101112131415const mergeUnionByKey = function(data,key,templete=&#123;&#125;) &#123; const datasets = data const datasetsIndex = _.mapValues(datasets, dataset =&gt; _.keyBy(dataset, key)) const uniqKeys = _.chain(datasets).flatten().map(key).uniq().value() const c = _.chain(uniqKeys).map(val =&gt; &#123; const data = JSON.parse(JSON.stringify(templete)) _.each(datasetsIndex, dataset =&gt;&#123; _.merge(data, dataset[val]) &#125;) return data &#125;).filter(key).value() return c&#125;","categories":[],"tags":[{"name":"node","slug":"node","permalink":"https://vlwq.github.io/tags/node/"}]},{"title":"docker install","slug":"2016linux/20180120","date":"2018-01-19T16:00:00.000Z","updated":"2022-03-03T03:42:19.985Z","comments":true,"path":"2018/01/20/2016linux/20180120/","link":"","permalink":"https://vlwq.github.io/2018/01/20/2016linux/20180120/","excerpt":"参照官方https://docs.docker.com/install/linux/docker-ce/ubuntu/ ce是社区版 先切换ubuntu内镜像https://mirrors.ustc.edu.cn/repogen/","text":"参照官方https://docs.docker.com/install/linux/docker-ce/ubuntu/ ce是社区版 先切换ubuntu内镜像https://mirrors.ustc.edu.cn/repogen/ 1、移除 1$ sudo apt-get remove docker docker-engine docker.io 2、(可选)安装linux-image-extra-*包，以便docker使用aufs存储驱动 12345$ sudo apt-get update$ sudo apt-get install \\ linux-image-extra-$(uname -r) \\ linux-image-extra-virtual 3、支持https? 12345$ sudo apt-get install \\ apt-transport-https \\ ca-certificates \\ curl \\ software-properties-common 4、add Docker的官方GPG key 12$ curl -fsSL https://download.docker.com/linux/ubuntu/gpg | sudo apt-key add -$ sudo apt-key fingerprint 0EBFCD88 5、配置库 1234$ sudo add-apt-repository \\ &quot;deb [arch=amd64] https://download.docker.com/linux/ubuntu \\ $(lsb_release -cs) \\ stable&quot; 6、install 12$ sudo apt-get update$ sudo apt-get install docker-ce 7、test 1$ sudo docker run hello-world 如果运行成功则网络无问题，若有，则需要配置docker代理,配置完重新运行“$ sudo docker run hello-world”进行验证 123456789101112131.默认情况下这个配置文件夹并不存在，我们要创建它$ mkdir -p /etc/systemd/system/docker.service.d2.创建一个文件 /etc/systemd/system/docker.service.d/http-proxy.conf 文件内容如下：[Service]Environment=&quot;HTTP_PROXY=http://proxy_ip:proxy_port/&quot;Environment=&quot;HTTPS_PROXY=http://proxy_ip:proxy_port/&quot;Environment=&quot;NO_PROXY=localhost,127.0.0.1,localaddress,.localdomain.com&quot;3.刷新systemd配置:$ sudo systemctl daemon-reload4.用系统命令验证环境变量加上去没:$ systemctl show --property=Environment docker5.重启docker$ sudo systemctl restart docker 8.安装docker-compose 1$ sudo apt-get install docker-compose","categories":[],"tags":[{"name":"linux","slug":"linux","permalink":"https://vlwq.github.io/tags/linux/"}]},{"title":"tcp3次","slug":"2018base/20180101","date":"2017-12-31T16:00:00.000Z","updated":"2022-03-03T03:42:07.265Z","comments":true,"path":"2018/01/01/2018base/20180101/","link":"","permalink":"https://vlwq.github.io/2018/01/01/2018base/20180101/","excerpt":"","text":"简单说，让双方都证实对方能发收。知道对方能收是因为收到对方的因为收到而发的回应。具体：1：A发，B收， B知道A能发2：B发，A收， A知道B能发收3：A发，B收， B知道A能收","categories":[],"tags":[{"name":"base","slug":"base","permalink":"https://vlwq.github.io/tags/base/"}]},{"title":"lodash合并对象数组","slug":"2017node/20171226","date":"2017-12-25T16:00:00.000Z","updated":"2017-12-26T15:08:48.492Z","comments":true,"path":"2017/12/26/2017node/20171226/","link":"","permalink":"https://vlwq.github.io/2017/12/26/2017node/20171226/","excerpt":"因pmo查询做得辣鸡，需要多次查询合成结果集，查询经常遇到对象数组合并问题(key不存在也要赋值)如 123456789101112131415const test1 = [ &#123; name: &#x27;zhanghong&#x27;, age: 32, &#125;, &#123; name: &#x27;wanghong&#x27;, age: 20, size: 6 &#125;,]const test2 = [ &#123; name: &#x27;zhanghong&#x27;, gender: &#x27;male&#x27;&#125;, &#123; name: &#x27;wanghong&#x27;, gender: &#x27;female&#x27;&#125;,]期望最后结果集合const test3 = [ &#123; name: &#x27;zhanghong&#x27;,gender: &#x27;male&#x27;, age: 32, size: 6, &#125;, &#123; name: &#x27;wanghong&#x27;, gender: &#x27;female&#x27; ,age: 20, size: 0 &#125;,]","text":"因pmo查询做得辣鸡，需要多次查询合成结果集，查询经常遇到对象数组合并问题(key不存在也要赋值)如 123456789101112131415const test1 = [ &#123; name: &#x27;zhanghong&#x27;, age: 32, &#125;, &#123; name: &#x27;wanghong&#x27;, age: 20, size: 6 &#125;,]const test2 = [ &#123; name: &#x27;zhanghong&#x27;, gender: &#x27;male&#x27;&#125;, &#123; name: &#x27;wanghong&#x27;, gender: &#x27;female&#x27;&#125;,]期望最后结果集合const test3 = [ &#123; name: &#x27;zhanghong&#x27;,gender: &#x27;male&#x27;, age: 32, size: 6, &#125;, &#123; name: &#x27;wanghong&#x27;, gender: &#x27;female&#x27; ,age: 20, size: 0 &#125;,] 参照 https://stackoverflow.com/questions/29320817/lodash-union-of-arrays-of-objects 暂时解决，待优化代码 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566const test1 = [ &#123; name: &#x27;zhanghong&#x27;, age: 32, money: 0, size: 12, &#125;, &#123; name: &#x27;wanghong&#x27;, age: 20, size: 6 &#125;, &#123; name: &#x27;jinhong&#x27;, age: 16, height: 172 &#125;,]const test2 = [ &#123; name: &#x27;zhanghong&#x27;, gender: &#x27;male&#x27;, age: 14 &#125;, &#123; name: &#x27;wanghong&#x27;, gender: &#x27;female&#x27;, age: 33 &#125;, &#123; name: &#x27;lihong&#x27;, gender: &#x27;female&#x27;, age: 33 &#125;,]const test3 = [ &#123; name: &#x27;meinv&#x27; &#125;,]const test4 = [ &#123; name: &#x27;aaa&#x27; &#125;,]const test5 = [ &#123; name: &#x27;zhanghong&#x27;, age: &#x27;wtf&#x27; &#125;,]const result = mergeUnionByKey(test1, test2, test3, test4, [], test5, &#x27;name&#x27;, &#x27;override&#x27;)function mergeUnionByKey(...args) &#123; const config = _.chain(args) .filter(_.isString) .value() const key = _.get(config, &#x27;[0]&#x27;) const strategy = _.get(config, &#x27;[1]&#x27;) === &#x27;override&#x27; ? _.merge : _.defaultsDeep if (!_.isString(key)) throw new Error(&#x27;missing key&#x27;) const datasets = _.chain(args) .reject(_.isEmpty) .filter(_.isArray) .value() const datasetsIndex = _.mapValues(datasets, dataset =&gt; _.keyBy(dataset, key)) const uniqKeys = _.chain(datasets) .flatten() .map(key) .uniq() .value() return _.chain(uniqKeys) .map(val =&gt; &#123; const data = &#123;&#125; _.each(datasetsIndex, dataset =&gt; strategy(data, dataset[val])) return data &#125;) .filter(key) .value()&#125;console.log(JSON.stringify(result, null, 4))","categories":[],"tags":[{"name":"node","slug":"node","permalink":"https://vlwq.github.io/tags/node/"}]},{"title":"sequelize-auto对照数据库自动生成相应的models","slug":"2017node/20171225","date":"2017-12-24T16:00:00.000Z","updated":"2017-12-26T14:59:57.180Z","comments":true,"path":"2017/12/25/2017node/20171225/","link":"","permalink":"https://vlwq.github.io/2017/12/25/2017node/20171225/","excerpt":"12345678910111213141516171819202122Installnpm install -g sequelize-autoPrerequisitesYou will need to install the correct dialect binding globally before using sequelize-auto.Example for MySQL/MariaDBnpm install -g mysqlExample for Postgresnpm install -g pg pg-hstoreExample for Sqlite3npm install -g sqliteExample for MSSQLnpm install -g mssql","text":"12345678910111213141516171819202122Installnpm install -g sequelize-autoPrerequisitesYou will need to install the correct dialect binding globally before using sequelize-auto.Example for MySQL/MariaDBnpm install -g mysqlExample for Postgresnpm install -g pg pg-hstoreExample for Sqlite3npm install -g sqliteExample for MSSQLnpm install -g mssql 参数见npm文档 https://www.npmjs.com/package/sequelize-auto","categories":[],"tags":[{"name":"node","slug":"node","permalink":"https://vlwq.github.io/tags/node/"}]},{"title":"git服务端强制覆盖本地","slug":"2018git/20171101","date":"2017-10-31T16:00:00.000Z","updated":"2022-03-03T03:35:03.928Z","comments":true,"path":"2017/11/01/2018git/20171101/","link":"","permalink":"https://vlwq.github.io/2017/11/01/2018git/20171101/","excerpt":"12git reset --hard origin/master git pull","text":"12git reset --hard origin/master git pull 版本管理软件有时boom…. 其他常用命令备用： 1234567891011121314151617181920212223# 显示当前分支的版本历史$ git log# 下载远程仓库的所有变动$ git fetch [remote]# 取回远程仓库的变化，并与本地分支合并$ git pull [remote] [branch]# 强行推送当前分支到远程仓库，即使有冲突$ git push [remote] --force# 暂时将未提交的变化移除，稍后再移入$ git stash$ git stash pop# 新建一个commit，用来撤销指定commit# 后者的所有变化都将被前者抵消，并且应用到当前分支$ git revert [commit]","categories":[],"tags":[{"name":"git","slug":"git","permalink":"https://vlwq.github.io/tags/git/"}]},{"title":"实现promise(转自bananas)","slug":"2017node/20171002","date":"2017-10-01T16:00:00.000Z","updated":"2017-11-27T06:38:30.498Z","comments":true,"path":"2017/10/02/2017node/20171002/","link":"","permalink":"https://vlwq.github.io/2017/10/02/2017node/20171002/","excerpt":"promise 是为了解决回调地狱的问题。主要有以下几个方法 Promise.prototype.then Promise.prototype.catch Promise.all Promise.race","text":"promise 是为了解决回调地狱的问题。主要有以下几个方法 Promise.prototype.then Promise.prototype.catch Promise.all Promise.race 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135const log = console.log.bind(console)class BananasPromise &#123; constructor(func) &#123; if(typeof func !== &#x27;function&#x27;) &#123; throw new Error(func, &#x27;is no a function&#x27;) &#125; this.func = func this.state = &#x27;init&#x27; const resolve = this.resolve.bind(this) const reject = this.reject.bind(this) const r = () =&gt; &#123; func(resolve, reject) return this &#125; return r &#125; _efunc() &#123; &#125; then(done) &#123; this.done = done || this._efunc if(this.state === &#x27;done&#x27;) &#123; done(this.args) &#125; return this &#125; catch(fail) &#123; this.fail = fail || this._efunc if(this.state === &#x27;fail&#x27;) &#123; fail(this.err) &#125; &#125; resolve(args=&#x27;&#x27;) &#123; this.state = &#x27;done&#x27; this.args = args this.done &amp;&amp; this.then(this.done) &#125; reject(args=&#x27;&#x27;) &#123; this.state = &#x27;fail&#x27; this.err = args this.catch &amp;&amp; this.catch(this.fail) &#125; static _init() &#123; const cls = this cls.state = &#x27;init&#x27; cls.done = () =&gt; &#123;&#125; cls.fail = () =&gt; &#123;&#125; cls._resule = [] cls._err = null &#125; static all(array) &#123; const cls = this let len = array.length cls._init() array.forEach((i, index) =&gt; &#123; if(cls._err !== null) &#123; return &#125; i().then((a) =&gt; &#123; if(cls._err !== null) &#123; return &#125; len-- cls._resule[index] = a if(len === 0) &#123; cls.state = &#x27;done&#x27; cls.then() &#125; &#125;).catch((err) =&gt; &#123; if(cls._err !== null) &#123; return &#125; cls.state = &#x27;fail&#x27; cls._err = err cls.catch() &#125;) &#125;) return this &#125; static then(done) &#123; const cls = this if(this.state === &#x27;done&#x27;) &#123; cls.done(cls._resule) &#125; else if(this.state === &#x27;init&#x27;) &#123; cls.done = done || cls.done &#125; return this &#125; static catch(fail) &#123; const cls = this if(cls.state === &#x27;fail&#x27;) &#123; cls.fail(cls._err) &#125; else if(cls.state === &#x27;init&#x27;) &#123; cls.fail = fail || cls.fail &#125; &#125; static race(array) &#123; const cls = this cls._init() array.forEach((item) =&gt; &#123; if(cls.state === &#x27;done&#x27; || cls.state === &#x27;fail&#x27;) &#123; return &#125; item().then((data) =&gt; &#123; if(cls.state === &#x27;done&#x27; || cls.state === &#x27;fail&#x27;) &#123; return &#125; cls.state = &#x27;done&#x27; cls._resule = data cls.then() &#125;).catch((err) =&gt; &#123; if(cls.state === &#x27;done&#x27; || cls.state === &#x27;fail&#x27;) &#123; return &#125; cls.state = &#x27;fail&#x27; cls._err = err cls.catch() &#125;) &#125;) return cls &#125;&#125;","categories":[],"tags":[{"name":"node","slug":"node","permalink":"https://vlwq.github.io/tags/node/"}]},{"title":"Andrew Parse 2","slug":"2018base/20170808","date":"2017-08-07T16:00:00.000Z","updated":"2017-08-27T05:57:56.304Z","comments":true,"path":"2017/08/08/2018base/20170808/","link":"","permalink":"https://vlwq.github.io/2017/08/08/2018base/20170808/","excerpt":"Andrew Parse 2","text":"Andrew Parse 2 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172173174175176177178179180/** * Created by Andrew on 2017/7/30 0030. */const log = console.log.bind(console)//处理key,value,去掉&quot;&quot;const parsedElement = (e) =&gt; &#123; if(e[0] === &#x27;\\&quot;&#x27; || e[0] === &quot;\\&#x27;&quot;) &#123; return e.slice(1, e.length - 1) &#125;else &#123; return Number(e) &#125;&#125;//解析name: &#x27;gua&#x27;, 一个字符值的情况const parsedOne = (s) =&gt; &#123; log(&#x27;debug parsedOne&#x27;,s) const obj = &#123;&#125; const arr = s.split(&#x27;,&#x27;) arr.forEach(e=&gt;&#123; const t = e.split(&quot;:&quot;) const k = parsedElement(t[0]) const v = parsedElement(t[1]) obj[k] = v &#125;) return obj&#125;/** * [[[[[]]]]]]] * 处理&#123;&#123;&#123;&#123;&#125;&#125;&#125;&#125;,取到最后一个&#125; */const findElementEnd = (str, start ,isObj = true) =&gt; &#123; let a = &#x27;&#x27; let b= &#x27;&#x27; if(isObj)&#123; a = &#x27;&#123;&#x27; b = &#x27;&#125;&#x27; &#125;else&#123; a = &#x27;[&#x27; b = &#x27;]&#x27; &#125; const stack = [a] let i = start + 1 while(i &lt; str.length &amp;&amp; stack.length &gt; 0) &#123; if(str[i] === a) &#123; stack.push(a) &#125;else if(str[i] === b) &#123; let index = stack.length - 1 stack.splice(index, 1) &#125;else &#123; // &#125; i++ &#125; return i&#125;const dealWithArray = (s ,arr=[])=&gt;&#123; //50,&quot;20&quot;,[1,[3,4],2],[55,66] const index = s.indexOf(&#x27;[&#x27;) log(&#x27;debug 6666----: &#x27;, s ,index) if( index === -1)&#123; const a = s.split(&#x27;,&#x27;).map(e =&gt;parsedElement(e)) arr.push.apply(arr,a) &#125;else &#123; //处理前面半段,不能为0 if(index !== 0)&#123; let newStr = s.slice(0,index - 1) let a = newStr.split(&#x27;,&#x27;).map(e =&gt;parsedElement(e)) arr.push.apply(arr,a) &#125; //递归(中间) const last = findElementEnd(s , index , false) let newS = s.slice(index + 1 ,last - 1) let temp = [] let b = dealWithArray(newS ,[]) //log(&#x27;77???---&#x27;,newS, b) //if(newS.indexOf(&#x27;[&#x27;) === -1 &amp;&amp; newS.indexOf(&#x27;]&#x27;) === -1)&#123; // arr.push.apply(arr,b) //&#125;else &#123; arr.push(b) // &#125; //arr.push(b) //处理后面半段 log(&#x27;==============================&#x27;,arr) log(&#x27;===============================\\n&#x27;) //继续递归 let newStr = s.slice(last + 1) if(newStr.length &gt; 0)&#123; log(&#x27;test------&#x27;,newStr) let c = dealWithArray(newStr ,[]) arr.push.apply(arr ,c) &#125; &#125; return arr&#125;const myParse =(s ,obj=&#123;&#125;)=&gt;&#123; if(s[0] === &#x27;&#123;&#x27;)&#123; s = s.slice(1, s.length - 1) &#125; //复杂情形 // &quot;name&quot;:&quot;gua&quot;,&quot;todo&quot;:&#123;&quot;play&quot;:&quot;0/1&quot;&#125; let index = s.indexOf(&#x27;:&#x27;) const str = s[index + 1] log(&#x27;debug digui &#x27;,s, &#x27;\\n&#x27;) if(str === &#x27;&#123;&#x27;)&#123; log(&#x27;-----enter object parse-----------&#x27;) let key = s.split(&#x27;:&#123;&#x27;)[0] //截取s key = parsedElement(key) // 找到最后一个&#125; const last = findElementEnd(s , index) const newStr = s.slice(index +1 , last) let o = &#123;&#125; o = myParse(newStr , o) obj[`$&#123;key&#125;`] = o log(&#x27;debug newStr : &#x27;,newStr) log(&#x27;debug o : &#x27;,o) &#125;else if(str === &#x27;[&#x27;)&#123; log(&#x27;-----enter array parse-----------&#x27;) //&quot;age&quot;:[50,20,30] let key = s.split(&#x27;:[&#x27;)[0] //截取s key = parsedElement(key) // 找到最后一个] const last = findElementEnd(s , index + 1 ,false) const newStr = s.slice(index + 1 , last) const r = dealWithArray(newStr) log(&#x27;final:&#x27;, r[0]) log(&#x27;str: &#x27;, s.slice(last + 1)) obj[`$&#123;key&#125;`] = r[0] //继续递归 const l = s.slice(last + 1) if(l.length &gt; 0)&#123; //截取不为空串就继续 myParse(l,obj) &#125; //log(&#x27;test: &#x27;,test) &#125;else if (str !== &#x27;&#123;&#x27; &amp;&amp; str !== &#x27;[&#x27;)&#123; log(`----enter str parse--------$&#123;s&#125; \\n`) //取到&quot;name&quot;:&quot;gua&quot; const cell = s.split(&#x27;,&#x27;)[0] log(&#x27;cell &#x27;,s,&#x27;----&#x27;, cell) const o = parsedOne(cell) const k = Object.keys(o)[0] obj[`$&#123;k&#125;`] = o[k] //log(&#x27;obj: &#x27;,obj) //下一个元素 index = s.indexOf(&#x27;,&#x27;) if (index !== -1) &#123; s = s.slice(index + 1) obj = myParse(s, obj) &#125; &#125; return obj&#125;const testParser = () =&gt; &#123; const o = &#123; age: [50,&#x27;20&#x27;,[1,[3,4],[22,33],2] ,[55,66]], age3: [50,[77,88]], todo: &#123; &#x27;play&#x27;: &#x27;0/1&#x27;, &#x27;sports&#x27;: &#123; &#x27;gua&#x27;:&#123; &#x27;test&#x27;:222 &#125; &#125; &#125; &#125; const s = JSON.stringify(o) const obj = myParse(s) // log(&#x27;\\n\\nfinal result : &#x27;) log(&#x27;\\nJSON.parse result:&#x27;, s) log(`\\nAndrew&#x27;s JSON Parse : `, obj) log(`\\nAndrew&#x27;s JSON Parse TODO detail: \\n`, obj[&#x27;todo&#x27;])&#125;testParser()","categories":[],"tags":[{"name":"base","slug":"base","permalink":"https://vlwq.github.io/tags/base/"}]},{"title":"Andrew的Json.parse解析器","slug":"2018base/20170729","date":"2017-07-29T02:36:00.000Z","updated":"2017-08-27T05:58:10.407Z","comments":true,"path":"2017/07/29/2018base/20170729/","link":"","permalink":"https://vlwq.github.io/2017/07/29/2018base/20170729/","excerpt":"&#x2F;&#x2F;令人窒息的操作 Andrew的Json.parse解析器","text":"&#x2F;&#x2F;令人窒息的操作 Andrew的Json.parse解析器 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169/** * Created by Andrew on 2017/7/30 0030. */const log = console.log.bind(console)//处理key,value,去掉&quot;&quot;const parsedElement = (e) =&gt; &#123; if (e[0] === &#x27;\\&quot;&#x27; || e[0] === &quot;\\&#x27;&quot;) &#123; return e.slice(1, e.length - 1) &#125; else &#123; return Number(e) &#125;&#125;//解析name: &#x27;gua&#x27;, 一个字符值的情况const parsedOne = (s) =&gt; &#123; log(&#x27;debug parsedOne&#x27;, s) const obj = &#123;&#125; const arr = s.split(&#x27;,&#x27;) arr.forEach(e =&gt; &#123; const t = e.split(&quot;:&quot;) const k = parsedElement(t[0]) const v = parsedElement(t[1]) obj[k] = v &#125;) return obj&#125;/** * [[[[[]]]]]]] * 处理&#123;&#123;&#123;&#123;&#125;&#125;&#125;&#125;,取到最后一个&#125;，默认i处理object ,数组需要传false */const findElementEnd = (str, start, isObj = true) =&gt; &#123; let a = &#x27;&#x27; let b = &#x27;&#x27; if (isObj) &#123; a = &#x27;&#123;&#x27; b = &#x27;&#125;&#x27; &#125; else &#123; a = &#x27;[&#x27; b = &#x27;]&#x27; &#125; const stack = [a] let i = start + 1 while (i &lt; str.length &amp;&amp; stack.length &gt; 0) &#123; if (str[i] === a) &#123; stack.push(a) &#125; else if (str[i] === b) &#123; let index = stack.length - 1 stack.splice(index, 1) &#125; else &#123; // &#125; i++ &#125; return i&#125;const dealWithArray = (s, arr = []) =&gt; &#123; //50,&quot;20&quot;,[1,[3,4],2],[55,66] const index = s.indexOf(&#x27;[&#x27;) log(&#x27;debug diguiguigi----: &#x27;, s) if (index === -1) &#123; const a = s.split(&#x27;,&#x27;).map(e =&gt; parsedElement(e)) arr.push.apply(arr, a) &#125; else &#123; //处理前面半段,不能为0 if (index !== 0) &#123; let newStr = s.slice(0, index - 1) let a = newStr.split(&#x27;,&#x27;).map(e =&gt; parsedElement(e)) arr.push.apply(arr, a) &#125; //递归(中间) const last = findElementEnd(s, index, false) let newS = s.slice(index + 1, last - 1) let temp = [] let b = dealWithArray(newS, []) arr.push(b) //处理后面半段 log(&#x27;===============================\\n&#x27;) //继续递归 let newStr = s.slice(last + 1) if (newStr.length &gt; 0) &#123; log(&#x27;test------&#x27;, newStr) let c = dealWithArray(newStr, []) arr.push.apply(arr, c) &#125; &#125; return arr&#125;const myParse = (s, obj = &#123;&#125;) =&gt; &#123; if (s[0] === &#x27;&#123;&#x27;) &#123; s = s.slice(1, s.length - 1) &#125; //复杂情形 // &quot;name&quot;:&quot;gua&quot;,&quot;todo&quot;:&#123;&quot;play&quot;:&quot;0/1&quot;&#125; let index = s.indexOf(&#x27;:&#x27;) const str = s[index + 1] log(&#x27;debug digui &#x27;, s, &#x27;\\n&#x27;) if (str === &#x27;&#123;&#x27;) &#123; log(&#x27;-----enter object parse-----------&#x27;) let key = s.split(&#x27;:&#123;&#x27;)[0] //截取s key = parsedElement(key) // 找到最后一个&#125; const last = findElementEnd(s, index) const newStr = s.slice(index + 2, last - 1) let o = &#123;&#125; o = myParse(newStr, o) obj[`$&#123;key&#125;`] = o log(&#x27;debug newStr : &#x27;, newStr) log(&#x27;debug o : &#x27;, o) &#125; else if (str !== &#x27;&#123;&#x27; &amp;&amp; str !== &#x27;[&#x27;) &#123; log(`----enter str parse--------$&#123;s&#125; \\n`) //取到&quot;name&quot;:&quot;gua&quot; const cell = s.split(&#x27;,&#x27;)[0] log(&#x27;cell &#x27;, s, &#x27;----&#x27;, cell) const o = parsedOne(cell) const k = Object.keys(o)[0] obj[`$&#123;k&#125;`] = o[k] //log(&#x27;obj: &#x27;,obj) //下一个元素 index = s.indexOf(&#x27;,&#x27;) if (index !== -1) &#123; s = s.slice(index + 1) obj = myParse(s, obj) &#125; &#125; else if (str === &#x27;[&#x27;) &#123; log(&#x27;-----enter array parse-----------&#x27;) //&quot;age&quot;:[50,20,30] let key = s.split(&#x27;:[&#x27;)[0] //截取s key = parsedElement(key) // 找到最后一个] const last = findElementEnd(s, index, false) const newStr = s.slice(index + 2, last - 1) // const r = dealWithArray(newStr) log(&#x27;final:&#x27;, r) //log(&#x27;debug arr: &#x27;,newStr) //Todo 有bug需要考虑后续字符s.slice(last + 1) obj[`$&#123;key&#125;`] = r &#125; return obj&#125;const testParser = () =&gt; &#123; const o = &#123; todo: &#123; &#x27;play&#x27;: &#x27;0/1&#x27;, &#x27;sports&#x27;: &#123; &#x27;gua&#x27;:&#123; &#x27;test&#x27;:222 &#125; &#125; &#125;, //name: &#x27;test&#x27;, //todo: 没完成：array单独运行没问题，和obj搭配有bug,需要update //age: [50,&#x27;20&#x27;,[1,[3,4],[22,33],2] ,[55,66]], &#125; const s = JSON.stringify(o) const obj = myParse(s) log(&#x27;\\n\\nfinal result : &#x27;) log(&#x27;\\nJSON.parse result:&#x27;, s) log(`\\nAndrew&#x27;s JSON Parse : `, obj) log(`\\nAndrew&#x27;s JSON Parse TODO 子类obj : `, obj[&#x27;todo&#x27;])&#125;testParser()","categories":[],"tags":[{"name":"base","slug":"base","permalink":"https://vlwq.github.io/tags/base/"}]},{"title":"同步/异步新认识","slug":"2016fe/20170720","date":"2017-07-20T02:36:00.000Z","updated":"2022-03-03T03:34:22.623Z","comments":true,"path":"2017/07/20/2016fe/20170720/","link":"","permalink":"https://vlwq.github.io/2017/07/20/2016fe/20170720/","excerpt":"&#x2F;&#x2F;令人窒息的操作","text":"&#x2F;&#x2F;令人窒息的操作 1234567891011121314151617181920212223242526272829303132333435var doExe = function (a, callback) &#123; setTimeout(function () &#123; console.log(a) if (callback) &#123; callback() &#125; &#125;, 100 * Math.random())&#125;;//async(async () =&gt; &#123; for (let i = 0; i &lt; 10; i++) &#123; await new Promise(resolve =&gt; doExe(i, resolve)); &#125;&#125;)();//不让用asynclet p = new Promise(res =&gt; doExe(0,res));for (let i = 1; i &lt; 10; i++) &#123; p = p.then(() =&gt; new Promise(res =&gt; doExe(i, res)));&#125;//es5var i = 0;var aTest = function()&#123; i &lt; 10 &amp;&amp; doExe(i++, aTest);&#125;aTest();//令人窒息的操作for(let t = 0; t &lt; 10; t++)&#123; Math.random = () =&gt; t; doExe(t);&#125;","categories":[],"tags":[{"name":"FE","slug":"FE","permalink":"https://vlwq.github.io/tags/FE/"}]},{"title":"less命令","slug":"2016linux/20170718","date":"2017-07-18T02:36:00.000Z","updated":"2017-07-18T12:23:39.095Z","comments":true,"path":"2017/07/18/2016linux/20170718/","link":"","permalink":"https://vlwq.github.io/2017/07/18/2016linux/20170718/","excerpt":"less命令 与 more命令 非常类似，但less命令 可以更加随意地浏览文件，而且 less 在查看之前不会加载整个文件。相比较于more命令，很多人更喜欢使用 less命令。","text":"less命令 与 more命令 非常类似，但less命令 可以更加随意地浏览文件，而且 less 在查看之前不会加载整个文件。相比较于more命令，很多人更喜欢使用 less命令。 一、Linux less命令语法 less [参数] 文件less命令非常强大，在此只介绍几个常用的参数，更多参数使用man less来查看Linux帮助手册。-b &lt;缓冲区大小&gt; 设置缓冲区的大小-e 当文件显示结束后，自动离开-f 强迫打开特殊文件，例如外围设备代号、目录和二进制文件-g 只标志最后搜索的关键词-i 忽略搜索时的大小写-m 显示类似more命令的百分比-N 显示每行的行号-o &lt;文件名&gt; 将less 输出的内容在指定文件中保存起来-Q 不使用警告音-s 显示连续空行为一行-S 行过长时间将超出部分舍弃-x &lt;数字&gt; 将”tab”键显示为规定的数字空格&#x2F;字符串：向下搜索”字符串”的功能?字符串：向上搜索”字符串”的功能n：重复前一个搜索（与 &#x2F; 或 ? 有关）N：反向重复前一个搜索（与 &#x2F; 或 ? 有关）b 向后翻一页d 向后翻半页h 显示帮助界面Q 退出less 命令u 向前滚动半页y 向前滚动一行空格键 滚动一行回车键 滚动一页[pagedown]： 向下翻动一页[pageup]： 向上翻动一页 二、Linux less命令使用实例 1）查看文件$less linuxdaxue.com-access_log120.26.216.168 - - [12&#x2F;Jun&#x2F;2016:03:09:16 +0800] “HEAD &#x2F; HTTP&#x2F;1.1” 200 -42.96.189.63 - - [12&#x2F;Jun&#x2F;2016:03:09:41 +0800] “HEAD &#x2F; HTTP&#x2F;1.1” 200 -123.56.138.37 - - [12&#x2F;Jun&#x2F;2016:03:12:52 +0800] “HEAD &#x2F; HTTP&#x2F;1.1” 200 -120.26.216.168 - - [12&#x2F;Jun&#x2F;2016:03:14:16 +0800] “HEAD &#x2F; HTTP&#x2F;1.1” 200 -42.96.189.63 - - [12&#x2F;Jun&#x2F;2016:03:14:41 +0800] “HEAD &#x2F; HTTP&#x2F;1.1” 200 -linuxdaxue.com-access_log2）一次查看多个文件#less linuxdaxue.com-access_log linuxdaxue.com-error_log120.26.216.168 - - [12&#x2F;Jun&#x2F;2016:03:09:16 +0800] “HEAD &#x2F; HTTP&#x2F;1.1” 200 -42.96.189.63 - - [12&#x2F;Jun&#x2F;2016:03:09:41 +0800] “HEAD &#x2F; HTTP&#x2F;1.1” 200 -123.56.138.37 - - [12&#x2F;Jun&#x2F;2016:03:12:52 +0800] “HEAD &#x2F; HTTP&#x2F;1.1” 200 -120.26.216.168 - - [12&#x2F;Jun&#x2F;2016:03:14:16 +0800] “HEAD &#x2F; HTTP&#x2F;1.1” 200 -42.96.189.63 - - [12&#x2F;Jun&#x2F;2016:03:14:41 +0800] “HEAD &#x2F; HTTP&#x2F;1.1” 200 -123.56.138.37 - - [12&#x2F;Jun&#x2F;2016:03:17:52 +0800] “HEAD &#x2F; HTTP&#x2F;1.1” 200 -linuxdaxue.com-access_log (file 1 of 2)说明：输入 ：n后，切换到linuxdaxue.com-error_log输入 ：p 后，切换到linuxdaxue.com-access_log 三、Linux less命令常用操作命令接下来给大家介绍一些在less命令比较常用的操作命令，希望大家能够熟练掌握。1）分屏导航 1234ctrl + F - 向前移动一屏ctrl + B - 向后移动一屏ctrl + D - 向前移动半屏ctrl + U - 向后移动半屏 2）单行导航 12j - 向前移动一行k - 向后移动一行 3）其它导航 12G - 移动到最后一行g - 移动到第一行 4）其它命令 1234v - 使用配置的编辑器编辑当前文件h - 显示 less 的帮助文档&amp;pattern - 仅显示匹配模式的行，而不是整个文件q / ZZ - 退出 less 命令 5）标记导航当使用 less 查看内容比较多的文件时，可以作一个标记，然后就能通过命令导航到标有特定标记的文本位置，方式如下所示：ma - 使用 a 标记文本的当前位置。‘a - 导航到标记 a 处好了有关Linux less命令的相关内容就先为大家介绍到这里，less命令非常强大，在此只是为大家做一个简单的介绍，更熟练的掌握还需要大家的多多练习才行。","categories":[],"tags":[{"name":"linux","slug":"linux","permalink":"https://vlwq.github.io/tags/linux/"}]},{"title":"mongodb查询","slug":"2017node/20170715","date":"2017-07-15T02:36:00.000Z","updated":"2022-03-03T03:34:09.447Z","comments":true,"path":"2017/07/15/2017node/20170715/","link":"","permalink":"https://vlwq.github.io/2017/07/15/2017node/20170715/","excerpt":"分页当查询时同时使用sort,skip,limit，无论位置先后，最先执行顺序 sort再skip再limit。","text":"分页当查询时同时使用sort,skip,limit，无论位置先后，最先执行顺序 sort再skip再limit。 想要读取从 10 条记录后 100 条记录，相当于 sql 中limit (10,100)。 1db.getCollection(&#x27;user&#x27;).find.skip(10).limit(100) 以上实例在集合中跳过前面 10 条返回 100 条数据。skip 和 limit 结合就能实现分页。 补充说明：第一个 {} 放 where 条件，为空表示返回集合中所有文档。第二个 {} 指定那些列显示和不显示 （0表示不显示 1表示显示)。 1db.col.find(&#123;&#125;,&#123;&quot;title&quot;:1,_id:0&#125;).limit(2) 条件操作符|操作 |格式 |范例 |RDBMS中的类似语句|—-|——|—-|等于 |&#123;&lt;key&gt;:&lt;value&gt;&#125; |db.col.find({“by”:”guagua”}).pretty() |where by &#x3D; ‘guagua’|小于 |&#123;&lt;key&gt;:&#123;$lt:&lt;value&gt;&#125;&#125; |db.col.find({“likes”:{$lt:50}}).pretty() |where likes &lt; 50|小于或等于 |&#123;&lt;key&gt;:&#123;$lte:&lt;value&gt;&#125;&#125; |db.col.find({“likes”:{$lte:50}}).pretty() |where likes &lt;&#x3D; 50|大于 |&#123;&lt;key&gt;:&#123;$gt:&lt;value&gt;&#125;&#125; |db.col.find({“likes”:{$gt:50}}).pretty() |where likes &gt; 50|大于或等于 |&#123;&lt;key&gt;:&#123;$gte:&lt;value&gt;&#125;&#125; |db.col.find({“likes”:{$gte:50}}).pretty() |where likes &gt;&#x3D; 50|不等于 |&#123;&lt;key&gt;:&#123;$ne:&lt;value&gt;&#125;&#125; |db.col.find({“likes”:{$ne:50}}).pretty() |where likes !&#x3D; 50 and12db.col.find(&#123;&quot;by&quot;:&quot;菜鸟教程&quot;, &quot;title&quot;:&quot;MongoDB 教程&quot;&#125;).pretty()以上实例中类似于 WHERE 语句：WHERE by=&#x27;菜鸟教程&#x27; AND title=&#x27;MongoDB 教程&#x27; or1234567db.col.find( &#123; $or: [ &#123;key1: value1&#125;, &#123;key2:value2&#125; ] &#125;).pretty() AND 和 OR 联合使用123以下实例演示了 AND 和 OR 联合使用，类似常规 SQL 语句为： &#x27;where likes&gt;50 AND (by = &#x27;菜鸟教程&#x27; OR title = &#x27;MongoDB 教程&#x27;)&#x27;db.col.find(&#123;&quot;likes&quot;: &#123;$gt:50&#125;, $or: [&#123;&quot;by&quot;: &quot;菜鸟教程&quot;&#125;,&#123;&quot;title&quot;: &quot;MongoDB 教程&quot;&#125;]&#125;).pretty() 大于等于小于12345678910MongoDB 使用 (&lt;) 和 (&gt;) 查询 - $lt 和 $gtdb.col.find(&#123;likes : &#123;$lt :200, $gt : 100&#125;&#125;)备注：$gt -------- greater than &gt;$gte --------- gt equal &gt;=$lt -------- less than &lt;$lte --------- lt equal &lt;=$ne ----------- not equal !=$eq -------- equal = MongoDB 排序sort()方法可以通过参数指定排序的字段，并使用 1 和 -1 来指定排序的方式，其中 1 为升序排列，而-1是用于降序排列。 12以下实例演示了 col 集合中的数据按字段 likes 的降序排列：db.col.find(&#123;&#125;,&#123;&quot;title&quot;:1,_id:0&#125;).sort(&#123;&quot;likes&quot;:-1&#125;) MongoDB中聚合(aggregate)主要用于处理数据(诸如统计平均值,求和等)，并返回计算后的数据结果。有点类似sql语句中的 count(*)。 123456789101112131415现在我们通过以上集合计算每个作者所写的文章数，使用aggregate()计算结果如下：&gt; db.mycol.aggregate([&#123;$group : &#123;_id : &quot;$by_user&quot;, num_tutorial : &#123;$sum : 1&#125;&#125;&#125;])&#123; &quot;result&quot; : [ &#123; &quot;_id&quot; : &quot;runoob.com&quot;, &quot;num_tutorial&quot; : 2 &#125;, &#123; &quot;_id&quot; : &quot;Neo4j&quot;, &quot;num_tutorial&quot; : 1 &#125; ], &quot;ok&quot; : 1&#125; |表达式 |描述 |实例|—-|——|$sum |计算总和。 |db.mycol.aggregate([{$group : {_id : “$by_user”, num_tutorial : {$sum : “$likes”}}}])|$avg |计算平均值 |db.mycol.aggregate([{$group : {_id : “$by_user”, num_tutorial : {$avg : “$likes”}}}])|$min |获取集合中所有文档对应值得最小值。|db.mycol.aggregate([{$group : {_id : “$by_user”, num_tutorial : {$min : “$likes”}}}])|$max |获取集合中所有文档对应值得最大值。|db.mycol.aggregate([{$group : {_id : “$by_user”, num_tutorial : {$max : “$likes”}}}])|$push |在结果文档中插入值到一个数组中。|db.mycol.aggregate([{$group : {_id : “$by_user”, url : {$push: “$url”}}}])|$addToSet |在结果文档中插入值到一个数组中，但不创建副本。| db.mycol.aggregate([{$group : {_id : “$by_user”, url : {$addToSet : “$url”}}}])|$first |根据资源文档的排序获取第一个文档数据。| db.mycol.aggregate([{$group : {_id : “$by_user”, first_url : {$first : “$url”}}}])|$last |根据资源文档的排序获取最后一个文档数据 |db.mycol.aggregate([{$group : {_id : “$by_user”, last_url : {$last : “$url”}}}]) 管道-聚合框架中常用的几个操作 $project：修改输入文档的结构。可以用来重命名、增加或删除域，也可以用于创建计算结果以及嵌套文档。 $match：用于过滤数据，只输出符合条件的文档。$match使用MongoDB的标准查询操作。 $limit：用来限制MongoDB聚合管道返回的文档数。 $skip：在聚合管道中跳过指定数量的文档，并返回余下的文档。 $unwind：将文档中的某一个数组类型字段拆分成多条，每条包含数组中的一个值。 $group：将集合中的文档分组，可用于统计结果。 $sort：将输入文档排序后输出。 $geoNear：输出接近某一地理位置的有序文档。 $project1234567这样的话结果中就只还有_id,tilte和author三个字段了，默认情况下_id字段是被包含的，填0。。1是显示，0是隐藏 db.getCollection(&#x27;user&#x27;).aggregate( &#123; $project : &#123; id : 1 , deleted : 1 , &#125;&#125; ); $match实例 $match用于获取id&#x3D;0,username不等于guagua记录，然后将符合条件的记录送到下一阶段$group管道操作符进行处理。 1234db.getCollection(&#x27;user&#x27;).aggregate( [ &#123; $match : &#123; id : &#123; $eq : 0&#125; , username:&#123; $ne : &#x27;guagua&#x27; &#125; &#125; &#125;, &#123;$group : &#123;_id : &quot;$username&quot;, gua : &#123;$sum : &#x27;$updated_time&#x27;&#125;&#125;&#125; ] ); $skip实例12db.getCollection(&#x27;user&#x27;).aggregate(&#123;$skip : 2&#125;)经过$skip管道操作符处理后，前2个文档被&quot;过滤&quot;掉 在后台创建索引：1db.values.ensureIndex(&#123;open: 1, close: 1&#125;, &#123;background: true&#125;) MongoDB 自动增长创建 Javascript 函数db.counters.insert(&#123;_id:&quot;gua&quot;,sequence_value:0&#125;) 1234567891011121314function getNextSequenceValue(sequenceName)&#123; var sequenceDocument = db.counters.findAndModify( &#123; query:&#123;_id: sequenceName &#125;, update: &#123;$inc:&#123;sequence_value:1&#125;&#125;, new:true &#125;); return sequenceDocument.sequence_value;&#125;db.counters.insert(&#123; &quot;_id&quot;:getNextSequenceValue(&quot;gua&quot;), &quot;product_name&quot;:&quot;Apple iPhone&quot;, &#x27;test&#x27;:&#x27;guaguagua&#x27;&#125;) $type 操作符 类型 数字 备注 Double 1 String 2 Object 3 Array 4 Binary data 5 Undefined 6 已废弃。 Object id 7 Boolean 8 Date 9 Null 10 Regular Expression 11 JavaScript 13 Symbol 14 JavaScript (with scope) 15 32-bit integer 16 Timestamp 17 64-bit integer 18 Min key 255 Query with -1. Max key 127 12如果想获取 &quot;col&quot; 集合中 title 为 String 的数据，你可以使用以下命令：db.col.find(&#123;&quot;title&quot; : &#123;$type : 2&#125;&#125;) 时间戳 1234db.getCollection(&#x27;counters&#x27;).find(&#123;gua:&#123; $gte:new Date(2017,7,01).getTime(), $lte:new Date(2017,7,18).getTime() &#125;&#125;)","categories":[],"tags":[{"name":"node","slug":"node","permalink":"https://vlwq.github.io/tags/node/"}]},{"title":"ES6特性","slug":"2016fe/20170711","date":"2017-07-11T02:36:00.000Z","updated":"2022-03-03T03:33:41.877Z","comments":true,"path":"2017/07/11/2016fe/20170711/","link":"","permalink":"https://vlwq.github.io/2017/07/11/2016fe/20170711/","excerpt":"ES6特性如下： 1.块级作用域 关键字let, 常量const 2.对象字面量的属性赋值简写（property value shorthand）","text":"ES6特性如下： 1.块级作用域 关键字let, 常量const 2.对象字面量的属性赋值简写（property value shorthand） 12345678910111213var obj = &#123; // __proto__ __proto__: theProtoObj, // Shorthand for ‘handler: handler’ handler, // Method definitions toString() &#123; // Super calls return &quot;d &quot; + super.toString(); &#125;, // Computed (dynamic) property names [ &#x27;prop_&#x27; + (() =&gt; 42)() ]: 42&#125;; 3.赋值解构 1234let singer = &#123; first: &quot;Bob&quot;, last: &quot;Dylan&quot; &#125;;let &#123; first: f, last: l &#125; = singer; // 相当于 f = &quot;Bob&quot;, l = &quot;Dylan&quot;let [all, year, month, day] = /^(\\d\\d\\d\\d)-(\\d\\d)-(\\d\\d)$/.exec(&quot;2015-10-25&quot;);let [x, y] = [1, 2, 3]; // x = 1, y = 2 4.函数参数 - 默认值、参数打包、 数组展开（Default 、Rest 、Spread） 1234567891011121314151617//Defaultfunction findArtist(name=&#x27;lu&#x27;, age=&#x27;26&#x27;) &#123; ...&#125;//Restfunction f(x, ...y) &#123; // y is an Array return x * y.length;&#125;f(3, &quot;hello&quot;, true) == 6//Spreadfunction f(x, y, z) &#123; return x + y + z;&#125;// Pass each elem of array as argumentf(...[1,2,3]) == 6 5.箭头函数 Arrow functions (1).简化了代码形式，默认return表达式结果。 (2).自动绑定语义this，即定义函数时的this。如上面例子中，forEach的匿名函数参数中用到的this。 6.字符串模板 Template strings 123var name = &quot;Bob&quot;, time = &quot;today&quot;;`Hello $&#123;name&#125;, how are you $&#123;time&#125;?`// return &quot;Hello Bob, how are you today?&quot; Iterators（迭代器）+ for..of 迭代器有个next方法，调用会返回： 12345678(1).返回迭代对象的一个元素：&#123; done: false, value: elem &#125;(2).如果已到迭代对象的末端：&#123; done: true, value: retVal &#125;for (var n of [&#x27;a&#x27;,&#x27;b&#x27;,&#x27;c&#x27;]) &#123; console.log(n);&#125;// 打印a、b、c 8.生成器 （Generators） 9.Class Class，有constructor、extends、super，但本质上是语法糖（对语言的功能并没有影响，但是更方便程序员使用）。 123456789101112131415161718192021222324252627class Artist &#123; constructor(name) &#123; this.name = name; &#125; perform() &#123; return this.name + &quot; performs &quot;; &#125;&#125;class Singer extends Artist &#123; constructor(name, song) &#123; super.constructor(name); this.song = song; &#125; perform() &#123; return super.perform() + &quot;[&quot; + this.song + &quot;]&quot;; &#125;&#125;let james = new Singer(&quot;Etta James&quot;, &quot;At last&quot;);james instanceof Artist; // truejames instanceof Singer; // truejames.perform(); // &quot;Etta James performs [At last]&quot; 10.Modules ES6的内置模块功能借鉴了CommonJS和AMD各自的优点： (1).具有CommonJS的精简语法、唯一导出出口(single exports)和循环依赖(cyclic dependencies)的特点。 (2).类似AMD，支持异步加载和可配置的模块加载。 1234567891011121314151617181920212223// lib/math.jsexport function sum(x, y) &#123; return x + y;&#125;export var pi = 3.141593;// app.jsimport * as math from &quot;lib/math&quot;;alert(&quot;2π = &quot; + math.sum(math.pi, math.pi));// otherApp.jsimport &#123;sum, pi&#125; from &quot;lib/math&quot;;alert(&quot;2π = &quot; + sum(pi, pi));Module Loaders:// Dynamic loading – ‘System’ is default loaderSystem.import(&#x27;lib/math&#x27;).then(function(m) &#123; alert(&quot;2π = &quot; + m.sum(m.pi, m.pi));&#125;);// Directly manipulate module cacheSystem.get(&#x27;jquery&#x27;);System.set(&#x27;jquery&#x27;, Module(&#123;$: $&#125;)); // WARNING: not yet finalized 11.Map + Set + WeakMap + WeakSet 四种集合类型，WeakMap、WeakSet作为属性键的对象如果没有别的变量在引用它们，则会被回收释放掉。 123456789101112131415161718192021// Setsvar s = new Set();s.add(&quot;hello&quot;).add(&quot;goodbye&quot;).add(&quot;hello&quot;);s.size === 2;s.has(&quot;hello&quot;) === true;// Mapsvar m = new Map();m.set(&quot;hello&quot;, 42);m.set(s, 34);m.get(s) == 34;//WeakMapvar wm = new WeakMap();wm.set(s, &#123; extra: 42 &#125;);wm.size === undefined// Weak Setsvar ws = new WeakSet();ws.add(&#123; data: 42 &#125;);//Because the added object has no other references, it will not be held in the set 12.Math + Number + String + Array + Object APIs 一些新的API 123456789101112131415161718192021222324Number.EPSILONNumber.isInteger(Infinity) // falseNumber.isNaN(&quot;NaN&quot;) // falseMath.acosh(3) // 1.762747174039086Math.hypot(3, 4) // 5Math.imul(Math.pow(2, 32) - 1, Math.pow(2, 32) - 2) // 2&quot;abcde&quot;.includes(&quot;cd&quot;) // true&quot;abc&quot;.repeat(3) // &quot;abcabcabc&quot;Array.from(document.querySelectorAll(&#x27;*&#x27;)) // Returns a real ArrayArray.of(1, 2, 3) // Similar to new Array(...), but without special one-arg behavior[0, 0, 0].fill(7, 1) // [0,7,7][1, 2, 3].find(x =&gt; x == 3) // 3[1, 2, 3].findIndex(x =&gt; x == 2) // 1[1, 2, 3, 4, 5].copyWithin(3, 0) // [1, 2, 3, 1, 2][&quot;a&quot;, &quot;b&quot;, &quot;c&quot;].entries() // iterator [0, &quot;a&quot;], [1,&quot;b&quot;], [2,&quot;c&quot;][&quot;a&quot;, &quot;b&quot;, &quot;c&quot;].keys() // iterator 0, 1, 2[&quot;a&quot;, &quot;b&quot;, &quot;c&quot;].values() // iterator &quot;a&quot;, &quot;b&quot;, &quot;c&quot;Object.assign(Point, &#123; origin: new Point(0,0) &#125;) Proxies 使用代理（Proxy）监听对象的操作，然后可以做一些相应事情。 1234567891011var target = &#123;&#125;;var handler = &#123; get: function (receiver, name) &#123; return `Hello, $&#123;name&#125;!`; &#125;&#125;;var p = new Proxy(target, handler);p.world === &#x27;Hello, world!&#x27;;可监听的操作： get、set、has、deleteProperty、apply、construct、getOwnPropertyDescriptor、defineProperty、getPrototypeOf、setPrototypeOf、enumerate、ownKeys、preventExtensions、isExtensible。 14.Symbols Symbol是一种基本类型。Symbol 通过调用symbol函数产生，它接收一个可选的名字参数，该函数返回的symbol是唯一的。 123var key = Symbol(&quot;key&quot;);var key2 = Symbol(&quot;key&quot;);key == key2 //false 15.Promises Promises是处理异步操作的对象，使用了 Promise 对象之后可以用一种链式调用的方式来组织代码，让代码更加直观（类似jQuery的deferred 对象）。 1234567891011121314151617function fakeAjax(url) &#123; return new Promise(function (resolve, reject) &#123; // setTimeouts are for effect, typically we would handle XHR if (!url) &#123; return setTimeout(reject, 1000); &#125; return setTimeout(resolve, 1000); &#125;);&#125;// no url, promise rejectedfakeAjax().then(function () &#123; console.log(&#x27;success&#x27;);&#125;,function () &#123; console.log(&#x27;fail&#x27;);&#125;);","categories":[],"tags":[{"name":"FE","slug":"FE","permalink":"https://vlwq.github.io/tags/FE/"}]},{"title":"BBR加速","slug":"2016linux/20170710","date":"2017-07-10T02:36:00.000Z","updated":"2017-07-16T04:27:15.191Z","comments":true,"path":"2017/07/10/2016linux/20170710/","link":"","permalink":"https://vlwq.github.io/2017/07/10/2016linux/20170710/","excerpt":"Debian &#x2F; Ubuntu 14.04 + CentOS用户请使用这个脚本：CentOS/Debian/Ubuntu系统 TCP-BBR 一键安装脚本 本脚本只在 Debian 7 / Debian 8 / Ubuntu 14.04 / Ubuntu 16.04 (均 x64位) 这几个系统中测试过脚本可以正常运行(Vultr)！ 强烈推荐 Debian 7 x64，这个是我一直使用的系统，我的脚本在这个系统上面出错率最低。 至于为什么不支持 CentOS 等系统，主要是我不怎么用其他的系统，就不做支持了。","text":"Debian &#x2F; Ubuntu 14.04 + CentOS用户请使用这个脚本：CentOS/Debian/Ubuntu系统 TCP-BBR 一键安装脚本 本脚本只在 Debian 7 / Debian 8 / Ubuntu 14.04 / Ubuntu 16.04 (均 x64位) 这几个系统中测试过脚本可以正常运行(Vultr)！ 强烈推荐 Debian 7 x64，这个是我一直使用的系统，我的脚本在这个系统上面出错率最低。 至于为什么不支持 CentOS 等系统，主要是我不怎么用其他的系统，就不做支持了。 安装步骤更换内核需要ROOT权限，所以如果你是普通用户 的话，需要ROOT账号权限，如果你是ROOT账号，那就忽略这个步骤： 1sudo su 输入并回车后，会提示让你输入当前账号的密码，输入并回车后就可以继续下面的步骤了。 1wget -N --no-check-certificate https://softs.pw/Bash/bbr.sh &amp;&amp; chmod +x bbr.sh &amp;&amp; bash bbr.sh 备用下载地址（上面的链接无法下载，就用这个）： 1wget -N --no-check-certificate https://raw.githubusercontent.com/ToyoDAdoubi/doubi/master/bbr.sh &amp;&amp; chmod +x bbr.sh &amp;&amp; bash bbr.sh 下载并运行脚本后，会自动检测并开始安装，首先会提示你输入要下载的内核版本，可以安装自定义版本的内核，也可以直接回车安装最新版本的内核（内核版本获取）！ 1234请输入 要下载安装的Linux内核版本(BBR) [ 格式: x.xx.xx ，例如: 4.10.12 ] [注意]内核版本列表请去这里获取：[ http://kernel.ubuntu.com/~kernel-ppa/mainline/ ](默认回车，自动获取最新版本):4.10.10 如果没有出错，内核更换完毕后，会提示是否立即重启VPS，直接回车或者输入 Y 。需要重启VPS后，才能开启BBR，是否现在重启 ? [Y&#x2F;n] : y[注意] 重启VPS后，请重新运行脚本开启BBR: bash bbr.sh start [信息] VPS 重启中… 等待十几秒，VPS启动后，重新通过SSH连接VPS，进入 bbr.sh 脚本的目录，然后执行下面这个命令开启BBR。 1bash bbr.sh start 然后就会自动开启BBR。如果重启VPS后，无法连接，说明内核安装或与系统存在兼容性问题，无法正常启动，代表你的VPS当前系统无法使用BBR，请更换其他系统！ 使用方法 123456789101112# 启动BBR，更换/升级内核并重启后，需要执行这个开启BBR！bash bbr.sh start# 关闭BBRbash bbr.sh stop# 查看BBR状态bash bbr.sh status# 升级BBRbash bbr.sh# 因为BBR是集成于内核中的，只是内核中的一部分，所以不一定要更新最新的内核，因为内核升级不一定是BBR升级。 卸载BBR BBR集成于内核中，所以卸载BBR&#x3D;更换内核，教程： 其他说明 注意：TCP-BBR必须是 2016-12-05 21:00 更新的 4.9.0-rc8 内核及以后的版本 才能开启，而锐速并不支持这个最新的内核版本，所以TCP-BBR和锐速是不可能共存的。裸SS &#x2F; 锐速+SS &#x2F; BBR+SS简单速度对比，仅供参考，看这里。 更换内核后重启服务器无法启动 的问题 如果重启VPS后，无法连接，说明内核安装有问题 或 内核与系统存在兼容性问题，无法正常启动。 这代表你的VPS当前系统不支持最新的内核版本，无法开启BBR，请更换其他系统尝试！ 1提示 wget: unknown host “softs.pw” 之类的错误 这是无法解析我的域名，多半是DNS的问题，请更换DNS为谷歌DNS。 123echo &quot;nameserver 8.8.8.8&quot; &gt; /etc/resolv.confecho &quot;nameserver 8.8.4.4&quot; &gt;&gt; /etc/resolv.conf提示 wget: command not found 的错误 这是你的系统精简的太干净了，wget都没有安装，所以需要安装wget。 123Debian/Ubuntu系统:apt-get install -y wget","categories":[],"tags":[{"name":"linux","slug":"linux","permalink":"https://vlwq.github.io/tags/linux/"}]},{"title":"mongoose 模型定义重复引用就报错：Cannot overwrite model once compiled 怎么解决？","slug":"2017node/20170708","date":"2017-07-08T02:36:00.000Z","updated":"2022-03-03T03:24:01.829Z","comments":true,"path":"2017/07/08/2017node/20170708/","link":"","permalink":"https://vlwq.github.io/2017/07/08/2017node/20170708/","excerpt":"错误提示的意思是：mongoose模型被重复定义了，这是不允许的 首先，你需要搞清楚require和module.exports的运行机制，建议你看看这篇：http://www.nodeclass.com/articles/37488","text":"错误提示的意思是：mongoose模型被重复定义了，这是不允许的 首先，你需要搞清楚require和module.exports的运行机制，建议你看看这篇：http://www.nodeclass.com/articles/37488 然后，针对你这个场景，不应该把 mongoose.model()模型定义方法做为模块导出的方法，因为： 模型定义不允许重复，所以这个mongoose.model()应该只调用一次，而导出它执行后的结果require机制确保了mongoose.model()只会执行一次 所以，你的代码应该改写成这样： 123456var UserAccountSchema = mongoose.Schema(&#123; //...略去定义代码&#125;);var model = mongoose.model(&#x27;user.account&#x27;, UserAccountSchema);//导出模型module.exports =model;","categories":[],"tags":[{"name":"node","slug":"node","permalink":"https://vlwq.github.io/tags/node/"}]},{"title":"electron打包程序","slug":"2017node/20170705","date":"2017-07-05T02:36:00.000Z","updated":"2022-03-03T03:23:55.488Z","comments":true,"path":"2017/07/05/2017node/20170705/","link":"","permalink":"https://vlwq.github.io/2017/07/05/2017node/20170705/","excerpt":"目录结构T:&#x2F;player&#x2F;index.html(网页入口)T:&#x2F;player&#x2F;main.jsT:&#x2F;player&#x2F;package.json&#x2F;&#x2F;成功打包的话，会player同级目录生成exeT:&#x2F;outplayer&#x2F;项目名","text":"目录结构T:&#x2F;player&#x2F;index.html(网页入口)T:&#x2F;player&#x2F;main.jsT:&#x2F;player&#x2F;package.json&#x2F;&#x2F;成功打包的话，会player同级目录生成exeT:&#x2F;outplayer&#x2F;项目名 mian.js12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364const electron = require(&#x27;electron&#x27;)// Module to control application life.const app = electron.app// Module to create native browser window.const BrowserWindow = electron.BrowserWindowconst path = require(&#x27;path&#x27;)const url = require(&#x27;url&#x27;)// Keep a global reference of the window object, if you don&#x27;t, the window will// be closed automatically when the JavaScript object is garbage collected.let mainWindowfunction createWindow() &#123; // Create the browser window. mainWindow = new BrowserWindow(&#123; width: 1200, height: 800 &#125;) // and load the index.html of the app. mainWindow.loadURL(url.format(&#123; pathname: path.join(__dirname, &#x27;index.html&#x27;), protocol: &#x27;file:&#x27;, slashes: true &#125;)) // Open the DevTools.我默认关闭了调试模式 //mainWindow.webContents.openDevTools() // Emitted when the window is closed. mainWindow.on(&#x27;closed&#x27;, function() &#123; // Dereference the window object, usually you would store windows // in an array if your app supports multi windows, this is the time // when you should delete the corresponding element. mainWindow = null &#125;)&#125;// This method will be called when Electron has finished// initialization and is ready to create browser windows.// Some APIs can only be used after this event occurs.app.on(&#x27;ready&#x27;, createWindow)// Quit when all windows are closed.app.on(&#x27;window-all-closed&#x27;, function() &#123; // On OS X it is common for applications and their menu bar // to stay active until the user quits explicitly with Cmd + Q if (process.platform !== &#x27;darwin&#x27;) &#123; app.quit() &#125;&#125;)app.on(&#x27;activate&#x27;, function() &#123; // On OS X it&#x27;s common to re-create a window in the app when the // dock icon is clicked and there are no other windows open. if (mainWindow === null) &#123; createWindow() &#125;&#125;)// In this file you can include the rest of your app&#x27;s specific main process// code. You can also put them in separate files and require them here. package.json123456789101112131415161718&#123; &quot;name&quot;: &quot;player&quot;, &quot;version&quot;: &quot;1.0.0&quot;, &quot;description&quot;: &quot;a music player&quot;, &quot;main&quot;: &quot;main.js&quot;, &quot;scripts&quot;: &#123; &quot;start&quot;: &quot;electron .&quot;, &quot;pack&quot;: &quot;electron-packager ./ andrewplayer --win32 --out ./../outplayer --electronVersion 1.4.13 --overwrite&quot; &#125;, &quot;author&quot;: &quot;Andrew li&quot;, &quot;license&quot;: &quot;ISC&quot;, &quot;dependencies&quot;: &#123; &quot;electron&quot;: &quot;^1.6.11&quot;, &quot;electron-packager&quot;: &quot;^8.7.2&quot;, &quot;electron-prebuilt&quot;: &quot;^1.4.13&quot; &#125;&#125; package文件的打包脚本pack说明一下：andrewplayer –是我的程序名win32 –生成windows下的exe可执行文件,其他平台: linux, win32, darwin, mas, all.&#x2F;..&#x2F;outplayer —生成的项目所在地方，和player（当前项目）同级目录–electronVersion 1.4.13 —这个是electron-prebuilt的版本 更多查 官网api 开始安装，先把源切到淘宝的镜像（yarn官网那个时慢时快）1234// 查看下载源yarn config get registry &#x2F;&#x2F; 更换为淘宝源 1yarn config set registry https://registry.npm.taobao.org 后面直接运行脚本即可1yarn install 先测试下能不能用 1yarn run start 最后打包1yarn run pack 和player同级目录外面应该已经生成一个outplayer目录了","categories":[],"tags":[{"name":"node","slug":"node","permalink":"https://vlwq.github.io/tags/node/"}]},{"title":"yarn更换为淘宝镜像","slug":"2017node/20170701","date":"2017-07-01T02:36:00.000Z","updated":"2017-07-16T04:34:21.559Z","comments":true,"path":"2017/07/01/2017node/20170701/","link":"","permalink":"https://vlwq.github.io/2017/07/01/2017node/20170701/","excerpt":"npm install cnpm cnpm install yarn -g","text":"npm install cnpm cnpm install yarn -g 1234// 查看下载源yarn config get registry &#x2F;&#x2F; 更换为淘宝源 1yarn config set registry https://registry.npm.taobao.org &#x2F;&#x2F; 初始化项目 1yarn init -y &#x2F;&#x2F; 安装webpack 1yarn add webpack &#x2F;&#x2F; 安装webpack到dev 1yarn add webpack -D &#x2F;&#x2F; 更新到最新的 1yarn upgrade webpack &#x2F;&#x2F; 安装项目里的依赖 1yarn install","categories":[],"tags":[{"name":"node","slug":"node","permalink":"https://vlwq.github.io/tags/node/"}]},{"title":"html 网页中的锚点(命名锚记)的使用介绍","slug":"2016fe/20170626","date":"2017-06-26T02:36:00.000Z","updated":"2022-03-03T03:33:05.564Z","comments":true,"path":"2017/06/26/2016fe/20170626/","link":"","permalink":"https://vlwq.github.io/2017/06/26/2016fe/20170626/","excerpt":"锚点是网页制作中超级链接的一种，又叫命名锚记。命名锚记像一个迅速定位器一样是一种页面内的超级链接，运用相当普遍。英文名：anchor使用命名锚记可以在文档中设置标记，这些标记通常放在文档的特定主题处或顶部。然后可以创建到这些命名锚记的链接，这些链接可快速将访问者带到指定位置。创建到命名锚记的链接的过程分为两步。首先，创建命名锚记，然后创建到该命名锚记的链接。","text":"锚点是网页制作中超级链接的一种，又叫命名锚记。命名锚记像一个迅速定位器一样是一种页面内的超级链接，运用相当普遍。英文名：anchor使用命名锚记可以在文档中设置标记，这些标记通常放在文档的特定主题处或顶部。然后可以创建到这些命名锚记的链接，这些链接可快速将访问者带到指定位置。创建到命名锚记的链接的过程分为两步。首先，创建命名锚记，然后创建到该命名锚记的链接。 12345678910111213141516代码如下: 这种方法测试不行必须加上id这个字段才可以&lt;html&gt;&lt;body&gt;&lt;p&gt;&lt;a href=&quot;#method1&quot;&gt;页面锚点方法一&lt;/a&gt;&lt;/p&gt;&lt;p&gt;&lt;a href=&quot;#method2&quot;&gt;页面锚点方法二&lt;/a&gt;&lt;/p&gt;&lt;h2&gt;&lt;a name=&quot;method1&quot;&gt;方法一&lt;/a&gt;&lt;/h2&gt;&lt;p&gt;使用锚标签的 href 和 name 属性&lt;/p&gt;&lt;h2 id=&quot;method2&quot;&gt;方法二&lt;/h2&gt;&lt;p&gt;使用锚标签和 id 属性&lt;/p&gt;&lt;/body&gt;&lt;/html&gt;","categories":[],"tags":[{"name":"FE","slug":"FE","permalink":"https://vlwq.github.io/tags/FE/"}]},{"title":"mongoose分页","slug":"2017node/20170625","date":"2017-06-25T11:36:00.000Z","updated":"2017-07-04T13:57:10.592Z","comments":true,"path":"2017/06/25/2017node/20170625/","link":"","permalink":"https://vlwq.github.io/2017/06/25/2017node/20170625/","excerpt":"123456789var mongoose = require(&#x27;mongoose&#x27;);mongoose.connect(&#x27;MongoDB://192.168.0.229:27017/Test&#x27;);var Cat = mongoose.model(&#x27;Cat&#x27;, &#123; name: String , _id:String , age:&#123; type: Number, min: 18, max: 65 &#125;&#125;);","text":"123456789var mongoose = require(&#x27;mongoose&#x27;);mongoose.connect(&#x27;MongoDB://192.168.0.229:27017/Test&#x27;);var Cat = mongoose.model(&#x27;Cat&#x27;, &#123; name: String , _id:String , age:&#123; type: Number, min: 18, max: 65 &#125;&#125;); 12345678910111213var query=Cat.find(&#123;&#125;);query.where(&#123;age:30&#125;);query.sort(&#123; name: &#x27;asc&#x27;, age: -1 &#125;);//query.and(&#123;_id:&quot;123456222&quot;&#125;);query.or([&#123;_id:&quot;123456fff222&quot;&#125;,&#123;_id:&quot;123456222&quot;&#125;]);//query.limit(3); //限制条数//query.skip(3) //开始数 ，通过计算可是实现分页//query.friends(&#x27;name&#x27;)query.exec(function(err,docs)&#123; console.log(docs);&#125;) 开发文档地址：http://mongoosejs.com/docs/api.html#query_Query-or","categories":[],"tags":[{"name":"node","slug":"node","permalink":"https://vlwq.github.io/tags/node/"}]},{"title":"bootstrap弹出框","slug":"2016fe/20170623","date":"2017-06-22T16:00:00.000Z","updated":"2022-03-03T03:32:48.995Z","comments":true,"path":"2017/06/23/2016fe/20170623/","link":"","permalink":"https://vlwq.github.io/2017/06/23/2016fe/20170623/","excerpt":"bootstrap弹出框标签（空格分隔）： bootstrap","text":"bootstrap弹出框标签（空格分隔）： bootstrap 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667&lt;!DOCTYPE html&gt;&lt;html&gt;&lt;head&gt; &lt;meta charset=&quot;utf-8&quot;&gt; &lt;title&gt;Bootstrap 实例 - 模态框（Modal）插件&lt;/title&gt; &lt;link rel=&quot;stylesheet&quot; href=&quot;http://cdn.static.runoob.com/libs/bootstrap/3.3.7/css/bootstrap.min.css&quot;&gt; &lt;script src=&quot;http://cdn.static.runoob.com/libs/jquery/2.1.1/jquery.min.js&quot;&gt;&lt;/script&gt; &lt;script src=&quot;http://cdn.static.runoob.com/libs/bootstrap/3.3.7/js/bootstrap.min.js&quot;&gt;&lt;/script&gt;&lt;/head&gt;&lt;body&gt;&lt;h2&gt;创建模态框（Modal）&lt;/h2&gt;&lt;!-- 按钮触发模态框 --&gt;&lt;button class=&quot;btn btn-primary btn-lg&quot; data-toggle=&quot;modal&quot; data-target=&quot;#myModal&quot;&gt; 开始演示模态框&lt;/button&gt;&lt;!-- 模态框（Modal） --&gt;&lt;div class=&quot;modal fade&quot; id=&quot;myModal&quot; tabindex=&quot;-1&quot; role=&quot;dialog&quot; aria-labelledby=&quot;myModalLabel&quot; aria-hidden=&quot;true&quot;&gt; &lt;div class=&quot;modal-dialog&quot;&gt; &lt;div class=&quot;modal-content&quot;&gt; &lt;div class=&quot;modal-header&quot;&gt; &lt;button type=&quot;button&quot; class=&quot;close&quot; data-dismiss=&quot;modal&quot; aria-hidden=&quot;true&quot;&gt; &amp;times; &lt;/button&gt; &lt;h4 class=&quot;modal-title&quot; id=&quot;myModalLabel&quot;&gt; 模态框（Modal）标题 &lt;/h4&gt; &lt;/div&gt; &lt;div class=&quot;modal-body&quot;&gt; &lt;form class=&quot;bs-example bs-example-form&quot; role=&quot;form&quot;&gt; &lt;div class=&quot;input-group&quot;&gt; &lt;span class=&quot;input-group-addon&quot;&gt;字段1&lt;/span&gt; &lt;input type=&quot;text&quot; class=&quot;form-control&quot; placeholder=&quot;测试&quot;&gt; &lt;span class=&quot;input-group-addon&quot;&gt;字段2&lt;/span&gt; &lt;input type=&quot;text&quot; class=&quot;form-control&quot; &gt; &lt;/div&gt; &lt;br&gt; &lt;div class=&quot;input-group&quot;&gt; &lt;span class=&quot;input-group-addon&quot;&gt;字段1&lt;/span&gt; &lt;input type=&quot;text&quot; class=&quot;form-control&quot; placeholder=&quot;测试&quot;&gt; &lt;span class=&quot;input-group-addon&quot;&gt;字段2&lt;/span&gt; &lt;input type=&quot;text&quot; class=&quot;form-control&quot; &gt; &lt;/div&gt; &lt;br&gt; &lt;div class=&quot;input-group&quot;&gt; &lt;span class=&quot;input-group-addon&quot;&gt;字段1&lt;/span&gt; &lt;input type=&quot;text&quot; class=&quot;form-control&quot; placeholder=&quot;测试&quot;&gt; &lt;span class=&quot;input-group-addon&quot;&gt;字段2&lt;/span&gt; &lt;input type=&quot;text&quot; class=&quot;form-control&quot; &gt; &lt;/div&gt; &lt;/form&gt; &lt;/div&gt; &lt;div class=&quot;modal-footer&quot;&gt; &lt;button type=&quot;button&quot; class=&quot;btn btn-default&quot; data-dismiss=&quot;modal&quot;&gt;关闭 &lt;/button&gt; &lt;button type=&quot;button&quot; class=&quot;btn btn-primary&quot;&gt; 提交更改 &lt;/button&gt; &lt;/div&gt; &lt;/div&gt;&lt;!-- /.modal-content --&gt; &lt;/div&gt;&lt;!-- /.modal --&gt;&lt;/div&gt;&lt;/body&gt;&lt;/html&gt;","categories":[],"tags":[{"name":"FE","slug":"FE","permalink":"https://vlwq.github.io/tags/FE/"}]},{"title":"mongoose里.save()/update()/findOneAndUpdate()的区别","slug":"2017node/20170622","date":"2017-06-22T02:36:00.000Z","updated":"2022-03-03T03:22:34.021Z","comments":true,"path":"2017/06/22/2017node/20170622/","link":"","permalink":"https://vlwq.github.io/2017/06/22/2017node/20170622/","excerpt":".save()和update()update比find之后save()效率高，因为这样不用读取整个文档。Mongoose的update是MongoDB的update，但是Mongoose的save可能是MongoDB的插入或是update。","text":".save()和update()update比find之后save()效率高，因为这样不用读取整个文档。Mongoose的update是MongoDB的update，但是Mongoose的save可能是MongoDB的插入或是update。 关于save，mongoose会自动diff新文档，只更改更新部分。这有利于原子性。update不能触发中间件，validation默认不能，但是可以修改。update()和findOneAndUpdate()update()返回数据处理条数findOneAndUpdate()返回处理后的数据简单来说，你需要获取数据就用findOneAndUpdate()，只需要修改数据而不关注修改后数据那就用update()。","categories":[],"tags":[{"name":"node","slug":"node","permalink":"https://vlwq.github.io/tags/node/"}]},{"title":"spy-debugger","slug":"2017node/20170620","date":"2017-06-20T02:36:00.000Z","updated":"2022-03-03T03:22:25.089Z","comments":true,"path":"2017/06/20/2017node/20170620/","link":"","permalink":"https://vlwq.github.io/2017/06/20/2017node/20170620/","excerpt":"","text":"https://github.com/wuchangming/spy-debugger推荐一个移动端的调试工具，可在 pc 端操作移动端页面，可看到操作台","categories":[],"tags":[{"name":"node","slug":"node","permalink":"https://vlwq.github.io/tags/node/"}]},{"title":"高程笔记9-新api","slug":"2017高程/20170617","date":"2017-06-17T02:36:00.000Z","updated":"2017-07-16T04:25:43.362Z","comments":true,"path":"2017/06/17/2017高程/20170617/","link":"","permalink":"https://vlwq.github.io/2017/06/17/2017%E9%AB%98%E7%A8%8B/20170617/","excerpt":"高程笔记9","text":"高程笔记9 requestAnimationFrame()1234567891011mozRequestAnimationFrame()方法接收一个参数，即在重绘屏幕前调用的一个函数。这个函数负责改变下一次重绘时的 DOM 样式。为了创建动画循环，可以像以前使用 setTimeout()一样，把多个对 mozRequestAnimationFrame()的调用连缀起来。比如：function updateProgress()&#123; var div = document.getElementById(&quot;status&quot;); div.style.width = (parseInt(div.style.width, 10) + 5) + &quot;%&quot;; if (div.style.left != &quot;100%&quot;)&#123; mozRequestAnimationFrame(updateProgress); &#125;&#125;mozRequestAnimationFrame(updateProgress); webkitRequestAnimationFrame与msRequestAnimationFrame 基于 mozRequestAnimationFrame()，Chrome 和 IE10+也都给出了自己的实现，分别叫 webkitRequestAnimationFrame()和msRequestAnimationFrame()。这两个版本与 Mozilla 的版本有两个方面的微小差异。首先，不会给回调函数传递时间码，因此你无法知道下一次重绘将发生在什么时间。其次，Chrome 又增加了第二个可选的参数，即将要发生变化的 DOM 元素。知道了重绘将发生在页面中哪个特定元素的区域内，就可以将重绘限定在该区域中。既然没有下一次重绘的时间码，那 Chrome 和 IE 没有提供 mozAnimationStartTime 的实现也就很容易理解了——没有那个时间码，实现这个属性也没有什么用。不过，Chrome 倒是又提供了另一个方法 webkitCancelAnimationFrame()，用于取消之前计划执行的重绘操作。假如你不需要知道精确的时间差，那么可以在 Firefox 4+、IE10+和 Chrome 中可以参考以下模式创建动画循环。 1234567891011121314151617181920(function()&#123; function draw(timestamp)&#123; //计算两次重绘的时间间隔 var drawStart = (timestamp || Date.now()), diff = drawStart - startTime; //使用 diff 确定下一步的绘制时间 //把 startTime 重写为这一次的绘制时间 startTime = drawStart; //重绘 UI requestAnimationFrame(draw); &#125; var requestAnimationFrame = window.requestAnimationFrame || window.mozRequestAnimationFrame || window.webkitRequestAnimationFrame || window.msRequestAnimationFrame, startTime = window.mozAnimationStartTime || Date.now(); requestAnimationFrame(draw);&#125;)(); File APIFile API 在表单中的文件输入字段的基础上，又添加了一些直接访问文件信息的接口。HTML5 在DOM 中为文件输入元素添加了一个 files 集合。在通过文件输入字段选择了一或多个文件时，files集合中将包含一组 File 对象，每个 File 对象对应着一个文件。每个 File 对象都有下列只读属性。  name：本地文件系统中的文件名。 size：文件的字节大小。 type：字符串，文件的 MIME 类型。 lastModifiedDate：字符串，文件上一次被修改的时间（只有 Chrome 实现了这个属性）。举个例子，通过侦听 change 事件并读取 files 集合就可以知道选择的每个文件的信息： 1234567891011var filesList = document.getElementById(&quot;files-list&quot;);EventUtil.addHandler(filesList, &quot;change&quot;, function(event)&#123;var files = EventUtil.getTarget(event).files, i = 0, len = files.length; while (i &lt; len)&#123; console.log(files[i].name + &quot; (&quot; + files[i].type + &quot;, &quot; + files[i].size + &quot; bytes) &quot;); i++; &#125;&#125;); FileReader类型FileReader类型实现的是一种异步文件读取机制。可以把FileReader想象成XMLHttpRequest，区别只是它读取的是文件系统，而不是远程服务器。为了读取文件中的数据，FileReader 提供了如下几个方法。  readAsText(file,encoding)：以纯文本形式读取文件，将读取到的文本保存在 result 属性中。第二个参数用于指定编码类型，是可选的。 readAsDataURL(file)：读取文件并将文件以数据 URI 的形式保存在 result 属性中。 readAsBinaryString(file)：读取文件并将一个字符串保存在 result 属性中，字符串中的每个字符表示一字节。 readAsArrayBuffer(file)：读取文件并将一个包含文件内容的 ArrayBuffer 保存在result 属性中。这些读取文件的方法为灵活地处理文件数据提供了极大便利。例如，可以读取图像文件并将其保存为数据 URI，以便将其显示给用户，或者为了解析方便，可以将文件读取为文本形式。 123456789101112131415161718192021222324252627282930313233343536373839404142var filesList = document.getElementById(&quot;files-list&quot;);EventUtil.addHandler(filesList, &quot;change&quot;, function(event)&#123; var info = &quot;&quot;, output = document.getElementById(&quot;output&quot;), progress = document.getElementById(&quot;progress&quot;), files = EventUtil.getTarget(event).files, type = &quot;default&quot;, reader = new FileReader(); if (/image/.test(files[0].type))&#123; reader.readAsDataURL(files[0]); type = &quot;image&quot;; &#125; else &#123; reader.readAsText(files[0]); type = &quot;text&quot;; &#125; reader.onerror = function()&#123; output.innerHTML = &quot;Could not read file, error code is &quot; + reader.error.code; &#125;; reader.onprogress = function(event)&#123; if (event.lengthComputable)&#123; progress.innerHTML = event.loaded + &quot;/&quot; + event.total; &#125; &#125;; reader.onload = function()&#123; var html = &quot;&quot;; switch(type)&#123; case &quot;image&quot;: html = &quot;&lt;img src=\\&quot;&quot; + reader.result + &quot;\\&quot;&gt;&quot;; break; case &quot;text&quot;: html = reader.result; break; &#125; output.innerHTML = html; &#125;;&#125;);这个例子读取了表单字段中选择的文件，并将其内容显示在了页面中。如果文件有 MIMI 类型，表示文件是图像，因此在 load 事件中就把它保存为数据 URI，并在页面中将这幅图像显示出来。如果文件不是图像，则以字符串形式读取文件内容，然后如实在页面中显示读取到的内容。这里使用了progress 事件来跟踪读取了多少字节的数据，而 error 事件则用于监控发生的错误。 读取部分内容有时候，我们只想读取文件的一部分而不是全部内容。为此，File 对象还支持一个 slice()方法，这个方法在 Firefox 中的实现叫 mozSlice()，在 Chrome 中的实现叫 webkitSlice()，Safari 的 5.1 及之前版本不支持这个方法。slice()方法接收两个参数：起始字节及要读取的字节数。这个方法返回一个 Blob 的实例，Blob 是 File 类型的父类型。下面是一个通用的函数，可以在不同实现中使用 slice()方法： 1234567891011function blobSlice(blob, startByte, length)&#123; if (blob.slice)&#123; return blob.slice(startByte, length); &#125; else if (blob.webkitSlice)&#123; return blob.webkitSlice(startByte, length); &#125; else if (blob.mozSlice)&#123; return blob.mozSlice(startByte, length); &#125; else &#123; return null; &#125;&#125; 对象URL1234567891011121314对象 URL 也被称为 blob URL，指的是引用保存在 File 或 Blob 中数据的 URL。使用对象 URL 的好处是可以不必把文件内容读取到 JavaScript 中而直接使用文件内容。为此，只要在需要文件内容的地方提供对象 URL 即可。要创建对象 URL，可以使用 window.URL.createObjectURL()方法，并传入File 或 Blob 对象。这个方法在 Chrome 中的实现叫 window.webkitURL.createObjectURL()，因此可以通过如下函数来消除命名的差异：function createObjectURL(blob)&#123; if (window.URL)&#123; return window.URL.createObjectURL(blob); &#125; else if (window.webkitURL)&#123; return window.webkitURL.createObjectURL(blob); &#125; else &#123; return null; &#125;&#125; 读取拖放的文件围绕读取文件信息，结合使用 HTML5 拖放 API 和文件 API，能够创造出令人瞩目的用户界面：在页面上创建了自定义的放置目标之后，你可以从桌面上把文件拖放到该目标。与拖放一张图片或者一个链接类似，从桌面上把文件拖放到浏览器中也会触发 drop 事件。而且可以在 event.dataTransfer. files中读取到被放置的文件，当然此时它是一个 File 对象，与通过文件输入字段取得的 File 对象一样。下面这个例子会将放置到页面中自定义的放置目标中的文件信息显示出来 123456789101112131415161718192021var droptarget = document.getElementById( &quot;droptarget&quot;);function handleEvent(event)&#123; var info = &quot;&quot;, output = document.getElementById(&quot;output&quot;), files, i, len; EventUtil.preventDefault(event); if (event.type == &quot;drop&quot;)&#123; files = event.dataTransfer.files; i = 0; len = files.length; while (i &lt; len)&#123; info += files[i].name + &quot; (&quot; + files[i].type + &quot;, &quot; + files[i].size + &quot; bytes)&lt;br&gt;&quot;; i++; &#125; output.innerHTML = info; &#125;&#125;EventUtil.addHandler(droptarget, &quot;dragenter&quot;, handleEvent);EventUtil.addHandler(droptarget, &quot;dragover&quot;, handleEvent);EventUtil.addHandler(droptarget, &quot;drop&quot;, handleEvent); 使用XHR上传文件首先，要创建一个 FormData对象，通过它调用 append()方法并传入相应的 File 对象作为参数。然后，再把 FormData 对象传递给 XHR 的 send()方法，结果与通过表单上传一模一样。 12345678910111213141516171819202122232425262728293031var droptarget = document.getElementById(&quot;droptarget&quot;);function handleEvent(event)&#123; var info = &quot;&quot;, output = document.getElementById(&quot;output&quot;), data, xhr, files, i, len; EventUtil.preventDefault(event); if (event.type == &quot;drop&quot;)&#123; data = new FormData(); //读取拖放的文件 files = event.dataTransfer.files; i = 0; len = files.length; while (i &lt; len)&#123; data.append(&quot;file&quot; + i, files[i]); i++; &#125; xhr = new XMLHttpRequest(); xhr.open(&quot;post&quot;, &quot;FileAPIExample06Upload.php&quot;, true); xhr.onreadystatechange = function()&#123; if (xhr.readyState == 4)&#123; alert(xhr.responseText); &#125; &#125;; xhr.send(data); &#125;&#125;EventUtil.addHandler(droptarget, &quot;dragenter&quot;, handleEvent);EventUtil.addHandler(droptarget, &quot;dragover&quot;, handleEvent);EventUtil.addHandler(droptarget, &quot;drop&quot;, handleEvent);","categories":[],"tags":[{"name":"高程","slug":"高程","permalink":"https://vlwq.github.io/tags/%E9%AB%98%E7%A8%8B/"}]},{"title":"高程笔记8-cookie","slug":"2017高程/20170616","date":"2017-06-16T02:36:00.000Z","updated":"2017-07-16T04:25:18.699Z","comments":true,"path":"2017/06/16/2017高程/20170616/","link":"","permalink":"https://vlwq.github.io/2017/06/16/2017%E9%AB%98%E7%A8%8B/20170616/","excerpt":"高程笔记8","text":"高程笔记8 数据存储Cookie HTTP Cookie，通常直接叫做 cookie，最初是在客户端用于存储会话信息的。该标准要求服务器对任意 HTTP 请求发送 Set-Cookie HTTP 头作为响应的一部分，其中包含会话信息。例如，这种服务器响应的头可能如下：HTTP&#x2F;1.1 200 OKContent-type: text&#x2F;htmlSet-Cookie: name&#x3D;valueOther-header: other-header-value 由于 cookie 是存在客户端计算机上的，还加入了一些限制确保 cookie 不会被恶意使用，同时不会占据太多磁盘空间。每个域的 cookie 总数是有限的，不过浏览器之间各有不同。如下所示。  IE6 以及更低版本限制每个域名最多 20 个 cookie。 IE7 和之后版本每个域名最多 50 个。IE7 最初是支持每个域名最大 20 个 cookie，之后被微软的一个补丁所更新。 Firefox 限制每个域最多 50 个 cookie。 Opera 限制每个域最多 30 个 cookie。 Safari 和 Chrome 对于每个域的 cookie 数量限制没有硬性规定。 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455var CookieUtil = &#123; get: function (name)&#123; var cookieName = encodeURIComponent(name) + &quot;=&quot;, cookieStart = document.cookie.indexOf(cookieName), cookieValue = null; if (cookieStart &gt; -1)&#123; var cookieEnd = document.cookie.indexOf(&quot;;&quot;, cookieStart); if (cookieEnd == -1)&#123; cookieEnd = document.cookie.length; &#125; cookieValue = decodeURIComponent(document.cookie.substring(cookieStart + cookieName.length, cookieEnd)); &#125; return cookieValue; &#125;, set: function (name, value, expires, path, domain, secure) &#123; var cookieText = encodeURIComponent(name) + &quot;=&quot; + encodeURIComponent(value); if (expires instanceof Date) &#123; cookieText += &quot;; expires=&quot; + expires.toGMTString(); &#125; if (path) &#123; cookieText += &quot;; path=&quot; + path; &#125; if (domain) &#123; cookieText += &quot;; domain=&quot; + domain; &#125; if (secure) &#123; cookieText += &quot;; secure&quot;; &#125; document.cookie = cookieText; &#125;, unset: function (name, path, domain, secure)&#123; this.set(name, &quot;&quot;, new Date(0), path, domain, secure); &#125;&#125;;可以像下面这样使用上述方法。//设置 cookieCookieUtil.set(&quot;name&quot;, &quot;Nicholas&quot;);CookieUtil.set(&quot;book&quot;, &quot;Professional JavaScript&quot;);//读取 cookie 的值alert(CookieUtil.get(&quot;name&quot;)); //&quot;Nicholas&quot;alert(CookieUtil.get(&quot;book&quot;)); //&quot;Professional JavaScript&quot;//删除 cookieCookieUtil.unset(&quot;name&quot;);CookieUtil.unset(&quot;book&quot;);//设置 cookie，包括它的路径、域、失效日期CookieUtil.set(&quot;name&quot;, &quot;Nicholas&quot;, &quot;/books/projs/&quot;, &quot;www.wrox.com&quot;, new Date(&quot;January 1, 2010&quot;));//删除刚刚设置的 cookieCookieUtil.unset(&quot;name&quot;, &quot;/books/projs/&quot;, &quot;www.wrox.com&quot;);//设置安全的 cookieCookieUtil.set(&quot;name&quot;, &quot;Nicholas&quot;, null, null, null, true); Web存储机制 Web Storage 的两个主要目标是： 提供一种在 cookie 之外存储会话数据的途径； 提供一种存储大量可以跨会话存在的数据的机制。最初的 Web Storage 规范包含了两种对象的定义：sessionStorage 和 globalStorage。 Storage 类型 Storage 类型提供最大的存储空间（因浏览器而异）来存储名值对儿。Storage 的实例与其他对象类似，有如下方法。 clear()： 删除所有值；Firefox 中没有实现 。 getItem(name)：根据指定的名字 name 获取对应的值。 key(index)：获得 index 位置处的值的名字。 removeItem(name)：删除由 name 指定的名值对儿。 setItem(name, value)：为指定的 name 设置一个对应的值。 sessionStorage 对象 sessionStorage 对象存储特定于某个会话的数据，也就是该数据只保持到浏览器关闭。这个对象就像会话 cookie，也会在浏览器关闭后消失。存储在 sessionStorage 中的数据可以跨越页面刷新而存在，同时如果浏览器支持，浏览器崩溃并重启之后依然可用（Firefox 和 WebKit 都支持，IE 则不行）。 123456789101112131415161718192021//使用方法存储数据sessionStorage.setItem(&quot;name&quot;, &quot;Nicholas&quot;);//使用属性存储数据sessionStorage.book = &quot;Professional JavaScript&quot;;//使用方法读取数据var name = sessionStorage.getItem(&quot;name&quot;);//使用属性读取数据var book = sessionStorage.book;使用 for-in 循环来迭代 sessionStorage 中的值：for (var key in sessionStorage)&#123; var value = sessionStorage.getItem(key); alert(key + &quot;=&quot; + value);&#125;//使用 delete 删除一个值——在 WebKit 中无效delete sessionStorage.name;//使用方法删除一个值sessionStorage.removeItem(&quot;book&quot;); 3. globalStorage 对象12345678910111213//保存数据globalStorage[&quot;wrox.com&quot;].name = &quot;Nicholas&quot;;//获取数据var name = globalStorage[&quot;wrox.com&quot;].name;/*在这里，访问的是针对域名 wrox.com 的存储空间。globalStorage 对象不是 Storage 的实例，而具体的 globalStorage[&quot;wrox.com&quot;]才是。这个存储空间对于 wrox.com 及其所有子域都是可以访问的。可以像下面这样指定子域名。*///保存数据globalStorage[&quot;www.wrox.com&quot;].name = &quot;Nicholas&quot;;//获取数据var name = globalStorage[&quot;www.wrox.com&quot;].name; 4.localStorage 对象localStorage 对象在修订过的 HTML 5 规范中作为持久保存客户端数据的方案取代了globalStorage。与 globalStorage 不同，不能给 localStorage 指定任何访问规则；规则事先就设定好了。要访问同一个 localStorage 对象，页面必须来自同一个域名（子域名无效），使用同一种协议，在同一个端口上。这相当于 globalStorage[location.host]。 5.Storage限制 对于 localStorage 而言，大多数桌面浏览器会设置每个来源 5MB 的限制。Chrome 和 Safari 对每个来源的限制是 2.5MB。而 iOS 版 Safari 和 Android 版 WebKit 的限制也是 2.5MB。对 sessionStorage 的限制也是因浏览器而异。有的浏览器对 sessionStorage 的大小没有限制，但 Chrome、Safari、iOS 版 Safari 和 Android 版 WebKit 都有限制，也都是 2.5MB。IE8+和 Opera 对sessionStorage 的限制是 5MB。 IndexedDB 数据库IndexedDB 就是一个数据库，与 MySQL 或 Web SQL Database 等这些你以前可能用过的数据库类似。IndexedDB 最大的特色是使用对象保存数据，而不是使用表来保存数据。一个 IndexedDB 数据库，就是一组位于相同命名空间下的对象的集合。123456789var request, database;request = indexedDB.open(&quot;admin&quot;);request.onerror = function(event)&#123; alert(&quot;Something bad happened while trying to open: &quot; + event.target.errorCode);&#125;;request.onsuccess = function(event)&#123; database = event.target.result;&#125;; 最 佳 实 践 &#x2F; 代 码 风 格命名的一般规则如下所示。  变量名应为名词如 car 或 person。 函数名应该以动词开始，如 getName()。返回布尔类型值的函数一般以 is 开头，如isEnable()。 变量和函数都应使用合乎逻辑的名字，不要担心长度。长度问题可以通过后处理和压缩（本章后面会讲到）来缓解。 变量类型透明123456789101112131415161718//通过初始化指定变量类型var found = false; //布尔型var count = -1; //数字var name = &quot;&quot;; //字符串var person = null; //对象第二种方法是使用匈牙利标记法来指定变量类型。//用于指定数据类型的匈牙利标记法var bFound; //布尔型var iCount; //整数var sName; //字符串var oPerson; //对象//用于指定类型的类型注释var found /*:Boolean*/ = false;var count /*:int*/ = 10;var name /*:String*/ = &quot;Nicholas&quot;;var person /*:Object*/ = null; 解耦应用逻辑／事件处理程序12345678910111213141516171819function validateValue(value)&#123; value = 5 * parseInt(value); if (value &gt; 10)&#123; document.getElementById(&quot;error-msg&quot;).style.display = &quot;block&quot;; &#125;&#125;function handleKeyPress(event)&#123; event = EventUtil.getEvent(event); if (event.keyCode == 13)&#123; var target = EventUtil.getTarget(event); validateValue(target.value); &#125;&#125;以下是要牢记的应用和业务逻辑之间松散耦合的几条原则： 勿将 event 对象传给其他方法；只传来自 event 对象中所需的数据； 任何可以在应用层面的动作都应该可以在不执行任何事件处理程序的情况下进行； 任何事件处理程序都应该处理事件，然后将处理转交给应用逻辑。牢记这几条可以在任何代码中都获得极大的可维护性的改进，并且为进一步的测试和开发制造了很多可能。 避免全局量与尊重对象所有权密切相关的是尽可能避免全局变量和函数。这也关系到创建一个脚本执行的一致的和可维护的环境。最多创建一个全局变量，让其他对象和函数存在其中。请看以下例子： 1234567891011121314//两个全局量——避免！！var name = &quot;Nicholas&quot;;function sayName()&#123; alert(name);&#125;这段代码包含了两个全局量：变量 name 和函数 sayName()。其实可以创建一个包含两者的对象，如下例所示：//一个全局量——推荐var MyApplication = &#123; name: &quot;Nicholas&quot;, sayName: function()&#123; alert(this.name); &#125;&#125;; 避免与 null 进行比较1234567891011121314由于 JavaScript 不做任何自动的类型检查，所有它就成了开发人员的责任。因此，在 JavaScript 代码中其实很少进行类型检测。最常见的类型检测就是查看某个值是否为 null。但是，直接将值与 null比较是使用过度的，并且常常由于不充分的类型检查导致错误。看以下例子：function sortArray(values)&#123; if (values != null)&#123; //避免！ values.sort(comparator); &#125;&#125;比如数组，可以改造成function sortArray(values)&#123; if (values instanceof Array)&#123; //推荐 values.sort(comparator); &#125;&#125; 如果看到了与 null 比较的代码，尝试使用以下技术替换： 如果值应为一个引用类型，使用 instanceof 操作符检查其构造函数； 如果值应为一个基本类型，使用 typeof 检查其类型； 如果是希望对象包含某个特定的方法名，则使用 typeof 操作符确保指定名字的方法存在于对象上。代码中的 null 比较越少，就越容易确定代码的目的，并消除不必要的错误。 使用常量尽管 JavaScript 没有常量的正式概念，但它还是很有用的。这种将数据从应用逻辑分离出来的思想，可以在不冒引入错误的风险的同时，就改变数据。请看以下例子： 123456789101112131415161718function validate(value)&#123; if (!value)&#123; alert(&quot;Invalid value!&quot;); location.href = &quot;/errors/invalid.php&quot;; &#125;&#125;改成：var Constants = &#123; INVALID_VALUE_MSG: &quot;Invalid value!&quot;, INVALID_VALUE_URL: &quot;/errors/invalid.php&quot;&#125;;function validate(value)&#123; if (!value)&#123; alert(Constants.INVALID_VALUE_MSG); location.href = Constants.INVALID_VALUE_URL; &#125;&#125; 关键在于将数据和使用它的逻辑进行分离。要注意的值的类型如下所示。 重复值——任何在多处用到的值都应抽取为一个常量。这就限制了当一个值变了而另一个没变的时候会造成的错误。这也包含了 CSS 类名。 用户界面字符串 —— 任何用于显示给用户的字符串，都应被抽取出来以方便国际化。 URLs ——在 Web 应用中，资源位置很容易变更，所以推荐用一个公共地方存放所有的 URL。 任意可能会更改的值 —— 每当你在用到字面量值的时候，你都要问一下自己这个值在未来是不是会变化。如果答案是“是”，那么这个值就应该被提取出来作为一个常量。 作用域1.避免全局查找可能优化脚本性能最重要的就是注意全局查找。使用全局变量和函数肯定要比局部的开销更大，因为要涉及作用域链上的查找。请看以下函数： 123456789101112131415161718192021function updateUI()&#123; var imgs = document.getElementsByTagName(&quot;img&quot;); for (var i=0, len=imgs.length; i &lt; len; i++)&#123; imgs[i].title = document.title + &quot; image &quot; + i; &#125; var msg = document.getElementById(&quot;msg&quot;); msg.innerHTML = &quot;Update complete.&quot;;&#125;该函数可能看上去完全正常，但是它包含了三个对于全局 document 对象的引用。如果在页面上有多个图片，那么 for 循环中的 document 引用就会被执行多次甚至上百次，每次都会要进行作用域链查找。通过创建一个指向 document 对象的局部变量，就可以通过限制一次全局查找来改进这个函数的性能：function updateUI()&#123; var doc = document; var imgs = doc.getElementsByTagName(&quot;img&quot;); for (var i=0, len=imgs.length; i &lt; len; i++)&#123; imgs[i].title = doc.title + &quot; image &quot; + i; &#125; var msg = doc.getElementById(&quot;msg&quot;); msg.innerHTML = &quot;Update complete.&quot;;&#125; 1. 多个变量声明 有个地方很多开发人员都容易创建很多语句，那就是多个变量的声明。很容易看到代码中由多个var 语句来声明多个变量，如下所示：&#x2F;&#x2F;4 个语句——很浪费var count &#x3D; 5;var color &#x3D; “blue”;var values &#x3D; [1,2,3];var now &#x3D; new Date();在强类型语言中，不同的数据类型的变量必须在不同的语句中声明。然而，在 JavaScript 中所有的变量都可以使用单个 var 语句来声明。前面的代码可以如下重写：&#x2F;&#x2F;一个语句var count &#x3D; 5, color &#x3D; “blue”, values &#x3D; [1,2,3], now &#x3D; new Date();","categories":[],"tags":[{"name":"高程","slug":"高程","permalink":"https://vlwq.github.io/tags/%E9%AB%98%E7%A8%8B/"}]},{"title":"高程笔记7-JSON和ajax","slug":"2017高程/20170615","date":"2017-06-15T02:36:00.000Z","updated":"2017-07-16T04:23:32.286Z","comments":true,"path":"2017/06/15/2017高程/20170615/","link":"","permalink":"https://vlwq.github.io/2017/06/15/2017%E9%AB%98%E7%A8%8B/20170615/","excerpt":"高程笔记7","text":"高程笔记7 语法 JSON 的语法可以表示以下三种类型的值。 简单值：使用与 JavaScript 相同的语法，可以在 JSON 中表示字符串、数值、布尔值和 null。但 JSON 不支持 JavaScript 中的特殊值 undefined。 对象：对象作为一种复杂数据类型，表示的是一组无序的键值对儿。而每个键值对儿中的值可以是简单值，也可以是复杂数据类型的值。 数组：数组也是一种复杂数据类型，表示一组有序的值的列表，可以通过数值索引来访问其中的值。数组的值也可以是任意类型——简单值、对象或数组。JSON 不支持变量、函数或对象实例，它就是一种表示结构化数据的格式，虽然与 JavaScript 中表示数据的某些语法相同，但它并不局限于 JavaScript 的范畴。 对象12345678910111213141516JSON 中的对象与 JavaScript 字面量稍微有一些不同。下面是一个 JavaScript 中的对象字面量：var person = &#123; name: &quot;Nicholas&quot;, age: 29&#125;;这虽然是开发人员在 JavaScript 中创建对象字面量的标准方式，但 JSON 中的对象要求给属性加引号。实际上，在 JavaScript 中，前面的对象字面量完全可以写成下面这样：var object = &#123; &quot;name&quot;: &quot;Nicholas&quot;, &quot;age&quot;: 29&#125;;JSON 表示上述对象的方式如下：&#123; &quot;name&quot;: &quot;Nicholas&quot;, &quot;age&quot;: 29&#125; JSON 对象有两个方法：stringify()和 parse()。在最简单的情况下，这两个方法分别用于把JavaScript 对象序列化为 JSON 字符串和把 JSON 字符串解析为原生 JavaScript 值。例如： 1234567891011121314151617181920212223242526272829var book = &#123; title: &quot;Professional JavaScript&quot;, authors: [ &quot;Nicholas C. Zakas&quot; ], edition: 3, year: 2011 &#125;;var jsonText = JSON.stringify(book);实际上，JSON.stringify()除了要序列化的 JavaScript 对象外，还可以接收另外两个参数，这两个参数用于指定以不同的方式序列化 JavaScript 对象。第一个参数是个过滤器，可以是一个数组，也可以是一个函数；第二个参数是一个选项，表示是否在 JSON 字符串中保留缩进。单独或组合使用这两个参数，可以更全面深入地控制 JSON 的序列化2. 字符串缩进JSON.stringify()方法的第三个参数用于控制结果中的缩进和空白符。如果这个参数是一个数值，那它表示的是每个级别缩进的空格数。例如，要在每个级别缩进 4 个空格，可以这样写代码：var book = &#123; &quot;title&quot;: &quot;Professional JavaScript&quot;, &quot;authors&quot;: [ &quot;Nicholas C. Zakas&quot; ], edition: 3, year: 2011 &#125;;var jsonText = JSON.stringify(book, null, 4); 解析选项123456789101112131415161718var book = &#123; &quot;title&quot;: &quot;Professional JavaScript&quot;, &quot;authors&quot;: [ &quot;Nicholas C. Zakas&quot; ], edition: 3, year: 2011, releaseDate: new Date(2011, 11, 1) &#125;;var jsonText = JSON.stringify(book);var bookCopy = JSON.parse(jsonText, function(key, value)&#123; if (key == &quot;releaseDate&quot;)&#123; return new Date(value); &#125; else &#123; return value; &#125; &#125;);alert(bookCopy.releaseDate.getFullYear()); ajaxXHR的用法 在使用 XHR 对象时，要调用的第一个方法是 open()，它接受 3 个参数：要发送的请求的类型（”get”、”post”等）、请求的 URL 和表示是否异步发送请求的布尔值。下面就是调用这个方法的例子。xhr.open(“get”, “example.php”, false);这行代码会启动一个针对 example.php 的 GET 请求。有关这行代码，需要说明两点：一是 URL相对于执行代码的当前页面（当然也可以使用绝对路径）；二是调用 open()方法并不会真正发送请求，而只是启动一个请求以备发送。 123要发送特定的请求，必须像下面这样调用 send()方法：xhr.open(&quot;get&quot;, &quot;example.txt&quot;, false);xhr.send(null); 在收到响应后，响应的数据会自动填充 XHR 对象的属性，相关的属性简介如下。  responseText：作为响应主体被返回的文本。 responseXML：如果响应的内容类型是”text&#x2F;xml”或”application&#x2F;xml”，这个属性中将保存包含着响应数据的 XML DOM 文档。 status：响应的 HTTP 状态。 statusText：HTTP 状态的说明 1234567xhr.open(&quot;get&quot;, &quot;example.txt&quot;, false);xhr.send(null);if ((xhr.status &gt;= 200 &amp;&amp; xhr.status &lt; 300) || xhr.status == 304)&#123; alert(xhr.responseText);&#125; else &#123; alert(&quot;Request was unsuccessful: &quot; + xhr.status);&#125; 但多数情况下，我们还是要发送异步请求，才能让JavaScript 继续执行而不必等待响应。此时，可以检测 XHR 对象的 readyState 属性，该属性表示请求&#x2F;响应过程的当前活动阶段。这个属性可取的值如下。  0：未初始化。尚未调用 open()方法。 1：启动。已经调用 open()方法，但尚未调用 send()方法。 2：发送。已经调用 send()方法，但尚未接收到响应。 3：接收。已经接收到部分响应数据。 4：完成。已经接收到全部响应数据，而且已经可以在客户端使用了。 123456789101112var xhr = createXHR();xhr.onreadystatechange = function()&#123; if (xhr.readyState == 4)&#123; if ((xhr.status &gt;= 200 &amp;&amp; xhr.status &lt; 300) || xhr.status == 304)&#123; alert(xhr.responseText); &#125; else &#123; alert(&quot;Request was unsuccessful: &quot; + xhr.status); &#125; &#125;&#125;;xhr.open(&quot;get&quot;, &quot;example.txt&quot;, true);xhr.send(null); HTTP头部信息 默认情况下，在发送 XHR 请求的同时，还会发送下列头部信息。 Accept：浏览器能够处理的内容类型。 Accept-Charset：浏览器能够显示的字符集。 Accept-Encoding：浏览器能够处理的压缩编码。 Accept-Language：浏览器当前设置的语言。 Connection：浏览器与服务器之间连接的类型。 Cookie：当前页面设置的任何 Cookie。 Host：发出请求的页面所在的域 。 Referer：发出请求的页面的 URI。注意，HTTP 规范将这个头部字段拼写错了，而为保证与规范一致，也只能将错就错了。（这个英文单词的正确拼法应该是 referrer。） User-Agent：浏览器的用户代理字符串 虽然不同浏览器实际发送的头部信息会有所不同，但以上列出的基本上是所有浏览器都会发送的。使用 setRequestHeader()方法可以设置自定义的请求头部信息。这个方法接受两个参数：头部字段的名称和头部字段的值。要成功发送请求头部信息，必须在调用 open()方法之后且调用 send()方法之前调用 setRequestHeader() GET请求1234567891011使用 GET 请求经常会发生的一个错误，就是查询字符串的格式有问题。查询字符串中每个参数的名称和值都必须使用 encodeURIComponent()进行编码，然后才能放到 URL 的末尾；而且所有名-值对儿都必须由和号（&amp;）分隔，如下面的例子所示。xhr.open(&quot;get&quot;, &quot;example.php?name1=value1&amp;name2=value2&quot;, true);下面这个函数可以辅助向现有 URL 的末尾添加查询字符串参数：function addURLParam(url, name, value) &#123; url += (url.indexOf(&quot;?&quot;) == -1 ? &quot;?&quot; : &quot;&amp;&quot;); url += encodeURIComponent(name) + &quot;=&quot; + encodeURIComponent(value); return url;&#125; post请求1234xhr.open(&quot;post&quot;, &quot;example.php&quot;, true);发送 POST 请求的第二步就是向 send()方法中传入某些数据。由于 XHR 最初的设计主要是为了处理 XML，因此可以在此传入 XML DOM 文档，传入的文档经序列化之后将作为请求主体被提交到服务器。当然，也可以在此传入任何想发送到服务器的字符串。 XMLHttpRequest 2 级 现代 Web 应用中频繁使用的一项功能就是表单数据的序列化，XMLHttpRequest 2 级为此定义了FormData 类型。FormData 为序列化表单以及创建与表单格式相同的数据（用于通过 XHR 传输）提供了便利。下面的代码创建了一个 FormData 对象，并向其中添加了一些数据。var data &#x3D; new FormData();data.append(“name”, “Nicholas”);这个 append()方法接收两个参数：键和值，分别对应表单字段的名字和字段中包含的值。可以像这样添加任意多个键值对儿。而通过向 FormData 构造函数中传入表单元素，也可以用表单元素的数据预先向其中填入键值对儿：var data &#x3D; new FormData(document.forms[0]); 超时设定12345678910111213141516171819202122var xhr = createXHR();xhr.onreadystatechange = function()&#123; if (xhr.readyState == 4)&#123; try &#123; if ((xhr.status &gt;= 200 &amp;&amp; xhr.status &lt; 300) || xhr.status == 304)&#123; alert(xhr.responseText); &#125; else &#123; alert(&quot;Request was unsuccessful: &quot; + xhr.status); &#125; &#125; catch (ex)&#123; //假设由 ontimeout 事件处理程序处理 &#125; &#125;&#125;;xhr.open(&quot;get&quot;, &quot;timeout.php&quot;, true);xhr.timeout = 1000; //将超时设置为 1 秒钟（仅适用于 IE8+）xhr.ontimeout = function()&#123; alert(&quot;Request did not return in a second.&quot;);&#125;;xhr.send(null);在写作本书时，IE 8+仍然是唯一支持超时设定的浏览器。 overrideMimeType()方法1234567比如，服务器返回的 MIME 类型是 text/plain，但数据中实际包含的是 XML。根据 MIME 类型，即使数据是 XML，responseXML 属性中仍然是 null。通过调用 overrideMimeType()方法，可以保证把响应当作 XML 而非纯文本来处理。var xhr = createXHR();xhr.open(&quot;get&quot;, &quot;text.php&quot;, true);xhr.overrideMimeType(&quot;text/xml&quot;);xhr.send(null); progress事件 Mozilla 对 XHR 的另一个革新是添加了 progress 事件，这个事件会在浏览器接收新数据期间周期性地触发。而 onprogress 事件处理程序会接收到一个 event 对象，其 target 属性是 XHR 对象，但包含着三个额外的属性：lengthComputable、position 和 totalSize。其中，lengthComputable是一个表示进度信息是否可用的布尔值，position 表示已经接收的字节数，totalSize 表示根据Content-Length 响应头部确定的预期字节数。有了这些信息，我们就可以为用户创建一个进度指示器了。下面展示了为用户创建进度指示器的一个示例。 123456789101112131415161718var xhr = createXHR();xhr.onload = function(event)&#123; if ((xhr.status &gt;= 200 &amp;&amp; xhr.status &lt; 300) || xhr.status == 304)&#123; alert(xhr.responseText); &#125; else &#123; alert(&quot;Request was unsuccessful: &quot; + xhr.status); &#125;&#125;;xhr.onprogress = function(event)&#123; var divStatus = document.getElementById(&quot;status&quot;); if (event.lengthComputable)&#123; divStatus.innerHTML = &quot;Received &quot; + event.position + &quot; of &quot; + event.totalSize +&quot; bytes&quot;; &#125;&#125;;xhr.open(&quot;get&quot;, &quot;altevents.php&quot;, true);xhr.send(null); 跨域 如果服务器认为这个请求可以接受，就在 Access-Control-Allow-Origin 头部中回发相同的源信息（如果是公共资源，可以回发”*”）。例如：Access-Control-Allow-Origin: http://www.nczonline.net如果没有这个头部，或者有这个头部但源信息不匹配，浏览器就会驳回请求。正常情况下，浏览器会处理请求。注意，请求和响应都不包含 cookie 信息。 123456789101112131415Firefox 3.5+、Safari 4+、Chrome、iOS 版 Safari 和 Android 平台中的 WebKit 都通过 XMLHttpRequest对象实现了对 CORS 的原生支持。在尝试打开不同来源的资源时，无需额外编写代码就可以触发这个行为。要请求位于另一个域中的资源，使用标准的 XHR 对象并在 open()方法中传入绝对 URL 即可，例如：var xhr = createXHR();xhr.onreadystatechange = function()&#123; if (xhr.readyState == 4)&#123; if ((xhr.status &gt;= 200 &amp;&amp; xhr.status &lt; 300) || xhr.status == 304)&#123; alert(xhr.responseText); &#125; else &#123; alert(&quot;Request was unsuccessful: &quot; + xhr.status); &#125; &#125;&#125;;xhr.open(&quot;get&quot;, &quot;http://www.somewhere-else.com/page/&quot;, true);xhr.send(null); 跨浏览器的CORS123456789101112131415161718function createCORSRequest(method, url)&#123; var xhr = new XMLHttpRequest(); if (&quot;withCredentials&quot; in xhr)&#123; xhr.open(method, url, true); &#125; else if (typeof XDomainRequest != &quot;undefined&quot;)&#123; vxhr = new XDomainRequest(); xhr.open(method, url); &#125; else &#123; xhr = null; &#125; return xhr;&#125;var request = createCORSRequest(&quot;get&quot;, &quot;http://www.somewhere-else.com/page/&quot;);if (request)&#123; request.onload = function()&#123; //对 request.responseText 进行处理 &#125;; request.send(); Firefox、Safari 和 Chrome 中的 XMLHttpRequest 对象与 IE 中的 XDomainRequest 对象类似，都提供了够用的接口，因此以上模式还是相当有用的。这两个对象共同的属性&#x2F;方法如下。 abort()：用于停止正在进行的请求。 onerror：用于替代 onreadystatechange 检测错误。 onload：用于替代 onreadystatechange 检测成功。 responseText：用于取得响应内容。 send()：用于发送请求。以上成员都包含在 createCORSRequest()函数返回的对象中，在所有浏览器中都能正常使用。 JSONP JSONP 是 JSON with padding（填充式 JSON 或参数式 JSON）的简写，是应用 JSON 的一种新方法，在后来的 Web 服务中非常流行。JSONP 看起来与 JSON 差不多，只不过是被包含在函数调用中的 JSON，就像下面这样。callback({ “name”: “Nicholas” });JSONP 由两部分组成：回调函数和数据。回调函数是当响应到来时应该在页面中调用的函数。回调函数的名字一般是在请求中指定的。而数据就是传入回调函数中的JSON数据。下面是一个典型的JSONP请求。http://freegeoip.net/json/?callback=handleResponse Web Sockets 要说最令人津津乐道的新浏览器 API，就得数 Web Sockets 了。Web Sockets 的目标是在一个单独的持久连接上提供全双工、双向通信。在 JavaScript 中创建了 Web Socket 之后，会有一个 HTTP 请求发送到浏览器以发起连接。在取得服务器响应后，建立的连接会使用 HTTP 升级从 HTTP 协议交换为 WebSocket 协议。也就是说，使用标准的 HTTP 服务器无法实现 Web Sockets，只有支持这种协议的专门服务器才能正常工作。由于 Web Sockets 使用了自定义的协议，所以 URL 模式也略有不同。未加密的连接不再是 http:&#x2F;&#x2F;，而是 ws:&#x2F;&#x2F;；加密的连接也不是 https:&#x2F;&#x2F;，而是 wss:&#x2F;&#x2F;。在使用 Web Socket URL 时，必须带着这个模式，因为将来还有可能支持其他模式。 12345678910111213141516171819202122232425262728293031323334353637383940414243444546471. Web Sockets API要创建 Web Socket，先实例一个 WebSocket 对象并传入要连接的 URL：var socket = new WebSocket(&quot;ws://www.example.com/server.php&quot;);注意，必须给 WebSocket 构造函数传入绝对 URL。同源策略对 Web Sockets 不适用，因此可以通过它打开到任何站点的连接。至于是否会与某个域中的页面通信，则完全取决于服务器。（通过握手信息就可以知道请求来自何方。）实例化了 WebSocket 对象后，浏览器就会马上尝试创建连接。与 XHR 类似，WebSocket 也有一个表示当前状态的 readyState 属性。不过，这个属性的值与 XHR 并不相同，而是如下所示。 WebSocket.OPENING (0)：正在建立连接。 WebSocket.OPEN (1)：已经建立连接。 WebSocket.CLOSING (2)：正在关闭连接。 WebSocket.CLOSE (3)：已经关闭连接。WebSocket 没有 readystatechange 事件；不过，它有其他事件，对应着不同的状态。readyState的值永远从 0 开始。要关闭 Web Socket 连接，可以在任何时候调用 close()方法。socket.close();调用了 close()之后，readyState 的值立即变为 2（正在关闭），而在关闭连接后就会变成 3。2. 发送和接收数据因为 Web Sockets 只能通过连接发送纯文本数据，所以对于复杂的数据结构，在通过连接发送之前，必须进行序列化。下面的例子展示了先将数据序列化为一个 JSON 字符串，然后再发送到服务器：var message = &#123; time: new Date(), text: &quot;Hello world!&quot;, clientId: &quot;asdfp8734rew&quot;&#125;;socket.send(JSON.stringify(message));接下来，服务器要读取其中的数据，就要解析接收到的 JSON 字符串。当服务器向客户端发来消息时，WebSocket 对象就会触发 message 事件。这个 message 事件与其他传递消息的协议类似，也是把返回的数据保存在 event.data 属性中。socket.onmessage = function(event)&#123; var data = event.data; //处理数据&#125;;与通过 send()发送到服务器的数据一样，event.data 中返回的数据也是字符串。如果你想得到其他格式的数据，必须手工解析这些数据。3.其他事件WebSocket 对象还有其他三个事件，在连接生命周期的不同阶段触发。 open：在成功建立连接时触发。 error：在发生错误时触发，连接不能持续。 close：在连接关闭时触发 总结 Ajax 是无需刷新页面就能够从服务器取得数据的一种方法。关于 Ajax，可以从以下几方面来总结一下。 负责 Ajax 运作的核心对象是 XMLHttpRequest（XHR）对象。 XHR 对象由微软最早在 IE5 中引入，用于通过 JavaScript 从服务器取得 XML 数据。 在此之后，Firefox、Safari、Chrome 和 Opera 都实现了相同的特性，使 XHR 成为了 Web 的一个事实标准。 虽然实现之间存在差异，但 XHR 对象的基本用法在不同浏览器间还是相对规范的，因此可以放心地用在 Web 开发当中。同源策略是对 XHR 的一个主要约束，它为通信设置了“相同的域、相同的端口、相同的协议”这一限制。试图访问上述限制之外的资源，都会引发安全错误，除非采用被认可的跨域解决方案。这个解决方案叫做 CORS（Cross-Origin Resource Sharing，跨源资源共享），IE8 通过 XDomainRequest 对象支持CORS，其他浏览器通过 XHR 对象原生支持 CORS。图像 Ping 和 JSONP 是另外两种跨域通信的技术，但不如 CORS 稳妥。Comet 是对 Ajax 的进一步扩展，让服务器几乎能够实时地向客户端推送数据。实现 Comet 的手段主要有两个：长轮询和 HTTP 流。所有浏览器都支持长轮询，而只有部分浏览器原生支持 HTTP 流。SSE（Server-Sent Events，服务器发送事件）是一种实现 Comet 交互的浏览器 API，既支持长轮询，也支持HTTP 流。Web Sockets 是一种与服务器进行全双工、双向通信的信道。与其他方案不同，Web Sockets 不使用HTTP 协议，而使用一种自定义的协议。这种协议专门为快速传输小数据设计。虽然要求使用不同的Web 服务器，但却具有速度上的优势。各方面对 Ajax 和 Comet 的鼓吹吸引了越来越多的开发人员学习 JavaScript，人们对 Web 开发的关注也再度升温。与 Ajax 有关的概念都还相对比较新，这些概念会随着时间推移继续发展。","categories":[],"tags":[{"name":"高程","slug":"高程","permalink":"https://vlwq.github.io/tags/%E9%AB%98%E7%A8%8B/"}]},{"title":"高程笔记6-表单知识","slug":"2017高程/20170614","date":"2017-06-14T02:36:00.000Z","updated":"2017-07-16T04:22:22.325Z","comments":true,"path":"2017/06/14/2017高程/20170614/","link":"","permalink":"https://vlwq.github.io/2017/06/14/2017%E9%AB%98%E7%A8%8B/20170614/","excerpt":"高程笔记6","text":"高程笔记6 表单的基础知识在 HTML 中，表单是由元素来表示的，而在 JavaScript 中，表单对应的则是 HTMLFormElement类型。HTMLFormElement 继承了 HTMLElement，因而与其他 HTML 元素具有相同的默认属性。不过，HTMLFormElement 也有它自己下列独有的属性和方法。  acceptCharset：服务器能够处理的字符集；等价于 HTML 中的 accept-charset 特性。 action：接受请求的 URL；等价于 HTML 中的 action 特性。 elements：表单中所有控件的集合（HTMLCollection）。 enctype：请求的编码类型；等价于 HTML 中的 enctype 特性。 length：表单中控件的数量。 method：要发送的 HTTP 请求类型，通常是”get”或”post”；等价于 HTML 的 method 特性。 name：表单的名称；等价于 HTML 的 name 特性。 reset()：将所有表单域重置为默认值。 submit()：提交表单。 target：用于发送请求和接收响应的窗口名称；等价于 HTML 的 target 特性 12345678910111213提交表单&lt;!-- 通用提交按钮 --&gt;&lt;input type=&quot;submit&quot; value=&quot;Submit Form&quot;&gt;&lt;!-- 自定义提交按钮 --&gt;&lt;button type=&quot;submit&quot;&gt;Submit Form&lt;/button&gt;&lt;!-- 图像按钮 --&gt;&lt;input type=&quot;image&quot; src=&quot;graphic.gif&quot;&gt;&lt;!-- 通用重置按钮 --&gt;&lt;input type=&quot;reset&quot; value=&quot;Reset Form&quot;&gt;&lt;!-- 自定义重置按钮 --&gt;&lt;button type=&quot;reset&quot;&gt;Reset Form&lt;/button&gt; 表单共有的表单字段属性除了元素之外，所有表单字段都拥有相同的一组属性。由于类型可以表示多种表单字段，因此有些属性只适用于某些字段，但还有一些属性是所有字段所共有的。表单字段共有的属性如下。  disabled：布尔值，表示当前字段是否被禁用。 form：指向当前字段所属表单的指针；只读。 name：当前字段的名称。 readOnly：布尔值，表示当前字段是否只读。 tabIndex：表示当前字段的切换（tab）序号。 type：当前字段的类型，如”checkbox”、”radio”，等等。 value：当前字段将被提交给服务器的值。对文件字段来说，这个属性是只读的，包含着文件在计算机中的路径。 123456789//避免多次提交表单EventUtil.addHandler(form, &quot;submit&quot;, function(event)&#123; event = EventUtil.getEvent(event); var target = EventUtil.getTarget(event); //取得提交按钮 var btn = target.elements[&quot;submit-btn&quot;]; //禁用它 btn.disabled = true;&#125;); 除了之外，所有表单字段都有 type 属性。对于元素，这个值等于 HTML 特性 type 的值。对于其他元素，这个 type 属性的值如下表所列.此外，和元素的 type 属性是可以动态修改的，而元素的 type 属性则是只读的。 2. 共有的表单字段方法每个表单字段都有两个方法：focus()和 blur()。其中，focus()方法用于将浏览器的焦点设置到表单字段，即激活表单字段，使其可以响应键盘事件 3. 共有的表单字段事件除了支持鼠标、键盘、更改和 HTML 事件之外，所有表单字段都支持下列 3 个事件。 1234 blur：当前字段失去焦点时触发。 change：对于&lt;input&gt;和&lt;textarea&gt;元素，在它们失去焦点且 value 值改变时触发；对于&lt;select&gt;元素，在其选项改变时触发 focus：当前字段获得焦点时触发。 文本框脚本1234567&lt;textarea&gt;元素则始终会呈现为一个多行文本框。要指定文本框的大小，可以使用 rows和 cols 特性。其中，rows 特性指定的是文本框的字符行数，而 cols 特性指定的是文本框的字符列数（类似于&lt;inpu&gt;元素的 size 特性）。与&lt;input&gt;元素不同，&lt;textarea&gt;的初始值必须要放在&lt;textarea&gt;和&lt;/textarea&gt;之间，如下面的例子所示。&lt;textarea rows=&quot;25&quot; cols=&quot;5&quot;&gt;initial value&lt;/textarea&gt;注意： 在处理文本框的值时，最好不要使用 DOM 方法。 过滤输入123456789例如，下列代码只允许用户输入数值。EventUtil.addHandler(textbox, &quot;keypress&quot;, function(event)&#123; event = EventUtil.getEvent(event); var target = EventUtil.getTarget(event); var charCode = EventUtil.getCharCode(event); if (!/\\d/.test(String.fromCharCode(charCode)))&#123; EventUtil.preventDefault(event); &#125;&#125;); 自动切换焦点1234567891011121314151617181920212223242526272829&lt;input type=&quot;text&quot; name=&quot;tel1&quot; id=&quot;txtTel1&quot; maxlength=&quot;3&quot;&gt;&lt;input type=&quot;text&quot; name=&quot;tel2&quot; id=&quot;txtTel2&quot; maxlength=&quot;3&quot;&gt;&lt;input type=&quot;text&quot; name=&quot;tel3&quot; id=&quot;txtTel3&quot; maxlength=&quot;4&quot;&gt;(function()&#123; function tabForward(event)&#123; event = EventUtil.getEvent(event); var target = EventUtil.getTarget(event); if (target.value.length == target.maxLength)&#123; var form = target.form; for (var i=0, len=form.elements.length; i &lt; len; i++) &#123; if (form.elements[i] == target) &#123; if (form.elements[i+1])&#123; form.elements[i+1].focus(); &#125; return; &#125; &#125; &#125; &#125; var textbox1 = document.getElementById(&quot;txtTel1&quot;); var textbox2 = document.getElementById(&quot;txtTel2&quot;); var textbox3 = document.getElementById(&quot;txtTel3&quot;); EventUtil.addHandler(textbox1, &quot;keyup&quot;, tabForward); EventUtil.addHandler(textbox2, &quot;keyup&quot;, tabForward); EventUtil.addHandler(textbox3, &quot;keyup&quot;, tabForward);&#125;)(); HTML5 约束验证API1234567891011121314151617181920212223242526272829303132333435361. 必填字段第一种情况是在表单字段中指定了 required 属性，如下面的例子所示：&lt;input type=&quot;text&quot; name=&quot;username&quot; required&gt;2. 其他输入类型HTML5 为&lt;input&gt;元素的 type 属性又增加了几个值。这些新的类型不仅能反映数据类型的信息，而且还能提供一些默认的验证功能。其中，&quot;email&quot;和&quot;url&quot;是两个得到支持最多的类型，各浏览器也都为它们增加了定制的验证机制。例如：&lt;input type=&quot;email&quot; name =&quot;email&quot;&gt;&lt;input type=&quot;url&quot; name=&quot;homepage&quot;&gt;3. 数值范围除了&quot;email&quot;和&quot;url&quot;，HTML5还定义了另外几个输入元素。这几个元素都要求填写某种基于数字的值：&quot;number&quot;、&quot;range&quot;、&quot;datetime&quot;、&quot;datetime-local&quot;、&quot;date&quot;、&quot;month&quot;、&quot;week&quot;，还有&quot;time&quot;。浏览器对这几个类型的支持情况并不好，对所有这些数值类型的输入元素，可以指定 min 属性（最小的可能值）、max 属性（最大的可能值）和 step 属性（从 min 到 max 的两个刻度间的差值）。例如，想让用户只能输入 0 到 100 的值，而且这个值必须是 5 的倍数，可以这样写代码：&lt;input type=&quot;number&quot; min=&quot;0&quot; max=&quot;100&quot; step=&quot;5&quot; name=&quot;count&quot;&gt;4. 输入模式HTML5 为文本字段新增了 pattern 属性。这个属性的值是一个正则表达式，用于匹配文本框中的值。例如，如果只想允许在文本字段中输入数值，可以像下面的代码一样应用约束：&lt;input type=&quot;text&quot; pattern=&quot;\\d+&quot; name=&quot;count&quot;&gt;5. 检测有效性使用 checkValidity()方法可以检测表单中的某个字段是否有效。所有表单字段都有个方法，如果字段的值有效，这个方法返回 true，否则返回 false。字段的值是否有效的判断依据是本节前面介绍过的那些约束。6. 禁用验证通过设置 novalidate 属性，可以告诉表单不进行验证。&lt;form method=&quot;post&quot; action=&quot;signup.php&quot; novalidate&gt; &lt;!--这里插入表单元素--&gt;&lt;/form&gt; 选择框脚本选择框是通过和元素创建的。为了方便与这个控件交互，除了所有表单字段共有的属性和方法外，HTMLSelectElement 类型还提供了下列属性和方法。 12345678910111213141516171819202122232425 add(newOption, relOption)：向控件中插入新&lt;option&gt;元素，其位置在相关项（relOption）之前。 multiple：布尔值，表示是否允许多项选择；等价于 HTML 中的 multiple 特性。 options：控件中所有&lt;option&gt;元素的 HTMLCollection。 remove(index)：移除给定位置的选项。 selectedIndex：基于 0 的选中项的索引，如果没有选中项，则值为-1。对于支持多选的控件，只保存选中项中第一项的索引。 size：选择框中可见的行数；等价于 HTML 中的 size 特性。选择框的 type 属性不是&quot;select-one&quot;，就是&quot;select-multiple&quot;，这取决于 HTML 代码中有没有 multiple 特性。选择框的 value 属性由当前选中项决定，相应规则如下。 如果没有选中的项，则选择框的 value 属性保存空字符串。 如果有一个选中项，而且该项的 value 特性已经在 HTML 中指定，则选择框的 value 属性等于选中项的 value 特性。即使 value 特性的值是空字符串，也同样遵循此条规则。 如果有一个选中项，但该项的 value 特性在 HTML 中未指定，则选择框的 value 属性等于该项的文本。 如果有多个选中项，则选择框的 value 属性将依据前两条规则取得第一个选中项的值。以下面的选择框为例：&lt;select name=&quot;location&quot; id=&quot;selLocation&quot;&gt; &lt;option value=&quot;Sunnyvale, CA&quot;&gt;Sunnyvale&lt;/option&gt; &lt;option value=&quot;Los Angeles, CA&quot;&gt;Los Angeles&lt;/option&gt; &lt;option value=&quot;Mountain View, CA&quot;&gt;Mountain View&lt;/option&gt; &lt;option value=&quot;&quot;&gt;China&lt;/option&gt; &lt;option&gt;Australia&lt;/option&gt;&lt;/select&gt; 在 DOM 中，每个&lt;option&gt;元素都有一个 HTMLOptionElement 对象表示。为便于访问数据，HTMLOptionElement 对象添加了下列属性： 123456789 index：当前选项在 options 集合中的索引。 label：当前选项的标签；等价于 HTML 中的 label 特性。 selected：布尔值，表示当前选项是否被选中。将这个属性设置为 true 可以选中当前选项。 text：选项的文本。 value：选项的值（等价于 HTML 中的 value 特性）//推荐var text = selectbox.options[0].text; //选项的文本var value = selectbox.options[0].value; //选项的值 移动和重排选项 123var selectbox1 = document.getElementById(&quot;selLocations1&quot;);var selectbox2 = document.getElementById(&quot;selLocations2&quot;);selectbox2.appendChild(selectbox1.options[0]); 表单序列化12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758function serialize(form)&#123; var parts = [], field = null, i, len, j, optLen, option, optValue; for (i=0, len=form.elements.length; i &lt; len; i++)&#123; field = form.elements[i]; switch(field.type)&#123; case &quot;select-one&quot;: case &quot;select-multiple&quot;: if (field.name.length)&#123; for (j=0, optLen = field.options.length; j &lt; optLen; j++)&#123; option = field.options[j]; if (option.selected)&#123; optValue = &quot;&quot;; if (option.hasAttribute)&#123; optValue = (option.hasAttribute(&quot;value&quot;) ? option.value : option.text); &#125; else &#123; optValue = (option.attributes[&quot;value&quot;].specified ? option.value : option.text); &#125; parts.push(encodeURIComponent(field.name) + &quot;=&quot; + encodeURIComponent(optValue)); &#125; &#125; &#125; break; case undefined: //字段集 case &quot;file&quot;: //文件输入 case &quot;submit&quot;: //提交按钮 case &quot;reset&quot;: //重置按钮 case &quot;button&quot;: //自定义按钮 break; case &quot;radio&quot;: //单选按钮 case &quot;checkbox&quot;: //复选框 if (!field.checked)&#123; break; &#125; /* 执行默认操作 */ default: //不包含没有名字的表单字段 if (field.name.length)&#123; parts.push(encodeURIComponent(field.name) + &quot;=&quot; + encodeURIComponent(field.value)); &#125; &#125; &#125; return parts.join(&quot;&amp;&quot;);&#125; 跨域问题 跨文档消息传递跨文档消息传送（cross-document messaging），有时候简称为 XDM，指的是在来自不同域的页面间传递消息。例如，www.wrox.com 域中的页面与位于一个内嵌框架中的 p2p.wrox.com 域中的页面通信。在 XDM 机制出现之前，要稳妥地实现这种通信需要花很多工夫。XDM 把这种机制规范化，让我们能既稳妥又简单地实现跨文档通信。 12345678910postMessage()方法接收两个参数：一条消息和一个表示消息接收方来自哪个域的字符串。第二个参数对保障安全通信非常重要，可以防止浏览器把消息发送到不安全的地方。来看下面的例子。//注意：所有支持 XDM 的浏览器也支持 iframe 的 contentWindow 属性var iframeWindow = document.getElementById(&quot;myframe&quot;).contentWindow;iframeWindow.postMessage(&quot;A secret&quot;, &quot;http://www.wrox.com&quot;);使用 postMessage()时，最好还是只传字符串。如果你想传入结构化的数据，最佳选择是先在要传入的数据上调用 JSON.stringify()，通过 postMessage()传入得到的字符串，然后再在 onmessage 事件处理程序中调用 JSON.parse()。 可拖动1234&lt;!-- 让这个图像不可以拖动 --&gt;&lt;img src=&quot;smile.gif&quot; draggable=&quot;false&quot; alt=&quot;Smiley face&quot;&gt;&lt;!-- 让这个元素可以拖动 --&gt;&lt;div draggable=&quot;true&quot;&gt;...&lt;/div&gt; 媒体元素123456789随着音频和视频在 Web 上的迅速流行，大多数提供富媒体内容的站点为了保证跨浏览器兼容性，不得不选择使用 Flash。HTML5 新增了两个与媒体相关的标签，让开发人员不必依赖任何插件就能在网页中嵌入跨浏览器的音频和视频内容。这两个标签就是&lt;audio&gt;和&lt;video&gt;。这两个标签除了能让开发人员方便地嵌入媒体文件之外，都提供了用于实现常用功能的 JavaScriptAPI，允许为媒体创建自定义的控件。这两个元素的用法如下。&lt;!-- 嵌入视频 --&gt;&lt;video src=&quot;conference.mpg&quot; id=&quot;myVideo&quot;&gt;Video player not available.&lt;/video&gt;&lt;!-- 嵌入音频 --&gt;&lt;audio src=&quot;song.mp3&quot; id=&quot;myAudio&quot;&gt;Audio player not available.&lt;/audio&gt; history对象12345678910111213141516history.pushState(&#123;name:&quot;Nicholas&quot;&#125;, &quot;Nicholas&#x27; page&quot;, &quot;nicholas.html&quot;);执行 pushState()方法后，新的状态信息就会被加入历史状态栈，而浏览器地址栏也会变成新的相对 URL。但是，浏览器并不会真的向服务器发送请求，即使状态改变之后查询 location.href 也会返回与地址栏中相同的地址。另外，第二个参数目前还没有浏览器实现，因此完全可以只传入一个空字符串，或者一个短标题也可以。而第一个参数则应该尽可能提供初始化页面状态所需的各种信息。因为 pushState()会创建新的历史状态，所以你会发现“后退”按钮也能使用了。按下“后退”按钮，会触发 window 对象的 popstate 事件①。popstate 事件的事件对象有一个 state 属性，这个属性就包含着当初以第一个参数传递给 pushState()的状态对象。EventUtil.addHandler(window, &quot;popstate&quot;, function(event)&#123; var state = event.state; if (state)&#123; //第一个页面加载时 state 为空 processState(state); &#125;&#125;);要更新当前状态，可以调用 replaceState()，传入的参数与 pushState()的前两个参数相同。调用这个方法不会在历史状态栈中创建新状态，只会重写当前状态。history.replaceState(&#123;name:&quot;Greg&quot;&#125;, &quot;Greg&#x27;s page&quot;);","categories":[],"tags":[{"name":"高程","slug":"高程","permalink":"https://vlwq.github.io/tags/%E9%AB%98%E7%A8%8B/"}]},{"title":"高程笔记5-事件","slug":"2017高程/20170613","date":"2017-06-13T02:36:00.000Z","updated":"2017-07-16T04:21:14.746Z","comments":true,"path":"2017/06/13/2017高程/20170613/","link":"","permalink":"https://vlwq.github.io/2017/06/13/2017%E9%AB%98%E7%A8%8B/20170613/","excerpt":"高程笔记5","text":"高程笔记5 事件冒泡IE 的事件流叫做事件冒泡（event bubbling），即事件开始时由最具体的元素（文档中嵌套层次最深的那个节点）接收，然后逐级向上传播到较为不具体的节点（文档）。以下面的 HTML 页面为例： 1234567891011121314151617&lt;!DOCTYPE html&gt;&lt;html&gt;&lt;head&gt; &lt;title&gt;Event Bubbling Example&lt;/title&gt;&lt;/head&gt;&lt;body&gt; &lt;div id=&quot;myDiv&quot;&gt;Click Me&lt;/div&gt;&lt;/body&gt;&lt;/html&gt;如果你单击了页面中的&lt;div&gt;元素，那么这个 click 事件会按照如下顺序传播：(1) &lt;div&gt;(2) &lt;body&gt;(3) &lt;html&gt;(4) document也就是说，click 事件首先在&lt;div&gt;元素上发生，而这个元素就是我们单击的元素。然后，click事件沿 DOM 树向上传播，在每一级节点上都会发生，直至传播到 document 对象。图 13-1 展示了事件冒泡的过程。 事件捕获12345678910Netscape Communicator 团队提出的另一种事件流叫做事件捕获（event capturing）。事件捕获的思想是不太具体的节点应该更早接收到事件，而最具体的节点应该最后接收到事件。事件捕获的用意在于在事件到达预定目标之前捕获它。如果仍以前面的 HTML 页面作为演示事件捕获的例子，那么单击&lt;div&gt;元素就会以下列顺序触发 click 事件。(1) document(2) &lt;html&gt;(3) &lt;body&gt;(4) &lt;div&gt;在事件捕获过程中，document 对象首先接收到 click 事件，然后事件沿 DOM 树依次向下，一直传播到事件的实际目标，即&lt;div&gt;元素。 HTML事件处理程序12345678910111213在 HTML 中定义的事件处理程序可以包含要执行的具体动作，也可以调用在页面其他地方定义的脚本，如下面的例子所示：&lt;script type=&quot;text/javascript&quot;&gt; function showMessage()&#123; alert(&quot;Hello world!&quot;); &#125;&lt;/script&gt;&lt;input type=&quot;button&quot; value=&quot;Click Me&quot; onclick=&quot;showMessage()&quot; /&gt;通过 HTML 指定事件处理程序的最后一个缺点是 HTML 与 JavaScript 代码紧密耦合。如果要更换事件处理程序，就要改动两个地方：HTML 代码和 JavaScript 代码。而这正是许多开发人员摒弃 HTML 事件处理程序，转而使用 JavaScript 指定事件处理程序的原因所在。 DOM2 级事件处理程序 “DOM2级事件”定义了两个方法，用于处理指定和删除事件处理程序的操作：addEventListener()和 removeEventListener()。所有 DOM 节点中都包含这两个方法，并且它们都接受 3 个参数：要处理的事件名、作为事件处理程序的函数和一个布尔值。最后这个布尔值参数如果是 true，表示在捕获阶段调用事件处理程序；如果是 false，表示在冒泡阶段调用事件处理程序。要在按钮上为 click 事件添加事件处理程序，可以使用下列代码： 1234567891011121314151617var btn = document.getElementById(&quot;myBtn&quot;);btn.addEventListener(&quot;click&quot;, function()&#123; alert(this.id);&#125;, false);上面的代码为一个按钮添加了 onclick 事件处理程序，而且该事件会在冒泡阶段被触发（因为最后一个参数是 false）。与 DOM0 级方法一样，这里添加的事件处理程序也是在其依附的元素的作用域中运行。//移除removeEventListener，函数不能匿名var btn = document.getElementById(&quot;myBtn&quot;);var handler = function()&#123; alert(this.id);&#125;;btn.addEventListener(&quot;click&quot;, handler, false);//这里省略了其他代码btn.removeEventListener(&quot;click&quot;, handler, false); //有效！ 事件类型 Web 浏览器中可能发生的事件有很多类型。如前所述，不同的事件类型具有不同的信息，而“DOM3级事件”规定了以下几类事件。 12345678910 UI（User Interface，用户界面）事件，当用户与页面上的元素交互时触发； 焦点事件，当元素获得或失去焦点时触发； 鼠标事件，当用户通过鼠标在页面上执行操作时触发； 滚轮事件，当使用鼠标滚轮（或类似设备）时触发； 文本事件，当在文档中输入文本时触发； 键盘事件，当用户通过键盘在页面上执行操作时触发； 合成事件，当为 IME（Input Method Editor，输入法编辑器）输入字符时触发； 变动（mutation）事件，当底层 DOM 结构发生变化时触发。 变动名称事件，当元素或属性名变动时触发。此类事件已经被废弃，没有任何浏览器实现它们，因此本章不做介绍 UI事件UI 事件指的是那些不一定与用户操作有关的事件。这些事件在 DOM 规范出现之前，都是以这种或那种形式存在的，而在 DOM 规范中保留是为了向后兼容。现有的 UI 事件如下。 1234567891011121314151617 DOMActivate：表示元素已经被用户操作（通过鼠标或键盘）激活。这个事件在 DOM3 级事件中被废弃，但 Firefox 2+和 Chrome 支持它。考虑到不同浏览器实现的差异，不建议使用这个事件。 load：当页面完全加载后在 window 上面触发，当所有框架都加载完毕时在框架集上面触发，当图像加载完毕时在&lt;img&gt;元素上面触发，或者当嵌入的内容加载完毕时在&lt;object&gt;元素上面触发。 unload：当页面完全卸载后在 window 上面触发，当所有框架都卸载后在框架集上面触发，或者当嵌入的内容卸载完毕后在&lt;object&gt;元素上面触发。 abort：在用户停止下载过程时，如果嵌入的内容没有加载完，则在&lt;object&gt;元素上面触发。 error：当发生 JavaScript 错误时在 window 上面触发，当无法加载图像时在&lt;img&gt;元素上面触发，当无法加载嵌入内容时在&lt;object&gt;元素上面触发，或者当有一或多个框架无法加载时在框架集上面触发。第 17 章将继续讨论这个事件。 select：当用户选择文本框（&lt;input&gt;或&lt;texterea&gt;）中的一或多个字符时触发。第 14 章将继续讨论这个事件。 resize：当窗口或框架的大小变化时在 window 或框架上面触发。 scroll：当用户滚动带滚动条的元素中的内容时，在该元素上面触发。&lt;body&gt;元素中包含所加载页面的滚动条。 load 事件 JavaScript 中最常用的一个事件就是 load。当页面完全加载后（包括所有图像、JavaScript 文件、CSS 文件等外部资源），就会触发 window 上面的 load 事件。有两种定义 onload 事件处理程序的方式。第一种方式是使用如下所示的 JavaScript 代码：EventUtil.addHandler(window, “load”, function(event){ alert(“Loaded!”);}); unload 事件 与 load 事件对应的是 unload 事件，这个事件在文档被完全卸载后触发。只要用户从一个页面切换到另一个页面，就会发生 unload 事件。而利用这个事件最多的情况是清除引用，以避免内存泄漏。与 load 事件类似，也有两种指定 onunload 事件处理程序的方式。第一种方式是使用 JavaScript，如下所示：EventUtil.addHandler(window, “unload”, function(event){ alert(“Unloaded”);}); resize 事件 当浏览器窗口被调整到一个新的高度或宽度时，就会触发resize事件。这个事件在window（窗口）上面触发，因此可以通过JavaScript或者元素中的onresize特性来指定事件处理程序。如前所述，我们还是推荐使用如下所示的 JavaScript 方式：EventUtil.addHandler(window, “resize”, function(event){ alert(“Resized”);}); 4.scroll 事件 虽然 scroll 事件是在 window 对象上发生的，但它实际表示的则是页面中相应元素的变化。在混杂模式下，可以通过元素的 scrollLeft 和 scrollTop 来监控到这一变化；而在标准模式下，除 Safari 之外的所有浏览器都会通过元素来反映这一变化（Safari 仍然基于跟踪滚动位置），如下面的例子所示：EventUtil.addHandler(window, “scroll”, function(event){ if (document.compatMode &#x3D;&#x3D; “CSS1Compat”){ alert(document.documentElement.scrollTop); } else { alert(document.body.scrollTop); }}); 焦点事件  blur：在元素失去焦点时触发。这个事件不会冒泡；所有浏览器都支持它。 focus：在元素获得焦点时触发。这个事件不会冒泡；所有浏览器都支持它。 鼠标与滚轮事件鼠标事件是 Web 开发中最常用的一类事件，毕竟鼠标还是最主要的定位设备。DOM3 级事件中定义了 9 个鼠标事件，简介如下。  click：在用户单击主鼠标按钮（一般是左边的按钮）或者按下回车键时触发。这一点对确保易访问性很重要，意味着 onclick 事件处理程序既可以通过键盘也可以通过鼠标执行。 dblclick：在用户双击主鼠标按钮（一般是左边的按钮）时触发。从技术上说，这个事件并不是 DOM2 级事件规范中规定的，但鉴于它得到了广泛支持，所以 DOM3 级事件将其纳入了标准。 mousedown：在用户按下了任意鼠标按钮时触发。不能通过键盘触发这个事件。 mouseenter：在鼠标光标从元素外部首次移动到元素范围之内时触发。这个事件不冒泡，而且在光标移动到后代元素上不会触发。DOM2 级事件并没有定义这个事件，但 DOM3 级事件将它纳入了规范。IE、Firefox 9+和 Opera 支持这个事件。 mouseleave：在位于元素上方的鼠标光标移动到元素范围之外时触发。这个事件不冒泡，而且在光标移动到后代元素上不会触发。DOM2 级事件并没有定义这个事件，但 DOM3 级事件将它纳入了规范。IE、Firefox 9+和 Opera 支持这个事件。 mousemove：当鼠标指针在元素内部移动时重复地触发。不能通过键盘触发这个事件。 mouseout：在鼠标指针位于一个元素上方，然后用户将其移入另一个元素时触发。又移入的另一个元素可能位于前一个元素的外部，也可能是这个元素的子元素。不能通过键盘触发这个事件。 mouseover：在鼠标指针位于一个元素外部，然后用户将其首次移入另一个元素边界之内时触发。不能通过键盘触发这个事件。 mouseup：在用户释放鼠标按钮时触发。不能通过键盘触发这个事件。 键盘与文本事件有 3 个键盘事件，简述如下。  keydown：当用户按下键盘上的任意键时触发，而且如果按住不放的话，会重复触发此事件。 keypress：当用户按下键盘上的字符键时触发，而且如果按住不放的话，会重复触发此事件。按下 Esc 键也会触发这个事件。Safari 3.1 之前的版本也会在用户按下非字符键时触发 keypress事件。 keyup：当用户释放键盘上的键时触发。 123456789101112131415161718var textbox = document.getElementById(&quot;myText&quot;);EventUtil.addHandler(textbox, &quot;keyup&quot;, function(event)&#123; event = EventUtil.getEvent(event); alert(event.keyCode);&#125;);//字符编码var EventUtil = &#123; //省略的代码 getCharCode: function(event)&#123; if (typeof event.charCode == &quot;number&quot;)&#123; return event.charCode; &#125; else &#123; return event.keyCode; &#125; &#125;, //省略的代码&#125;; 事件委托 对“事件处理程序过多”问题的解决方案就是事件委托。事件委托利用了事件冒泡，只指定一个事件处理程序，就可以管理某一类型的所有事件。例如，click 事件会一直冒泡到 document 层次。也就是说，我们可以为整个页面指定一个 onclick 事件处理程序，而不必给每个可单击的元素分别添加事件处理程序。以下面的 HTML 代码为例。 1234567891011121314151617181920212223&lt;ul id=&quot;myLinks&quot;&gt; &lt;li id=&quot;goSomewhere&quot;&gt;Go somewhere&lt;/li&gt; &lt;li id=&quot;doSomething&quot;&gt;Do something&lt;/li&gt; &lt;li id=&quot;sayHi&quot;&gt;Say hi&lt;/li&gt;&lt;/ul&gt;var list = document.getElementById(&quot;myLinks&quot;);EventUtil.addHandler(list, &quot;click&quot;, function(event)&#123; event = EventUtil.getEvent(event); var target = EventUtil.getTarget(event); switch(target.id)&#123; case &quot;doSomething&quot;: document.title = &quot;I changed the document&#x27;s title&quot;; break; case &quot;goSomewhere&quot;: location.href = &quot;http://www.wrox.com&quot;; break; case &quot;sayHi&quot;: alert(&quot;hi&quot;); break; &#125;&#125;); 最适合采用事件委托技术的事件包括 click、mousedown、mouseup、keydown、keyup 和 keypress。虽然 mouseover 和 mouseout 事件也冒泡，但要适当处理它们并不容易，而且经常需要计算元素的位置。（因为当鼠标从一个元素移到其子节点时，或者当鼠标移出该元素时，都会触发 mouseout 事件。） 自定义 DOM 事件DOM3 级还定义了“自定义事件”。自定义事件不是由 DOM 原生触发的，它的目的是让开发人员创建自己的事件。要创建新的自定义事件，可以调用 createEvent(“CustomEvent”)。返回的对象有一个名为 initCustomEvent()的方法，接收如下 4 个参数。  type（字符串）：触发的事件类型，例如”keydown”。 bubbles（布尔值）：表示事件是否应该冒泡。 cancelable（布尔值）：表示事件是否可以取消。 detail（对象）：任意值，保存在 event 对象的 detail 属性中。 123456789101112131415161718var div = document.getElementById(&quot;myDiv&quot;), event;EventUtil.addHandler(div, &quot;myevent&quot;, function(event)&#123; alert(&quot;DIV: &quot; + event.detail);&#125;);EventUtil.addHandler(document, &quot;myevent&quot;, function(event)&#123; alert(&quot;DOCUMENT: &quot; + event.detail);&#125;);if (document.implementation.hasFeature(&quot;CustomEvents&quot;, &quot;3.0&quot;))&#123; event = document.createEvent(&quot;CustomEvent&quot;); event.initCustomEvent(&quot;myevent&quot;, true, false, &quot;Hello world!&quot;); div.dispatchEvent(event);&#125;这个例子创建了一个冒泡事件&quot;myevent&quot;。而 event.detail 的值被设置成了一个简单的字符串，然后在&lt;div&gt;元素和 document 上侦听这个事件。因为 initCustomEvent()方法已经指定这个事件应该冒泡，所以浏览器会负责将事件向上冒泡到 document。支持自定义 DOM 事件的浏览器有 IE9+和 Firefox 6+。","categories":[],"tags":[{"name":"高程","slug":"高程","permalink":"https://vlwq.github.io/tags/%E9%AB%98%E7%A8%8B/"}]},{"title":"高程笔记4-BOM","slug":"2017高程/20170612","date":"2017-06-12T02:36:00.000Z","updated":"2017-07-16T04:19:24.266Z","comments":true,"path":"2017/06/12/2017高程/20170612/","link":"","permalink":"https://vlwq.github.io/2017/06/12/2017%E9%AB%98%E7%A8%8B/20170612/","excerpt":"高程笔记4-BOM","text":"高程笔记4-BOM 8-windows对象1234567891011抛开全局变量会成为 window 对象的属性不谈，定义全局变量与在 window 对象上直接定义属性还是有一点差别：全局变量不能通过 delete 操作符删除，而直接在 window 对象上的定义的属性可以。例如：var age = 29;window.color = &quot;red&quot;;//在 IE &lt; 9 时抛出错误，在其他所有浏览器中都返回 falsedelete window.age;//在 IE &lt; 9 时抛出错误，在其他所有浏览器中都返回 truedelete window.color; //returns truealert(window.age); //29alert(window.color); //undefined 间歇调用和超时调用1234567891011121314//设置超时调用var timeoutId = setTimeout(function() &#123; alert(&quot;Hello world!&quot;);&#125;, 1000);//注意：把它取消clearTimeout(timeoutId);//不建议传递字符串！setInterval (&quot;alert(&#x27;Hello world!&#x27;) &quot;, 10000);//推荐的调用方式setInterval (function() &#123; alert(&quot;Hello world!&quot;);&#125;, 10000) 浏览器通过 alert()、confirm()和 prompt()方法可以调用系统对话框向用户显示消息。&#x2F;&#x2F;显示“打印”对话框window.print();&#x2F;&#x2F;显示“查找”对话框window.find(); location 对象位置操作 123456789101112131415161718192021location.assign(&quot;http://www.wrox.com&quot;);window.location = &quot;http://www.wrox.com&quot;;location.href = &quot;http://www.wrox.com&quot;;//假设初始 URL 为 http://www.wrox.com/WileyCDA///将 URL 修改为&quot;http://www.wrox.com/WileyCDA/#section1&quot;location.hash = &quot;#section1&quot;;//将 URL 修改为&quot;http://www.wrox.com/WileyCDA/?q=javascript&quot;location.search = &quot;?q=javascript&quot;;//将 URL 修改为&quot;http://www.yahoo.com/WileyCDA/&quot;location.hostname = &quot;www.yahoo.com&quot;;//将 URL 修改为&quot;http://www.yahoo.com/mydir/&quot;location.pathname = &quot;mydir&quot;;//将 URL 修改为&quot;http://www.yahoo.com:8080/WileyCDA/&quot;location.port = 8080;每次修改 location 的属性（hash 除外），页面都会以新 URL 重新加载。 重新加载location.reload(); &#x2F;&#x2F;重新加载（有可能从缓存中加载）location.reload(true); &#x2F;&#x2F;重新加载（从服务器重新加载） history 对象12345678910111213141516171819使用 go()方法可以在用户的历史记录中任意跳转，可以向后也可以向前。这个方法接受一个参数，表示向后或向前跳转的页面数的一个整数值。负数表示向后跳转（类似于单击浏览器的“后退”按钮），正数表示向前跳转（类似于单击浏览器的“前进”按钮）。来看下面的例子。//后退一页history.go(-1);//前进一页history.go(1);//前进两页history.go(2);//跳转到最近的 wrox.com 页面history.go(&quot;wrox.com&quot;);//跳转到最近的 nczonline.net 页面history.go(&quot;nczonline.net&quot;);另外，还可以使用两个简写方法 back()和 forward()来代替 go()。顾名思义，这两个方法可以模仿浏览器的“后退”和“前进”按钮。//后退一页history.back();//前进一页history.forward(); BOM总结 浏览器对象模型（BOM）以 window 对象为依托，表示浏览器窗口以及页面可见区域。同时，window对象还是 ECMAScript 中的 Global 对象，因而所有全局变量和函数都是它的属性，且所有原生的构造函数及其他函数也都存在于它的命名空间下。本章讨论了下列 BOM 的组成部分。 在使用框架时，每个框架都有自己的 window 对象以及所有原生构造函数及其他函数的副本。每个框架都保存在 frames 集合中，可以通过位置或通过名称来访问。 有一些窗口指针，可以用来引用其他框架，包括父框架。 top 对象始终指向最外围的框架，也就是整个浏览器窗口。 parent 对象表示包含当前框架的框架，而 self 对象则回指 window。 使用 location 对象可以通过编程方式来访问浏览器的导航系统。设置相应的属性，可以逐段或整体性地修改浏览器的 URL。 调用 replace()方法可以导航到一个新 URL，同时该 URL 会替换浏览器历史记录中当前显示的页面。 navigator 对象提供了与浏览器有关的信息。到底提供哪些信息，很大程度上取决于用户的浏览器；不过，也有一些公共的属性（如 userAgent）存在于所有浏览器中。BOM 中还有两个对象：screen 和 history，但它们的功能有限。screen 对象中保存着与客户端显示器有关的信息，这些信息一般只用于站点分析。history 对象为访问浏览器的历史记录开了一个小缝隙，开发人员可以据此判断历史记录的数量，也可以在历史记录中向后或向前导航到任意页面。 10.DOMDOCUMENT 这个页面在经过浏览器解析后，其文档中只包含一个子节点，即元素。可以通过documentElement 或 childNodes 列表来访问这个元素，如下所示。 12345678910111213141516var html = document.documentElement; //取得对&lt;html&gt;的引用alert(html === document.childNodes[0]); //truealert(html === document.firstChild); //true//取得文档标题var originalTitle = document.title;//设置文档标题document.title = &quot;New page title&quot;;//取得完整的 URLvar url = document.URL;//取得域名var domain = document.domain;//取得来源页面的 URLvar referrer = document.referrer; 文档写入 有一个 document 对象的功能已经存在很多年了，那就是将输出流写入到网页中的能力。这个能力体现在下列 4 个方法中：write()、writeln()、open()和 close()。其中，write()和 writeln()方法都接受一个字符串参数，即要写入到输出流中的文本。write()会原样写入，而 writeln()则会在字符串的末尾添加一个换行符（\\n）。在页面被加载的过程中，可以使用这两个方法向页面中动态地加入内容，如下面的例子所示。 Element类型12345678910111213if (element.tagName == &quot;div&quot;)&#123; //不能这样比较，很容易出错！ //在此执行某些操作&#125;if (element.tagName.toLowerCase() == &quot;div&quot;)&#123; //这样最好（适用于任何文档） //在此执行某些操作&#125;//属性的3个方法div.setAttribute(&quot;id&quot;, &quot;someOtherId&quot;);alert(div.getAttribute(&quot;mycolor&quot;)); //null（IE 除外）div.removeAttribute(&quot;class&quot;); DOM拓展querySelector()方法 1234567891011121314//取得 body 元素var body = document.querySelector(&quot;body&quot;);//取得某&lt;div&gt;中的所有&lt;em&gt;元素（类似于 getElementsByTagName(&quot;em&quot;)）var ems = document.getElementById(&quot;myDiv&quot;).querySelectorAll(&quot;em&quot;);//matchesSelector()方法//Selectors API Level 2 规范为 Element 类型新增了一个方法 matchesSelector()。这个方法接收//一个参数，即 CSS 选择符，如果调用元素与该选择符匹配，返回 true；否则，返回 false。看例子。if (document.body.matchesSelector(&quot;body.page1&quot;))&#123; //true&#125; classList 属性  add(value)：将给定的字符串值添加到列表中。如果值已经存在，就不添加了。 contains(value)：表示列表中是否存在给定的值，如果存在则返回 true，否则返回 false。 remove(value)：从列表中删除给定的字符串。 toggle(value)：如果列表中已经存在给定的值，删除它；如果列表中没有给定的值，添加它。 1234567891011121314151617//删除&quot;disabled&quot;类div.classList.remove(&quot;disabled&quot;);//添加&quot;current&quot;类div.classList.add(&quot;current&quot;);//切换&quot;user&quot;类div.classList.toggle(&quot;user&quot;);//确定元素中是否包含既定的类名if (div.classList.contains(&quot;bd&quot;) &amp;&amp; !div.classList.contains(&quot;disabled&quot;))&#123; //执行操作)//迭代类名for (var i=0, len=div.classList.length; i &lt; len; i++)&#123; doSomething(div.classList[i]);&#125;有了 classList 属性，除非你需要全部删除所有类名，或者完全重写元素的 class 属性，否则也就用不到 className 属性了。支持 classList 属性的浏览器有 Firefox 3.6+和 Chrome。 焦点管理123456默认情况下，文档刚刚加载完成时，document.activeElement 中保存的是 document.body 元素的引用。文档加载期间，document.activeElement 的值为 null。另外就是新增了 document.hasFocus()方法，这个方法用于确定文档是否获得了焦点。var button = document.getElementById(&quot;myButton&quot;);button.focus();alert(document.hasFocus()); //true 自定义数据属性 HTML5 规定可以为元素添加非标准的属性，但要添加前缀 data-，目的是为元素提供与渲染无关的信息，或者提供语义信息。这些属性可以任意添加、随便命名，只要以 data-开头即可。来看一个例子。 12345678910111213&lt;div id=&quot;myDiv&quot; data-appId=&quot;12345&quot; data-myname=&quot;Nicholas&quot;&gt;&lt;/div&gt;添加了自定义属性之后，可以通过元素的 dataset 属性来访问自定义属性的值。dataset 属性的值是 DOMStringMap 的一个实例，也就是一个名值对儿的映射。在这个映射中，每个 data-name 形式的属性都会有一个对应的属性，只不过属性名没有 data-前缀（比如，自定义属性是 data-myname，那映射中对应的属性就是 myname）。还是看一个例子吧。//本例中使用的方法仅用于演示var div = document.getElementById(&quot;myDiv&quot;);//取得自定义属性的值var appId = div.dataset.appId;var myName = div.dataset.myname;//设置值div.dataset.appId = 23456;div.dataset.myname = &quot;Michael&quot;; 字符集属性12345HTML5 新增了几个与文档字符集有关的属性。其中，charset 属性表示文档中实际使用的字符集，也可以用来指定新字符集。默认情况下，这个属性的值为&quot;UTF-16&quot;，但可以通过&lt;meta&gt;元素、响应头部或直接设置 charset 属性修改这个值。来看一个例子。alert(document.charset); //&quot;UTF-16&quot;document.charset = &quot;UTF-8&quot;; 插入标记1234567innerHTMLs属性div.innerHTML = &quot;Hello world!&quot;;outerHTML 属性outerHTML会根据指定的 HTML 字符串创建新的 DOM 子树，然后用这个 DOM 子树完全替换调用元素div.outerHTML = &quot;&lt;p&gt;This is a paragraph.&lt;/p&gt;&quot;; //div会被覆盖掉 insertAdjacentHTML()方法插入标记的最后一个新增方式是insertAdjacentHTML()方法。这个方法最早也是在IE中出现的，它接收两个参数：插入位置和要插入的 HTML 文本。第一个参数必须是下列值之一： “beforebegin”，在当前元素之前插入一个紧邻的同辈元素； “afterbegin”，在当前元素之下插入一个新的子元素或在第一个子元素之前再插入新的子元素； “beforeend”，在当前元素之下插入一个新的子元素或在最后一个子元素之后再插入新的子元素； “afterend”，在当前元素之后插入一个紧邻的同辈元素。 123456789//作为前一个同辈元素插入element.insertAdjacentHTML(&quot;beforebegin&quot;, &quot;&lt;p&gt;Hello world!&lt;/p&gt;&quot;);//作为第一个子元素插入element.insertAdjacentHTML(&quot;afterbegin&quot;, &quot;&lt;p&gt;Hello world!&lt;/p&gt;&quot;);//作为最后一个子元素插入element.insertAdjacentHTML(&quot;beforeend&quot;, &quot;&lt;p&gt;Hello world!&lt;/p&gt;&quot;);//作为后一个同辈元素插入element.insertAdjacentHTML(&quot;afterend&quot;, &quot;&lt;p&gt;Hello world!&lt;/p&gt;&quot;);支持 insertAdjacentHTML()方法的浏览器有 IE、Firefox 8+、Safari、Opera 和 Chrome。 scrollIntoView()方法 如何滚动页面也是 DOM 规范没有解决的一个问题。为了解决这个问题，浏览器实现了一些方法，以方便开发人员更好地控制页面滚动。在各种专有方法中，HTML5 最终选择了 scrollIntoView()作为标准方法。&#x2F;&#x2F;让元素可见 1document.forms[0].scrollIntoView();  scrollIntoViewIfNeeded(alignCenter)：只在当前元素在视口中不可见的情况下，才滚动浏览器窗口或容器元素，最终让它可见。如果当前元素在视口中可见，这个方法什么也不做。如果将可选的 alignCenter 参数设置为 true，则表示尽量将元素显示在视口中部（垂直方向）。Safari 和 Chrome 实现了这个方法。 scrollByLines(lineCount)：将元素的内容滚动指定的行高，lineCount 值可以是正值，也可以是负值。Safari 和 Chrome 实现了这个方法。 scrollByPages(pageCount)：将元素的内容滚动指定的页面高度，具体高度由元素的高度决定。Safari 和 Chrome 实现了这个方法。 设置CSS1234567891011只要取得一个有效的 DOM 元素的引用，就可以随时使用 JavaScript 为其设置样式。以下是几个例子。var myDiv = document.getElementById(&quot;myDiv&quot;);//设置背景颜色myDiv.style.backgroundColor = &quot;red&quot;;//改变大小myDiv.style.width = &quot;100px&quot;;myDiv.style.height = &quot;200px&quot;;//指定边框myDiv.style.border = &quot;1px solid black&quot;;在以这种方式改变样式时，元素的外观会自动被更新。 DOM 样式属性和方法“DOM2级样式”规范还为 style 对象定义了一些属性和方法。这些属性和方法在提供元素的 style特性值的同时，也可以修改样式。下面列出了这些属性和方法。 cssText：如前所述，通过它能够访问到 style 特性中的 CSS 代码。 length：应用给元素的 CSS 属性的数量。 parentRule：表示 CSS 信息的 CSSRule 对象。本节后面将讨论 CSSRule 类型。 getPropertyCSSValue(propertyName)：返回包含给定属性值的 CSSValue 对象。 getPropertyPriority(propertyName)：如果给定的属性使用了!important 设置，则返回“important”；否则，返回空字符串。 getPropertyValue(propertyName)：返回给定属性的字符串值。 item(index)：返回给定位置的 CSS 属性的名称。 removeProperty(propertyName)：从样式中删除给定属性。 setProperty(propertyName,value,priority)：将给定属性设置为相应的值，并加上优先权标志（”important”或者一个空字符串）。 12345678910myDiv.style.cssText = &quot;width: 25px; height: 100px; background-color: green&quot;;alert(myDiv.style.cssText);设计 length 属性的目的，就是将其与 item()方法配套使用，以便迭代在元素中定义的 CSS 属性。在使用 length 和 item()时，style 对象实际上就相当于一个集合，都可以使用方括号语法来代替item()来取得给定位置的 CSS 属性，如下面的例子所示。for (var i=0, len=myDiv.style.length; i &lt; len; i++)&#123; alert(myDiv.style[i]); //或者 myDiv.style.item(i)&#125; &#x2F;&#x2F; CSS 规则 123456789101112131415161718192021var sheet = document.styleSheets[0];var rules = sheet.cssRules || sheet.rules; //取得规则列表var rule = rules[0]; //取得第一条规则alert(rule.selectorText); //&quot;div.box&quot;alert(rule.style.cssText); //完整的 CSS 代码alert(rule.style.backgroundColor); //&quot;blue&quot;alert(rule.style.width); //&quot;100px&quot;alert(rule.style.height); //&quot;200px&quot;/*使用这种方式，可以像确定元素的行内样式信息一样，确定与规则相关的样式信息。与使用元素的方式一样，在这种方式下也可以修改样式信息，如下面的例子所示。*/var sheet = document.styleSheets[0];var rules = sheet.cssRules || sheet.rules; //取得规则列表var rule = rules[0]; //取得第一条规则rule.style.backgroundColor = &quot;red&quot;//2. 创建规则sheet.insertRule(&quot;body &#123; background-color: silver &#125;&quot;, 0); //DOM 方法//3. 删除规则sheet.deleteRule(0); //DOM 方法","categories":[],"tags":[{"name":"高程","slug":"高程","permalink":"https://vlwq.github.io/tags/%E9%AB%98%E7%A8%8B/"}]},{"title":"高程笔记3-函数表达式","slug":"2017高程/20170611","date":"2017-06-11T02:36:00.000Z","updated":"2017-07-16T04:18:01.498Z","comments":true,"path":"2017/06/11/2017高程/20170611/","link":"","permalink":"https://vlwq.github.io/2017/06/11/2017%E9%AB%98%E7%A8%8B/20170611/","excerpt":"高程笔记3","text":"高程笔记3 函数表达式 123456函数表达式与其他表达式一样，在使用前必须先赋值。以下代码会导致错误。sayHi(); //错误：函数还不存在var sayHi = function()&#123; //匿名函数 alert(&quot;Hi!&quot;);&#125;; 递归函数是在一个函数通过名字调用自身的情况下构成的，如下所示。 1234567891011121314151617function factorial(num)&#123; if (num &lt;= 1)&#123; return 1; &#125; else &#123; return num * factorial(num-1); &#125;&#125;arguments.callee 是一个指向正在执行的函数的指针，因此可以用它来实现对函数的递归调用，例如function factorial(num)&#123; if (num &lt;= 1)&#123; return 1; &#125; else &#123; return num * arguments.callee(num-1); &#125;&#125; 闭包闭包是指有权访问另一个函数作用域中的变量的函数。创建闭包的常见方式，就是在一个函数内部创建另一个函数 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950function createComparisonFunction(propertyName) &#123; return function(object1, object2)&#123; var value1 = object1[propertyName]; var value2 = object2[propertyName]; if (value1 &lt; value2)&#123; return -1; &#125; else if (value1 &gt; value2)&#123; return 1; &#125; else &#123; return 0; &#125; &#125;;&#125;/*作用域链的这种配置机制引出了一个值得注意的副作用，即闭包只能取得包含函数中任何变量的最后一个值。别忘了闭包所保存的是整个变量对象，而不是某个特殊的变量。下面这个例子可以清晰地说明这个问题。*/function createFunctions()&#123; var result = new Array(); for (var i=0; i &lt; 10; i++)&#123; result[i] = function()&#123; return i; &#125;; &#125; return result;&#125;/*这个函数会返回一个函数数组。表面上看，似乎每个函数都应该返自己的索引值，即位置 0 的函数返回 0，位置 1 的函数返回 1，以此类推。但实际上，每个函数都返回 10。因为每个函数的作用域链中都保存着 createFunctions() 函数的活动对象，所以它们引用的都是同一个变量 i 。 当createFunctions()函数返回后，变量 i 的值是 10，此时每个函数都引用着保存变量 i 的同一个变量对象，所以在每个函数内部 i 的值都是 10。但是，我们可以通过创建另一个匿名函数强制让闭包的行为符合预期，如下所示。*/function createFunctions()&#123; var result = new Array(); for (var i=0; i &lt; 10; i++)&#123; result[i] = function(num)&#123; return function()&#123; return num; &#125;; &#125;(i); &#125; return result;&#125; 每个函数在被调用时都会自动取得两个特殊变量：this 和 arguments。 123456789101112把外部作用域中的 this 对象保存在一个闭包能够访问到的变量里，就可以让闭包访问该对象了var name = &quot;The Window&quot;;var object = &#123; name : &quot;My Object&quot;, getNameFunc : function()&#123; var that = this; return function()&#123; return that.name; &#125;; &#125;&#125;;alert(object.getNameFunc()()); //&quot;My Object&quot; 内存泄漏 12345678910function assignHandler()&#123; var element = document.getElementById(&quot;someElement&quot;); var id = element.id; element.onclick = function()&#123; alert(id); &#125;; element = null;&#125; 模仿块级作用域 123456789function outputNumbers(count)&#123; (function () &#123; for (var i=0; i &lt; count; i++)&#123; alert(i); &#125; &#125;)(); alert(i); //导致一个错误！&#125; 私有变量 12345678910111213141516171819202122232425262728293031function MyObject()&#123; //私有变量和私有函数 var privateVariable = 10; function privateFunction()&#123; return false; &#125; //特权方法 this.publicMethod = function ()&#123; privateVariable++; return privateFunction(); &#125;;&#125;这个模式在构造函数内部定义了所有私有变量和函数。然后，又继续创建了能够访问这些私有成员的特权方法。能够在构造函数中定义特权方法，是因为特权方法作为闭包有权访问在构造函数中定义的所有变量和函数。对这个例子而言，变量 privateVariable 和函数 privateFunction()只能通过特权方法 publicMethod()来访问。在创建 MyObject 的实例后，除了使用 publicMethod()这一个途径外，没有任何办法可以直接访问 privateVariable 和 privateFunction()。利用私有和特权成员，可以隐藏那些不应该被直接修改的数据，例如：function Person(name)&#123; this.getName = function()&#123; return name; &#125;; this.setName = function (value) &#123; name = value; &#125;;&#125;var person = new Person(&quot;Nicholas&quot;);alert(person.getName()); //&quot;Nicholas&quot;person.setName(&quot;Greg&quot;);alert(person.getName()); //&quot;Greg&quot; 静态私有变量 1234567891011121314151617181920212223(function()&#123; var name = &quot;&quot;; Person = function(value)&#123; name = value; &#125;; Person.prototype.getName = function()&#123; return name; &#125;; Person.prototype.setName = function (value)&#123; name = value; &#125;;&#125;)();var person1 = new Person(&quot;Nicholas&quot;);alert(person1.getName()); //&quot;Nicholas&quot;person1.setName(&quot;Greg&quot;);alert(person1.getName()); //&quot;Greg&quot;var person2 = new Person(&quot;Michael&quot;);alert(person1.getName()); //&quot;Michael&quot;alert(person2.getName()); //&quot;Michael&quot; 模块模式123456789101112131415161718192021222324252627282930313233343536373839模块模式通过为单例添加私有变量和特权方法能够使其得到增强，其语法形式如下：var singleton = function()&#123; //私有变量和私有函数 var privateVariable = 10; function privateFunction()&#123; return false; &#125; //特权/公有方法和属性 return &#123; publicProperty: true, publicMethod : function()&#123; privateVariable++; return privateFunction(); &#125; &#125;;&#125;();/*增强的模块模式*/var singleton = function()&#123; //私有变量和私有函数 var privateVariable = 10; function privateFunction()&#123; return false; &#125; //创建对象 var object = new CustomType(); //添加特权/公有属性和方法 object.publicProperty = true; object.publicMethod = function()&#123; privateVariable++; return privateFunction(); &#125;; //返回这个对象 return object;&#125;(); 总结 在 JavaScript 编程中，函数表达式是一种非常有用的技术。使用函数表达式可以无须对函数命名，从而实现动态编程。匿名函数，也称为拉姆达函数，是一种使用 JavaScript 函数的强大方式。以下总结了函数表达式的特点。 函数表达式不同于函数声明。函数声明要求有名字，但函数表达式不需要。没有名字的函数表达式也叫做匿名函数。 在无法确定如何引用函数的情况下，递归函数就会变得比较复杂； 递归函数应该始终使用 arguments.callee 来递归地调用自身，不要使用函数名——函数名可能会发生变化。当在函数内部定义了其他函数时，就创建了闭包。闭包有权访问包含函数内部的所有变量，原理如下。 在后台执行环境中，闭包的作用域链包含着它自己的作用域、包含函数的作用域和全局作用域。 通常，函数的作用域及其所有变量都会在函数执行结束后被销毁。 但是，当函数返回了一个闭包时，这个函数的作用域将会一直在内存中保存到闭包不存在为止。使用闭包可以在 JavaScript 中模仿块级作用域（JavaScript 本身没有块级作用域的概念），要点如下。 创建并立即调用一个函数，这样既可以执行其中的代码，又不会在内存中留下对该函数的引用。 结果就是函数内部的所有变量都会被立即销毁——除非将某些变量赋值给了包含作用域（即外部作用域）中的变量。闭包还可以用于在对象中创建私有变量，相关概念和要点如下。 即使 JavaScript 中没有正式的私有对象属性的概念，但可以使用闭包来实现公有方法，而通过公有方法可以访问在包含作用域中定义的变量。 有权访问私有变量的公有方法叫做特权方法。 可以使用构造函数模式、原型模式来实现自定义类型的特权方法，也可以使用模块模式、增强的模块模式来实现单例的特权方法。JavaScript 中的函数表达式和闭包都是极其有用的特性，利用它们可以实现很多功能。不过，因为创建闭包必须维护额外的作用域，所以过度使用它们可能会占用大量内存。","categories":[],"tags":[{"name":"高程","slug":"高程","permalink":"https://vlwq.github.io/tags/%E9%AB%98%E7%A8%8B/"}]},{"title":"高程笔记2-面向对象的程序设计","slug":"2017高程/20170610","date":"2017-06-10T02:36:00.000Z","updated":"2017-07-16T04:16:48.823Z","comments":true,"path":"2017/06/10/2017高程/20170610/","link":"","permalink":"https://vlwq.github.io/2017/06/10/2017%E9%AB%98%E7%A8%8B/20170610/","excerpt":"高程笔记二","text":"高程笔记二 面向对象的程序设计Object  [[Configurable]]：表示能否通过 delete 删除属性从而重新定义属性，能否修改属性的特性，或者能否把属性修改为访问器属性。像前面例子中那样直接在对象上定义的属性，它们的这个特性默认值为 true。 [[Enumerable]]：表示能否通过 for-in 循环返回属性。像前面例子中那样直接在对象上定义的属性，它们的这个特性默认值为 true。 [[Writable]]：表示能否修改属性的值。像前面例子中那样直接在对象上定义的属性，它们的这个特性默认值为 true。 [[Value]]：包含这个属性的数据值。读取属性值的时候，从这个位置读；写入属性值的时候，把新值保存在这个位置。这个特性的默认值为 undefined。 要修改属性默认的特性，必须使用ECMAScript 5的Object.defineProperty()方法。这个方法接收三个参数：属性所在的对象、属性的名字和一个描述符对象。其中，描述符（descriptor）对象的属性必须是：configurable、enumerable、writable 和 value。 123456789101112131415161718192021222324var person = &#123;&#125;;Object.defineProperty(person, &quot;name&quot;, &#123; writable: false, value: &quot;Nicholas&quot;&#125;);alert(person.name); //&quot;Nicholas&quot;person.name = &quot;Greg&quot;;alert(person.name); //&quot;Nicholas&quot;/*这个例子创建了一个名为 name 的属性，它的值&quot;Nicholas&quot;是只读的。这个属性的值是不可修改的，如果尝试为它指定新值，则在非严格模式下，赋值操作将被忽略；在严格模式下，赋值操作将会导致抛出错误。类似的规则也适用于不可配置的属性。例如：*/var person = &#123;&#125;;Object.defineProperty(person, &quot;name&quot;, &#123; configurable: false, value: &quot;Nicholas&quot;&#125;);alert(person.name); //&quot;Nicholas&quot;delete person.name;alert(person.name); //&quot;Nicholas&quot; 访问器属性1234567891011121314151617var book = &#123; _year: 2004, edition: 1&#125;;Object.defineProperty(book, &quot;year&quot;, &#123; get: function()&#123; return this._year; &#125;, set: function(newValue)&#123; if (newValue &gt; 2004) &#123; this._year = newValue; this.edition += newValue - 2004; &#125; &#125;&#125;);book.year = 2005;alert(book.edition); //2 工厂模式 工厂模式是软件工程领域一种广为人知的设计模式，这种模式抽象了创建具体对象的过程（本书后面还将讨论其他设计模式及其在 JavaScript 中的实现） 123456789101112function createPerson(name, age, job)&#123; var o = new Object(); o.name = name; o.age = age; o.job = job; o.sayName = function()&#123; alert(this.name); &#125;; return o;&#125;var person1 = createPerson(&quot;Nicholas&quot;, 29, &quot;Software Engineer&quot;);var person2 = createPerson(&quot;Greg&quot;, 27, &quot;Doctor&quot;); 原型模式123456789101112131415我们创建的每个函数都有一个 prototype（原型）属性，这个属性是一个指针，指向一个对象，而这个对象的用途是包含可以由特定类型的所有实例共享的属性和方法。如果按照字面意思来理解，那么 prototype 就是通过调用构造函数而创建的那个对象实例的原型对象。使用原型对象的好处是可以让所有对象实例共享它所包含的属性和方法。换句话说，不必在构造函数中定义对象实例的信息，而是可以将这些信息直接添加到原型对象中，如下面的例子所示。function Person()&#123;&#125;Person.prototype.name = &quot;Nicholas&quot;;Person.prototype.age = 29;Person.prototype.job = &quot;Software Engineer&quot;;Person.prototype.sayName = function()&#123; alert(this.name);&#125;;var person1 = new Person();person1.sayName(); //&quot;Nicholas&quot; 组合使用构造函数模式和原型模式1234567891011121314151617181920212223创建自定义类型的最常见方式，就是组合使用构造函数模式与原型模式。构造函数模式用于定义实例属性，而原型模式用于定义方法和共享的属性。结果，每个实例都会有自己的一份实例属性的副本，但同时又共享着对方法的引用，最大限度地节省了内存。另外，这种混成模式还支持向构造函数传递参数；可谓是集两种模式之长。下面的代码重写了前面的例子。function Person(name, age, job)&#123; this.name = name; this.age = age; this.job = job; this.friends = [&quot;Shelby&quot;, &quot;Court&quot;];&#125;Person.prototype = &#123; constructor : Person, sayName : function()&#123; alert(this.name); &#125;&#125;var person1 = new Person(&quot;Nicholas&quot;, 29, &quot;Software Engineer&quot;);var person2 = new Person(&quot;Greg&quot;, 27, &quot;Doctor&quot;);person1.friends.push(&quot;Van&quot;);alert(person1.friends); //&quot;Shelby,Count,Van&quot;alert(person2.friends); //&quot;Shelby,Count&quot;alert(person1.friends === person2.friends); //falsealert(person1.sayName === person2.sayName); //true 动态原型模式123456789101112131415161718有其他 OO 语言经验的开发人员在看到独立的构造函数和原型时，很可能会感到非常困惑。动态原型模式正是致力于解决这个问题的一个方案，它把所有信息都封装在了构造函数中，而通过在构造函数中初始化原型（仅在必要的情况下），又保持了同时使用构造函数和原型的优点。换句话说，可以通过检查某个应该存在的方法是否有效，来决定是否需要初始化原型。来看一个例子。function Person(name, age, job)&#123; //属性 this.name = name; this.age = age; this.job = job; //方法 if (typeof this.sayName != &quot;function&quot;)&#123; Person.prototype.sayName = function()&#123; alert(this.name); &#125;; &#125;&#125;var friend = new Person(&quot;Nicholas&quot;, 29, &quot;Software Engineer&quot;);friend.sayName(); 寄生构造函数模式123456789101112131415通常，在前述的几种模式都不适用的情况下，可以使用寄生（parasitic）构造函数模式。这种模式的基本思想是创建一个函数，该函数的作用仅仅是封装创建对象的代码，然后再返回新创建的对象；但从表面上看，这个函数又很像是典型的构造函数。下面是一个例子。function Person(name, age, job)&#123; var o = new Object(); o.name = name; o.age = age; o.job = job; o.sayName = function()&#123; alert(this.name); &#125;; return o;&#125;var friend = new Person(&quot;Nicholas&quot;, 29, &quot;Software Engineer&quot;);friend.sayName(); //&quot;Nicholas&quot; 原型链的问题1234567891011121314151617原型链虽然很强大，可以用它来实现继承，但它也存在一些问题。其中，最主要的问题来自包含引用类型值的原型。想必大家还记得，我们前面介绍过包含引用类型值的原型属性会被所有实例共享；而这也正是为什么要在构造函数中，而不是在原型对象中定义属性的原因。在通过原型来实现继承时，原型实际上会变成另一个类型的实例。于是，原先的实例属性也就顺理成章地变成了现在的原型属性了。下列代码可以用来说明这个问题。function SuperType()&#123; this.colors = [&quot;red&quot;, &quot;blue&quot;, &quot;green&quot;]; &#125;function SubType()&#123;&#125;//继承了 SuperTypeSubType.prototype = new SuperType();var instance1 = new SubType();instance1.colors.push(&quot;black&quot;);alert(instance1.colors); //&quot;red,blue,green,black&quot;var instance2 = new SubType();alert(instance2.colors); //&quot;red,blue,green,black&quot; 组合继承123456789101112131415161718192021222324252627282930313233组合继承（combination inheritance），有时候也叫做伪经典继承，指的是将原型链和借用构造函数的技术组合到一块，从而发挥二者之长的一种继承模式。其背后的思路是使用原型链实现对原型属性和方法的继承，而通过借用构造函数来实现对实例属性的继承。这样，既通过在原型上定义方法实现了函数复用，又能够保证每个实例都有它自己的属性。下面来看一个例子。function SuperType(name)&#123; this.name = name; this.colors = [&quot;red&quot;, &quot;blue&quot;, &quot;green&quot;];&#125;SuperType.prototype.sayName = function()&#123; alert(this.name); &#125;;function SubType(name, age)&#123; //继承属性 SuperType.call(this, name); this.age = age;&#125;//继承方法SubType.prototype = new SuperType();SubType.prototype.constructor = SubType;SubType.prototype.sayAge = function()&#123; alert(this.age);&#125;;var instance1 = new SubType(&quot;Nicholas&quot;, 29);instance1.colors.push(&quot;black&quot;);alert(instance1.colors); //&quot;red,blue,green,black&quot;instance1.sayName(); //&quot;Nicholas&quot;;instance1.sayAge(); //29var instance2 = new SubType(&quot;Greg&quot;, 27);alert(instance2.colors); //&quot;red,blue,green&quot;instance2.sayName(); //&quot;Greg&quot;;instance2.sayAge(); //27 原型式继承1234567891011var person = &#123; name: &quot;Nicholas&quot;, friends: [&quot;Shelby&quot;, &quot;Court&quot;, &quot;Van&quot;]&#125;;var anotherPerson = object(person);anotherPerson.name = &quot;Greg&quot;;anotherPerson.friends.push(&quot;Rob&quot;);var yetAnotherPerson = object(person);yetAnotherPerson.name = &quot;Linda&quot;;yetAnotherPerson.friends.push(&quot;Barbie&quot;);alert(person.friends); //&quot;Shelby,Court,Van,Rob,Barbie&quot; ECMAScript 5 通过新增 Object.create()方法规范化了原型式继承。这个方法接收两个参数：一个用作新对象原型的对象和（可选的）一个为新对象定义额外属性的对象。在传入一个参数的情况下，Object.create()与 object()方法的行为相同。 123456789101112var person = &#123; name: &quot;Nicholas&quot;, friends: [&quot;Shelby&quot;, &quot;Court&quot;, &quot;Van&quot;]&#125;;var anotherPerson = Object.create(person);anotherPerson.name = &quot;Greg&quot;;anotherPerson.friends.push(&quot;Rob&quot;);var yetAnotherPerson = Object.create(person);yetAnotherPerson.name = &quot;Linda&quot;;yetAnotherPerson.friends.push(&quot;Barbie&quot;);alert(person.friends); //&quot;Shelby,Court,Van,Rob,Barbie&quot; 寄生组合式继承1234567891011121314151617function SuperType(name)&#123; this.name = name; this.colors = [&quot;red&quot;, &quot;blue&quot;, &quot;green&quot;];&#125;SuperType.prototype.sayName = function()&#123; alert(this.name);&#125;;function SubType(name, age)&#123; SuperType.call(this, name); this.age = age;&#125;inheritPrototype(SubType, SuperType);SubType.prototype.sayAge = function()&#123; alert(this.age);&#125;; 总结 ECMAScript 支持面向对象（OO）编程，但不使用类或者接口。对象可以在代码执行过程中创建和增强，因此具有动态性而非严格定义的实体。在没有类的情况下，可以采用下列模式创建对象。 工厂模式，使用简单的函数创建对象，为对象添加属性和方法，然后返回对象。这个模式后来被构造函数模式所取代。 构造函数模式，可以创建自定义引用类型，可以像创建内置对象实例一样使用 new 操作符。不过，构造函数模式也有缺点，即它的每个成员都无法得到复用，包括函数。由于函数可以不局限于任何对象（即与对象具有松散耦合的特点），因此没有理由不在多个对象间共享函数。 原型模式，使用构造函数的 prototype 属性来指定那些应该共享的属性和方法。组合使用构造函数模式和原型模式时，使用构造函数定义实例属性，而使用原型定义共享的属性和方法。JavaScript 主要通过原型链实现继承。原型链的构建是通过将一个类型的实例赋值给另一个构造函数的原型实现的。这样，子类型就能够访问超类型的所有属性和方法，这一点与基于类的继承很相似。原型链的问题是对象实例共享所有继承的属性和方法，因此不适宜单独使用。解决这个问题的技术是借用构造函数，即在子类型构造函数的内部调用超类型构造函数。这样就可以做到每个实例都具有自己的属性，同时还能保证只使用构造函数模式来定义类型。使用最多的继承模式是组合继承，这种模式使用原型链继承共享的属性和方法，而通过借用构造函数继承实例属性。此外，还存在下列可供选择的继承模式。 原型式继承，可以在不必预先定义构造函数的情况下实现继承，其本质是执行对给定对象的浅复制。而复制得到的副本还可以得到进一步改造。 寄生式继承，与原型式继承非常相似，也是基于某个对象或某些信息创建一个对象，然后增强对象，最后返回对象。为了解决组合继承模式由于多次调用超类型构造函数而导致的低效率问题，可以将这个模式与组合继承一起使用。 寄生组合式继承，集寄生式继承和组合继承的优点与一身，是实现基于类型继承的最有效方式。","categories":[],"tags":[{"name":"高程","slug":"高程","permalink":"https://vlwq.github.io/tags/%E9%AB%98%E7%A8%8B/"}]},{"title":"高程笔记1","slug":"2017高程/20170609","date":"2017-06-09T02:36:00.000Z","updated":"2017-07-16T04:15:32.006Z","comments":true,"path":"2017/06/09/2017高程/20170609/","link":"","permalink":"https://vlwq.github.io/2017/06/09/2017%E9%AB%98%E7%A8%8B/20170609/","excerpt":"高程笔记一","text":"高程笔记一 JavaScript 是一种专为与网页交互而设计的脚本语言，由下列三个不同的部分组成：ECMAScript，由 ECMA-262 定义，提供核心语言功能；文档对象模型（DOM），提供访问和操作网页内容的方法和接口；浏览器对象模型（BOM），提供与浏览器交互的方法和接口。 JavaScript 的这三个组成部分，在当前五个主要浏览器（IE、Firefox、Chrome、Safari 和 Opera）中都得到了不同程度的支持。其中，所有浏览器对 ECMAScript 第 3 版的支持大体上都还不错，而对ECMAScript 5 的支持程度越来越高，但对 DOM 的支持则彼此相差比较多。对已经正式纳入 HTML5 标准的 BOM 来说，尽管各浏览器都实现了某些众所周知的共同特性，但其他特性还是会因浏览器而异。 &lt;script&gt;定义了下列 6 个属性。 async：可选。表示应该立即下载脚本，但不应妨碍页面中的其他操作， 比如下载其他资源或等待加载其他脚本。只对外部脚本文件有效。  charset：可选。表示通过src属性指定的代码的字符集。由于大多数浏览器会忽略它的值，因此这个属性很少有人用。  defer：可选。表示脚本可以延迟到文档完全被解析和显示之后再执行。 只对外部脚本文件有效。IE7 及更早版本对嵌入脚本也支持这个属性。  language：已废弃。原来用于表示编写代码使用的脚本语言（如JavaScript、JavaScript1.2或VBScript）。大多数浏览器会忽略这个属性，因此也没有必要再用了。  src：可选。表示包含要执行代码的外部文件。  type：可选。可以看成是language的替代属性；表示编写代码使用的脚本语言的内容类型（也称为 MIME 类型）。虽然 text/javascript 和 text/ecmascript 都已经不被推荐使用，但人们一直以来使用的都还是text/javascript。实际上，服务器在传送JavaScript文件时使用的MIME类型通常是application/x–javascript，但在type中设置这个值却可能导致脚本被忽略。另外，在非IE浏览器中还可以使用以下值：application/javascript和application/ecmascript。考虑到约定俗成和最大限度的浏览器兼容性，目前type属性的值依旧还是text/javascript。不过，这个属性并不是必需的，如果没有指定这个属性，则其默认值仍为text/javascript XHTML运行script1234567891011&lt;script type=&quot;text/javascript&quot;&gt;&lt;![CDATA[ function compare(a, b) &#123; if (a &lt; b) &#123; alert(&quot;A is less than B&quot;); &#125; else if (a &gt; b) &#123; alert(&quot;A is greater than B&quot;); &#125; else &#123; alert(&quot;A is equal to B&quot;); &#125; &#125;]]&gt;&lt;/script&gt; html文档模式 标准模式 12345678910&lt;!-- HTML 4.01 严格型 --&gt;&lt;!DOCTYPE HTML PUBLIC &quot;-//W3C//DTD HTML 4.01//EN&quot;&quot;http://www.w3.org/TR/html4/strict.dtd&quot;&gt;&lt;!-- XHTML 1.0 严格型 --&gt;&lt;!DOCTYPE html PUBLIC&quot;-//W3C//DTD XHTML 1.0 Strict//EN&quot;&quot;http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd&quot;&gt;&lt;!-- HTML 5 --&gt;&lt;!DOCTYPE html&gt; 非标准模式 12345678910111213141516&lt;!-- HTML 4.01 过渡型 --&gt;&lt;!DOCTYPE HTML PUBLIC&quot;-//W3C//DTD HTML 4.01 Transitional//EN&quot;&quot;http://www.w3.org/TR/html4/loose.dtd&quot;&gt;&lt;!-- HTML 4.01 框架集型 --&gt;&lt;!DOCTYPE HTML PUBLIC&quot;-//W3C//DTD HTML 4.01 Frameset//EN&quot;&quot;http://www.w3.org/TR/html4/frameset.dtd&quot;&gt;&lt;!-- XHTML 1.0 过渡型 --&gt;&lt;!DOCTYPE html PUBLIC&quot;-//W3C//DTD XHTML 1.0 Transitional//EN&quot;&quot;http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd&quot;&gt;&lt;!-- XHTML 1.0 框架集型 --&gt;&lt;!DOCTYPE html PUBLIC&quot;-//W3C//DTD XHTML 1.0 Frameset//EN&quot;&quot;http://www.w3.org/TR/xhtml1/DTD/xhtml1-frameset.dtd&quot;&gt; ECMAScript 中有 5 种简单数据类型（也称为基本数据类型）：Undefined、Null、Boolean、Number和 String。 3 个函数可以把非数值转换为数值：Number()、parseInt()和parseFloat()。第一个函数，即转型函数Number()可以用于任何数据类型，而另两个函数则专门用于把字符串转换成数值。这 3 个函数对于同样的输入会有返回不同的结果。Number()函数的转换规则如下。 如果是 Boolean 值，true 和 false 将分别被转换为 1 和 0。 如果是数字值，只是简单的传入和返回。 如果是 null 值，返回 0。 如果是 undefined，返回 NaN。 数值转换有 3 个函数可以把非数值转换为数值：Number()、parseInt()和 parseFloat()。第一个函数，即转型函数Number()可以用于任何数据类型，而另两个函数则专门用于把字符串转换成数值。这3个函数对于同样的输入会有返回不同的结果。Number()函数的转换规则如下。 如果是 Boolean 值，true 和 false 将分别被转换为 1 和 0。 如果是数字值，只是简单的传入和返回。 如果是 null 值，返回 0。 如果是 undefined，返回 NaN。 如果是字符串，遵循下列规则：  如果字符串中只包含数字（包括前面带正号或负号的情况），则将其转换为十进制数值，即”1”会变成1，”123”会变成123，而”011”会变成11（注意：前导的零被忽略了）； 如果字符串中包含有效的浮点格式，如”1.1”，则将其转换为对应的浮点数值 同样，也会忽略前导零）； 如果字符串中包含有效的十六进制格式，例如”0xf”，则将其转换为相同大小的 十进制整数值； 如果字符串是空的（不包含任何字符），则将其转换为 0； 如果字符串中包含除上述格式之外的字符，则将其转换为 NaN。 如果是对象，则调用对象的valueOf()方法，然后依照前面的规则转换返回的值。如果转换的结果是NaN，则调用对象的toString()方法，然后再次依照前面的规则转换返回的字符串值。根据这么多的规则使用Number()把各种数据类型转换为数值确实有点复杂。下面还是给出几个具体的例子吧。var num1 &#x3D; Number(“Hello world!”); &#x2F;&#x2F;NaNvar num2 &#x3D; Number(“”); &#x2F;&#x2F;0var num3 &#x3D; Number(“000011”); &#x2F;&#x2F;11 parseInt1234var num1 = parseInt(&quot;10&quot;, 2); //2 （按二进制解析）var num2 = parseInt(&quot;10&quot;, 8); //8 （按八进制解析）var num3 = parseInt(&quot;10&quot;, 10); //10 （按十进制解析）var num4 = parseInt(&quot;10&quot;, 16); //16 （按十六进制解析 parseFloat123456var num1 = parseFloat(&quot;1234blue&quot;); //1234 （整数）var num2 = parseFloat(&quot;0xA&quot;); //0var num3 = parseFloat(&quot;22.5&quot;); //22.5var num4 = parseFloat(&quot;22.34.5&quot;); //22.34var num5 = parseFloat(&quot;0908.5&quot;); //908.5var num6 = parseFloat(&quot;3.125e7&quot;); //31250000 字符String12345678910\\n 换行\\t 制表\\b 空格\\r 回车\\f 进纸\\\\ 斜杠\\&#x27; 单引号（&#x27;），在用单引号表示的字符串中使用。例如：&#x27;He said, \\&#x27;hey.\\&#x27;&#x27;\\&quot; 双引号（&quot;），在用双引号表示的字符串中使用。例如：&quot;He said, \\&quot;hey.\\&quot;&quot;\\xnn 以十六进制代码nn表示的一个字符（其中n为0～F）。例如，\\x41表示&quot;A&quot;\\unnnn 以十六进制代码nnnn表示的一个Unicode字符（其中n为0～F）。例如，\\u03a3表示希腊字符Σ 求模运算 求模（余数）操作符由一个百分号（%）表示，用法如下：var result &#x3D; 26 % 5; &#x2F;&#x2F; 等于 1与另外两个乘性操作符类似，求模操作符会遵循下列特殊规则来处理特殊的值： 如果操作数都是数值，执行常规的除法计算，返回除得的余数； 如果被除数是无穷大值而除数是有限大的数值，则结果是 NaN； 如果被除数是有限大的数值而除数是零，则结果是 NaN； 如果是 Infinity 被 Infinity 除，则结果是 NaN； 如果被除数是有限大的数值而除数是无穷大的数值，则结果是被除数； 如果被除数是零，则结果是零； 如果有一个操作数不是数值，则在后台调用 Number()将其转换为数值，然后再应用上面的规则。 减法123456var result1 = 5 - true; // 4，因为 true 被转换成了 1var result2 = NaN - 1; // NaNvar result3 = 5 - 3; // 2var result4 = 5 - &quot;&quot;; // 5，因为&quot;&quot; 被转换成了 0var result5 = 5 - &quot;2&quot;; // 3，因为&quot;2&quot;被转换成了 2var result6 = 5 - null; // 5，因为 null 被转换成了 0 全等和不全等记住：null &#x3D;&#x3D; undefined 会返回 true，因为它们是类似的值；但 null &#x3D;&#x3D;&#x3D; undefined 会返回 false，因为它们是不同类型的值 每个主要算术操作符（以及个别的其他操作符）都有对应的复合赋值操作符。这些操作符如下所示：1234567 乘/赋值（*=）； 除/赋值（/=）； 模/赋值（%=）； 加/赋值（+=）； 减/赋值（=）； 左移/赋值（&lt;&lt;=）； 有符号右移/赋值（&gt;&gt;=）； for-in语句123456for-in 语句是一种精准的迭代语句，可以用来枚举对象的属性。以下是 for-in 语句的语法：for (property in expression) statement下面是一个示例：for (var propName in window) &#123; document.write(propName);&#125; ECMAScript 对象的属性没有顺序。因此，通过 for-in 循环输出的属性名的顺序是不可预测的。具体来讲，所有属性都会被返回一次，但返回的先后次序可能会因浏览器而异。 js没有重载 ECMAScript 函数不能像传统意义上那样实现重载。而在其他语言（如Java）中，可以为一个函数编写两个定义，只要这两个定义的签名（接受的参数的类型和数量）不同即可。如前所述，ECMAScirpt函数没有签名，因为其参数是由包含零或多个值的数组来表示的。而没有函数签名，真正的重载是不可能做到的。 基本类型和引用类型的值 ECMAScript 变量可能包含两种不同数据类型的值：基本类型值和引用类型值。基本类型值指的是简单的数据段，而引用类型值指那些可能由多个值构成的对象。在将一个值赋给变量时，解析器必须确定这个值是基本类型值还是引用类型值。第 3 章讨论了 5 种基本数据类型：Undefined、Null、Boolean、Number 和 String。这 5 种基本数据类型是按值访问的，因为可以操作保存在变量中的实际的值。引用类型的值是保存在内存中的对象。与其他语言不同，JavaScript不允许直接访问内存中的位置，也就是说不能直接操作对象的内存空间。在操作对象时，实际上是在操作对象的引用而不是实际的对象。为此，引用类型的值是按引用访问的①。 在 Web 浏览器中，全局执行环境被认为是 window 对象数组的栈方法12345678var colors = new Array(); // 创建一个数组var count = colors.push(&quot;red&quot;, &quot;green&quot;); // 推入两项alert(count); //2count = colors.push(&quot;black&quot;); // 推入另一项alert(count); //3var item = colors.pop(); // 取得最后一项alert(item); //&quot;black&quot;alert(colors.length); //2 数组的重排序方法1234567891011121314151617181920数组中已经存在两个可以直接用来重排序的方法：reverse()和 sort()。有读者可能猜到了，reverse()方法会反转数组项的顺序。请看下面这个例子。var values = [1, 2, 3, 4, 5];values.reverse();alert(values); //5,4,3,2,1//自定义排序function compare(value1, value2) &#123; if (value1 &lt; value2) &#123; return 1; &#125; else if (value1 &gt; value2) &#123; return -1; &#125; else &#123; return 0; &#125;&#125;var values = [0, 1, 5, 10, 15];values.sort(compare);alert(values); // 15,10,5,1,0 数组的splice12345678910var colors = [&quot;red&quot;, &quot;green&quot;, &quot;blue&quot;];var removed = colors.splice(0,1); // 删除第一项alert(colors); // green,bluealert(removed); // red，返回的数组中只包含一项removed = colors.splice(1, 0, &quot;yellow&quot;, &quot;orange&quot;); // 从位置 1 开始插入两项alert(colors); // green,yellow,orange,bluealert(removed); // 返回的是一个空数组removed = colors.splice(1, 1, &quot;red&quot;, &quot;purple&quot;); // 插入两项，删除一项alert(colors); // green,red,purple,orange,bluealert(removed); // yellow，返回的数组中只包含一项 数组迭代方法123456789101112131415 every()：对数组中的每一项运行给定函数，如果该函数对每一项都返回 true，则返回 true。 filter()：对数组中的每一项运行给定函数，返回该函数会返回 true 的项组成的数组。 forEach()：对数组中的每一项运行给定函数。这个方法没有返回值。 map()：对数组中的每一项运行给定函数，返回每次函数调用的结果组成的数组。 some()：对数组中的每一项运行给定函数，如果该函数对任一项返回 true，则返回 true。var numbers = [1,2,3,4,5,4,3,2,1];var everyResult = numbers.every(function(item, index, array)&#123; return (item &gt; 2);&#125;);alert(everyResult); //falsevar someResult = numbers.some(function(item, index, array)&#123; return (item &gt; 2);&#125;);alert(someResult); //true 数组的归并方法 这两个方法都接收两个参数：一个在每一项上调用的函数和（可选的）作为归并基础的初始值。传给reduce()和 reduceRight()的函数接收4个参数：前一个值、当前值、项的索引和数组对象。这个函数返回的任何值都会作为第一个参数自动传给下一项。第一次迭代发生在数组的第二项上，因此第一个参数是数组的第一项，第二个参数就是数组的第二项。 123456使用 reduce()方法可以执行求数组中所有值之和的操作，比如：var values = [1,2,3,4,5];var sum = values.reduce(function(prev, cur, index, array)&#123; return prev + cur;&#125;);alert(sum); //15 js没有重载（深入理解）将函数名想象为指针，也有助于理解为什么 ECMAScript 中没有函数重载的概念。以下是曾在第 3章使用过的例子。 函数声明与函数表达式 本节到目前为止，我们一直没有对函数声明和函数表达式加以区别。而实际上，解析器在向执行环境中加载数据时，对函数声明和函数表达式并非一视同仁。解析器会率先读取函数声明，并使其在执行任何代码之前可用（可以访问）；至于函数表达式，则必须等到解析器执行到它所在的代码行，才会真正被解释执行。 12345678910alert(sum(10,10));function sum(num1, num2)&#123; return num1 + num2;&#125;下面这个报错alert(sum(10,10));var sum = function(num1, num2)&#123; return num1 + num2;&#125;; 作为值的函数12345678910function callSomeFunction(someFunction, someArgument)&#123; return someFunction(someArgument);&#125;这个函数接受两个参数。第一个参数应该是一个函数，第二个参数应该是要传递给该函数的一个值。然后，就可以像下面的例子一样传递函数了。function add10(num)&#123; return num + 10;&#125;var result1 = callSomeFunction(add10, 10);alert(result1); //20 递归12345678910111213141516function factorial(num)&#123; if (num &lt;=1) &#123; return 1; &#125; else &#123; return num * factorial(num-1) &#125;&#125;为了消除这种紧密耦合的现象，可以像下面这样使用 arguments.callee。function factorial(num)&#123; if (num &lt;=1) &#123; return 1; &#125; else &#123; return num * arguments.callee(num-1) &#125;&#125; 函数的apply和bind 每个函数都包含两个非继承而来的方法：apply()和 call()。这两个方法的用途都是在特定的作用域中调用函数，实际上等于设置函数体内 this 对象的值。首先，apply()方法接收两个参数：一个是在其中运行函数的作用域，另一个是参数数组。其中，第二个参数可以是 Array 的实例，也可以是arguments 对象。例如： 1234567891011function sum(num1, num2)&#123; return num1 + num2;&#125;function callSum1(num1, num2)&#123; return sum.apply(this, arguments); // 传入 arguments 对象&#125;function callSum2(num1, num2)&#123; return sum.apply(this, [num1, num2]); // 传入数组&#125;alert(callSum1(10,10)); //20alert(callSum2(10,10)); //20 call()方法与 apply()方法的作用相同，它们的区别仅在于接收参数的方式不同。对于 call()方法而言，第一个参数是 this 值没有变化，变化的是其余参数都直接传递给函数。换句话说，在使用call()方法时，传递给函数的参数必须逐个列举出来，如下面的例子所示。 1234567function sum(num1, num2)&#123; return num1 + num2;&#125;function callSum(num1, num2)&#123; return sum.call(this, num1, num2);&#125;alert(callSum(10,10)); //20 能够扩充函数赖以运行的作用域 123456789window.color = &quot;red&quot;;var o = &#123; color: &quot;blue&quot; &#125;;function sayColor()&#123; alert(this.color);&#125;sayColor(); //redsayColor.call(this); //redsayColor.call(window); //redsayColor.call(o); //blue ECMAScript 5 还定义了一个方法：bind()。这个方法会创建一个函数的实例，其 this 值会被绑定到传给 bind()函数的值。例如： 12345678910window.color = &quot;red&quot;;var o = &#123; color: &quot;blue&quot; &#125;;function sayColor()&#123; alert(this.color);&#125;var objectSayColor = sayColor.bind(o);objectSayColor(); //blue在这里，sayColor()调用 bind()并传入对象 o，创建了 objectSayColor()函数。objectSayColor()函数的this 值等于 o，因此即使是在全局作用域中调用这个函数，也会看到&quot;blue&quot;。 基本包装类型 ECMAScript 还提供了 3 个特殊的引用类型：Boolean、Number 和String。Object 构造函数也会像工厂方法一样，根据传入值的类型返回相应基本包装类型的实例。例如：var obj &#x3D; new Object(“some text”);alert(obj instanceof String); &#x2F;&#x2F;true Number 类型还提供了一些用于将数值格式化为字符串的方法。其中，toFixed()方法会按照指定的小数位返回数值的字符串表示，例如：var num &#x3D; 10;alert(num.toFixed(2)); &#x2F;&#x2F;“10.00”toFixed()方法可以表示带有 0 到 20 个小数位的数值。但这只是标准实现的范围，有些浏览器也可能支持更多位数 var num &#x3D; 10;alert(num.toExponential(1)); &#x2F;&#x2F;“1.0e+1”以上代码输出了”1.0e+1”；不过，这么小的数值一般不必使用 e 表示法。如果你想得到表示某个数值的最合适的格式，就应该使用 toPrecision()方法。var num &#x3D; 99;alert(num.toPrecision(1)); &#x2F;&#x2F;“1e+2”alert(num.toPrecision(2)); &#x2F;&#x2F;“99”alert(num.toPrecision(3)); &#x2F;&#x2F;“99.0” string截取1234567var stringValue = &quot;hello world&quot;;alert(stringValue.slice(3)); //&quot;lo world&quot;alert(stringValue.substring(3)); //&quot;lo world&quot;alert(stringValue.substr(3)); //&quot;lo world&quot;alert(stringValue.slice(3, 7)); //&quot;lo w&quot;alert(stringValue.substring(3,7)); //&quot;lo w&quot;alert(stringValue.substr(3, 7)); //&quot;lo worl&quot; 在传递给这些方法的参数是负值的情况下，它们的行为就不尽相同了。其中，slice()方法会将传入的负值与字符串的长度相加，substr()方法将负的第一个参数加上字符串的长度，而将负的第二个参数转换为0。最后，substring()方法会把所有负值参数都转换为 0。下 1234567var stringValue = &quot;hello world&quot;;alert(stringValue.slice(-3)); //&quot;rld&quot;alert(stringValue.substring(-3)); //&quot;hello world&quot;alert(stringValue.substr(-3)); //&quot;rld&quot;alert(stringValue.slice(3, -4)); //&quot;lo w&quot;alert(stringValue.substring(3, -4)); //&quot;hel&quot;alert(stringValue.substr(3, -4)); //&quot;&quot;（空字符串） 字符串位置方法var stringValue &#x3D; “hello world”;alert(stringValue.indexOf(“o”, 6)); &#x2F;&#x2F;7alert(stringValue.lastIndexOf(“o”, 6)); &#x2F;&#x2F;4 Global对象 诸如 isNaN()、isFinite()、parseInt()以及 parseFloat()，实际上全都是 Global对象的方法。除此之外，Global 对象还包含其他一些方法。Global 对象的 encodeURI()和 encodeURIComponent()方法可以对 URI（Uniform ResourceIdentifiers，通用资源标识符）进行编码，以便发送给浏览器。有效的 URI 中不能包含某些字符，例如空格。而这两个 URI 编码方法就可以对 URI 进行编码，它们用特殊的 UTF-8 编码替换所有无效的字符，从而让浏览器能够接受和理解。 encodeURI()主要用于整个URI（例如，http://www.wrox.com/illegalvalue.htm），而encodeURIComponent()主要用于对URI 中的某一段（例如前面URI中的illegal value.htm）进行编码。它们的主要区别在于，encodeURI()不会对本身属于URI的特殊字符进行编码，例如冒号、正斜杠、问号和井字号；而encodeURIComponent()则会对它发现的任何非标准字符进行编码。 12345678910var uri = &quot;http://www.wrox.com/illegal value.htm#start&quot;;//&quot;http://www.wrox.com/illegal%20value.htm#start&quot;alert(encodeURI(uri));//&quot;http%3A%2F%2Fwww.wrox.com%2Fillegal%20value.htm%23start&quot;alert(encodeURIComponent(uri));使用 encodeURI()编码后的结果是除了空格之外的其他字符都原封不动，只有空格被替换成了%20。而 encodeURIComponent()方法则会使用对应的编码替换所有非字母数字字符。这也正是可以对整个 URI 使用 encodeURI()，而只能对附加在现有 URI 后面的字符串使用 encodeURIComponent()的原因所在。 与 encodeURI()和 encodeURIComponent()方法对应的两个方法分别是 decodeURI()和decodeURIComponent()。 eval()方法在 eval()中创建的任何变量或函数都不会被提升，因为在解析代码的时候，它们被包含在一个字符串中；它们只在 eval()执行的时候创建 window 对象 另一种取得 Global 对象的方法是使用以下代码：var global &#x3D; function(){ return this;}(); Math对象123要找到数组中的最大或最小值，可以像下面这样使用 apply()方法。var values = [1, 2, 3, 4, 5, 6, 7, 8];var max = Math.max.apply(Math, values); Math.ceil()执行向上舍入，即它总是将数值向上舍入为最接近的整数； Math.floor()执行向下舍入，即它总是将数值向下舍入为最接近的整数； Math.round()执行标准舍入，即它总是将数值四舍五入为最接近的整数（这也是我们在数学课上学到的舍入规则） 1234567891011function selectFrom(lowerValue, upperValue) &#123; var choices = upperValue - lowerValue + 1; return Math.floor(Math.random() * choices + lowerValue);&#125;var num = selectFrom(2, 10);alert(num); // 介于 2 和 10 之间（包括 2 和 10）的一个数值//通过调用 selectFrom(2,10)就可以得到一个介于 2 和 10 之间（包括 2 和 10）的数值了。利用这个函数，可以方便地从数组中随机取出一项var colors = [&quot;red&quot;, &quot;green&quot;, &quot;blue&quot;, &quot;yellow&quot;, &quot;black&quot;, &quot;purple&quot;, &quot;brown&quot;];var color = colors[selectFrom(0, colors.length-1)];alert(color); // 可能是数组中包含的任何一个字符串 js引用类型1234567891011121314151617181920对象在 JavaScript 中被称为引用类型的值，而且有一些内置的引用类型可以用来创建特定的对象，现简要总结如下： 引用类型与传统面向对象程序设计中的类相似，但实现不同； Object 是一个基础类型，其他所有类型都从 Object 继承了基本的行为； Array 类型是一组值的有序列表，同时还提供了操作和转换这些值的功能； Date 类型提供了有关日期和时间的信息，包括当前日期和时间以及相关的计算功能； RegExp 类型是 ECMAScript 支持正则表达式的一个接口，提供了最基本的和一些高级的正则表达式功能。函数实际上是 Function 类型的实例，因此函数也是对象；而这一点正是 JavaScript 最有特色的地方。由于函数是对象，所以函数也拥有方法，可以用来增强其行为。因为有了基本包装类型，所以 JavaScript 中的基本类型值可以被当作对象来访问。三种基本包装类型分别是：Boolean、Number 和 String。以下是它们共同的特征： 每个包装类型都映射到同名的基本类型； 在读取模式下访问基本类型值时，就会创建对应的基本包装类型的一个对象，从而方便了数据操作； 操作基本类型值的语句一经执行完毕，就会立即销毁新创建的包装对象。在所有代码执行之前，作用域中就已经存在两个内置对象：Global 和 Math。在大多数 ECMAScript实现中都不能直接访问 Global 对象；不过，Web 浏览器实现了承担该角色的 window 对象。全局变量和函数都是 Global 对象的属性。Math 对象提供了很多属性和方法，用于辅助完成复杂的数学计算任务。","categories":[],"tags":[{"name":"高程","slug":"高程","permalink":"https://vlwq.github.io/tags/%E9%AB%98%E7%A8%8B/"}]},{"title":"算法","slug":"2018base/20170608","date":"2017-06-08T02:36:00.000Z","updated":"2022-03-03T03:21:36.948Z","comments":true,"path":"2017/06/08/2018base/20170608/","link":"","permalink":"https://vlwq.github.io/2017/06/08/2018base/20170608/","excerpt":"排序","text":"排序 冒泡排序123456789101112131415161718192021222324252627var log = console.log.bind(console) // 元素交换function exchange(arr ,a , b)&#123; var temp = arr[b]; arr[b] = arr[a]; arr[a] = temp;&#125;function compare(arr , count)&#123; //log(&#x27;2----&#x27;, arr) for (var i = 0; i &lt; count ; i++) &#123; if (arr[i] &gt; arr[i+1]) &#123; // 相邻元素两两对比 var a = exchange(arr ,i , i+1) //log(&#x27;3-------&#x27;,a) &#125; &#125;&#125;function bubbleSort(array) &#123; //复制数组 var arr = array.slice(0) var len = arr.length; //控制次数 for (var i = 0; i &lt; len; i++) &#123; var count = len- 1 - i compare(arr , count) &#125; return arr;&#125; 二分查找1234567891011121314151617Array.prototype.binarySearch = function(obj) &#123; var value = 0; var left = 0; var right = this.length; while (left &lt;= right) &#123; var center = Math.floor((left + right) / 2); if (this[center] == obj) &#123; value = center; &#125; if (obj &lt; this[center]) &#123; right = center - 1; &#125; else &#123; left = center + 1; &#125; &#125; alert(value);&#125; 快速排序123456789101112131415161718192021function quickSort(arr)&#123; if(arr.length&lt;=1)&#123; return arr;//如果数组只有一个数，就直接返回； &#125; var num = Math.floor(arr.length/2);//找到中间数的索引值，如果是浮点数，则向下取整 var numValue = arr.splice(num,1);//找到中间数的值 var left = []; var right = []; for(var i=0;i&lt;arr.length;i++)&#123; if(arr[i]&lt;numValue)&#123; left.push(arr[i]);//基准点的左边的数传到左边数组 &#125; else&#123; right.push(arr[i]);//基准点的右边的数传到右边数组 &#125; &#125; return quickSort(left).concat([numValue],quickSort(right));//递归不断重复比较&#125;alert(quickSort([32,45,37,16,2,87]));//弹出“2,16,32,37,45,87”","categories":[],"tags":[{"name":"base","slug":"base","permalink":"https://vlwq.github.io/tags/base/"}]},{"title":"使用淘宝的cnpm代替npm","slug":"2017node/20170702","date":"2017-06-05T02:36:00.000Z","updated":"2017-07-05T11:39:59.447Z","comments":true,"path":"2017/06/05/2017node/20170702/","link":"","permalink":"https://vlwq.github.io/2017/06/05/2017node/20170702/","excerpt":"使用国内 npm 镜像 npm 默认从国外的源（https://registry.npmjs.org/）获取和下载包信息，国内访问速度很不理想。就像其他很多开源软件都有国内镜像源，npm 也不例外。所以我们可以利用国内镜像源来加速模块安装。","text":"使用国内 npm 镜像 npm 默认从国外的源（https://registry.npmjs.org/）获取和下载包信息，国内访问速度很不理想。就像其他很多开源软件都有国内镜像源，npm 也不例外。所以我们可以利用国内镜像源来加速模块安装。 国内 npm 镜像源cnpmjs 镜像： 搜索地址：https://cnpmjs.org/registry ： https://r.cnpmjs.org/淘宝 npm 镜像： 搜索地址：https://npm.taobao.org/registry ： https://registry.npm.taobao.org/ 临时使用 1npm install express --registry https://r.cnpmjs.org/ 持久使用 npm 依次通过命令行、环境变量、.npmrc 文件来获取配置 方式一：命令行修改 npm 配置 1234# 配置 registrynpm config set registry https://r.cnpmjs.org/# 验证配置是否修改成功npm config get registry 方式二：修改环境变量 任何环境变量以npm_config_开头，将被解释为配置参数。以 windows 为例，打开：系统信息 &gt; 高级系统设置 &gt; 环境变量。可以新建一条用户变量或者系统变量 1234# 变量名npm_config_registry# 变量值https://r.cnpmjs.org/ 方式三：添加 npm 配置文件 .npmrc 1234567891011.npmrc 包含 4 级，可以按需求选择配置的地方项目目录：/path/to/my/project/.npmrc用户目录：~/.npmrc全局配置：$PREFIX/etc/.npmrc内置配置：/path/to/npm/.npmrc# .npmrc 配置registry = https://r.cnpmjs.org 命令行工具 cnpm还可以通过定制的 cnpm 命令来直接从淘宝镜像源安装模块，参考 https://npm.taobao.org/ 12345# 安装 cnpmnpm install -g cnpm --registry=https://registry.npm.taobao.org# 通过 cnpm 命令替代 npm 命令安装模块cnpm install express","categories":[],"tags":[{"name":"node","slug":"node","permalink":"https://vlwq.github.io/tags/node/"}]},{"title":"nginx配置静态网页","slug":"2016linux/20170225","date":"2017-02-25T02:36:00.000Z","updated":"2022-03-03T03:37:27.964Z","comments":true,"path":"2017/02/25/2016linux/20170225/","link":"","permalink":"https://vlwq.github.io/2017/02/25/2016linux/20170225/","excerpt":"负载均衡 123456upstream bbs &#123; server music.istorm.cc:80 weight=1; &#125; upstream blog &#123; server http://0.0.0.0:2020 weight=1; &#125;","text":"负载均衡 123456upstream bbs &#123; server music.istorm.cc:80 weight=1; &#125; upstream blog &#123; server http://0.0.0.0:2020 weight=1; &#125; 静态服务器和动态服务器配置 1234567891011121314151617181920212223242526272829303132server &#123; listen 80; server_name music.istorm.cc; location / &#123; #这个地方指定被访问的文件夹位置 root /var/www/static/music; index index.html; &#125; #location /二级域名/ &#123; # root /var/www/static/music; # index index.html; #&#125;&#125;server&#123; listen 80; # 配置 www.istorm.cc server_name www.istorm.cc; access_log /var/log/nginx/www.log; location / &#123; root /home/website_root; # proxy_pass 为反向代理后的 网站 proxy_pass http://0.0.0.0:2020; proxy_read_timeout 300; proxy_connect_timeout 300; proxy_redirect off; proxy_set_header X-Forwarded-Proto $scheme; proxy_set_header Host $http_host; proxy_set_header X-Real-IP $remote_addr; &#125;&#125;","categories":[],"tags":[{"name":"linux","slug":"linux","permalink":"https://vlwq.github.io/tags/linux/"}]},{"title":"nginx 的 403 Forbidden errors","slug":"2016linux/20170224","date":"2017-02-24T02:36:00.000Z","updated":"2022-03-03T03:37:19.386Z","comments":true,"path":"2017/02/24/2016linux/20170224/","link":"","permalink":"https://vlwq.github.io/2017/02/24/2016linux/20170224/","excerpt":"nginx 的 403 Forbidden errors 表示你在请求一个资源文件但是nginx不允许你查看。403 Forbidden 只是一个HTTP状态码，像404,200一样不是技术上的错误。哪些场景需要返回403状态码的场景？","text":"nginx 的 403 Forbidden errors 表示你在请求一个资源文件但是nginx不允许你查看。403 Forbidden 只是一个HTTP状态码，像404,200一样不是技术上的错误。哪些场景需要返回403状态码的场景？ 1.网站禁止特定的用户访问所有内容，例：网站屏蔽某个ip访问。2.访问禁止目录浏览的目录，例：设置autoindex off后访问目录。3.用户访问只能被内网访问的文件。 以上几种常见的需要返回 403 Forbidden 的场景。 由于服务器端的错误配置导致在不希望nginx返回403时返回403 Forbidden。 1.权限配置不正确 这个是nginx出现403 forbidden最常见的原因。 为了保证文件能正确执行，nginx既需要文件的读权限,又需要文件所有父目录的可执行权限。 例如，当访问&#x2F;usr&#x2F;local&#x2F;nginx&#x2F;html&#x2F;image.jpg时，nginx既需要image.jpg文件的可读权限，也需要&#x2F;,&#x2F;usr,&#x2F;usr&#x2F;local,&#x2F;usr&#x2F;local&#x2F;nginx,&#x2F;usr&#x2F;local&#x2F;nginx&#x2F;html的可以执行权限。 解决办法:设置所有父目录为755权限，设置文件为644权限可以避免权限不正确。 2.目录索引设置错误（index指令配置） 网站根目录不包含index指令设置的文件。 例如，运行PHP的网站，通常像这样配置index index index.html index.htm index.php; 当访问该网站的时，nginx 会按照 index.html，index.htm ，index.php 的先后顺序在根目录中查找文件。如果这三个文件都不存在，那么nginx就会返回403 Forbidden。 如果index中不定义 index.php ，nginx直接返回403 Forbidden而不会去检查index.php是否存在。 同样对于如果运行jsp, py时也需要添加index.jsp,index.py到目录索引指令index中。 解决办法:添加首页文件到index指令，常见的是index.php，index.jsp，index.jsp或者自定义首页文件。","categories":[],"tags":[{"name":"linux","slug":"linux","permalink":"https://vlwq.github.io/tags/linux/"}]},{"title":"nginx反向代理","slug":"2016linux/20170223","date":"2017-02-23T02:36:00.000Z","updated":"2022-03-03T03:31:28.152Z","comments":true,"path":"2017/02/23/2016linux/20170223/","link":"","permalink":"https://vlwq.github.io/2017/02/23/2016linux/20170223/","excerpt":"当只有一台服务器，而又想运行多个 web 后端服务，且希望网址为 www.XX.com &#x2F; bbs.XX.com &#x2F; blog.XX.com,怎么办，此时就要用nginx进行反向代理 以 ubuntu 为例 安装 NGINX 1$ sudo apt-get install nginx","text":"当只有一台服务器，而又想运行多个 web 后端服务，且希望网址为 www.XX.com &#x2F; bbs.XX.com &#x2F; blog.XX.com,怎么办，此时就要用nginx进行反向代理 以 ubuntu 为例 安装 NGINX 1$ sudo apt-get install nginx 修改 NGINX 的配置文件12# 配置文件在 /etc/nginx/nginx.confcd /etc/nginx 然后修改 nginx.conf,具体为:修改配置文件中 的 http{}在 http{} 中的末尾补上反向代理配置代码 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869user www-data;worker_processes auto;pid /run/nginx.pid;events &#123; worker_connections 768; # multi_accept on;&#125;http &#123; ## # 前面的代码再此不展示了,在 http&#123;&#125; 中补上以上代码 ## ## # 反向代理配置代码 ## # 注意端口号 8081 为 bbs 服务, 8082 为 blog 服务,8083 为 www 服务 upstream bbs &#123; server 127.0.0.1:8081 weight=1; &#125; upstream blog &#123; server 127.0.0.1:8082 weight=1; &#125; upstream www &#123; server 127.0.0.1:8083 weight=1; &#125; server&#123; listen 80; # 配置 www.bigbananas.cn server_name www.bigbananas.cn; access_log /var/log/nginx/www.log; location / &#123; root /home/website_root; &#125; &#125; server&#123; listen 80; # 配置 blog.bigbananas.cn server_name blog.bigbananas.cn; access_log /var/log/nginx/blog_access.log; location / &#123; root /home/todo_root; # proxy_pass 为反向代理后的 网站 proxy_pass http://127.0.0.1:8081/; proxy_read_timeout 300; proxy_connect_timeout 300; proxy_redirect off; proxy_set_header X-Forwarded-Proto $scheme; proxy_set_header Host $http_host; proxy_set_header X-Real-IP $remote_addr; &#125; &#125; server&#123; listen 80; # 配置 bbs.bigbananas.cn server_name bbs.bigbananas.cn; access_log /var/log/nginx/bbs_access.log; location / &#123; root /home/todo_root; # proxy_pass 为反向代理后的 网站 proxy_pass http://127.0.0.1:8082/; proxy_read_timeout 300; proxy_connect_timeout 300; proxy_redirect off; proxy_set_header X-Forwarded-Proto $scheme; proxy_set_header Host $http_host; proxy_set_header X-Real-IP $remote_addr; &#125; &#125;&#125; 3、 在重启 NGINX 服务 1$ sudo nginx -s reload 4、 在服务器启动 BLOG、BBS、WWW 服务 注意：端口号 8081 为 bbs 服务, 8082 为 blog 服务,8083 为 www 服务","categories":[],"tags":[{"name":"linux","slug":"linux","permalink":"https://vlwq.github.io/tags/linux/"}]},{"title":"git还原某个特定的文件到之前的版本","slug":"2018git/20170203","date":"2017-02-03T02:36:00.000Z","updated":"2022-03-03T03:35:16.612Z","comments":true,"path":"2017/02/03/2018git/20170203/","link":"","permalink":"https://vlwq.github.io/2017/02/03/2018git/20170203/","excerpt":"场景： 对于某个Git控制下的文件进行了修改，但是改的不满意，想退回到改之前的版本。假定该文件为 src&#x2F;main&#x2F;main.c","text":"场景： 对于某个Git控制下的文件进行了修改，但是改的不满意，想退回到改之前的版本。假定该文件为 src&#x2F;main&#x2F;main.c 解决方法： 第一步： 在命令行中输入 Git log src&#x2F;main&#x2F;main.c 得到该文件的commit 历史。 会得到类似下面的界面 第二步： 复制需要回退版本的hash，在此假设我们回退到 d98a0f565804ba639ba46d6e4295d4f787ff2949 ,则复制该序列即可 第三步：checkout 对应版本。格式为 git checkout , 在此即为命令行中输入 git checkout d98a0f565804ba639ba46d6e4295d4f787ff2949 src&#x2F;main&#x2F;main.c 第四步： commit checkout下来的版本。 如： git commit -m “revert to previous version”","categories":[],"tags":[{"name":"git","slug":"git","permalink":"https://vlwq.github.io/tags/git/"}]},{"title":"node启动listen EADDRINUSE","slug":"2017node/20170121","date":"2017-01-21T02:36:00.000Z","updated":"2017-07-05T11:12:41.872Z","comments":true,"path":"2017/01/21/2017node/20170121/","link":"","permalink":"https://vlwq.github.io/2017/01/21/2017node/20170121/","excerpt":"我在使用elasticsearch的kibana插件时候，有一次启动，遇到这个错误： Error: listen EADDRINUSE 0.0.0.0:5601它的意思是，端口5601被其他进程占用。 故而，需要kill掉那个进程，或者更换kibana的端口号。","text":"我在使用elasticsearch的kibana插件时候，有一次启动，遇到这个错误： Error: listen EADDRINUSE 0.0.0.0:5601它的意思是，端口5601被其他进程占用。 故而，需要kill掉那个进程，或者更换kibana的端口号。 我先找到那个进程是什么： 方法： 12netstat -apn|grep 5601 然后kill掉，即可启动kibana。","categories":[],"tags":[{"name":"node","slug":"node","permalink":"https://vlwq.github.io/tags/node/"}]},{"title":"github怎么绑定自己的域名？","slug":"2018git/20170113","date":"2017-01-13T02:36:00.000Z","updated":"2022-03-03T03:35:11.764Z","comments":true,"path":"2017/01/13/2018git/20170113/","link":"","permalink":"https://vlwq.github.io/2017/01/13/2018git/20170113/","excerpt":"向你的 Github Pages 仓库添加一个CNAME(一定要大写)文件其中只能包含一个顶级域名，像这样：1example.com","text":"向你的 Github Pages 仓库添加一个CNAME(一定要大写)文件其中只能包含一个顶级域名，像这样：1example.com 如果你是用 hexo 框架搭建博客并部署到 Github Pages 上，每次 hexo ghexo d 后会把你的博客所在目录下 public 文件夹里的东西都推到 Github Pages 仓库上，并且把 CNAME 文件覆盖掉，解决这个问题可以直接把 CNAME 文件添加到 source 文件夹里，这样每次推的时候就不用担心仓库里的 CNAME 文件被覆盖掉了。 向你的 DNS 配置中添加 3 条记录123@ A 192.30.252.153@ A 192.30.252.154www CNAME username.github.io. 用你自己的 Github 用户名替换 username推荐使用 DNSPOD 的服务，使用国外的 DNS 解析服务可能有被墙的风险。至于如何使用 DNSPOD 解析域名，参考http://jingyan.baidu.com/article/546ae1857c4ee81149f28cbe.html3.等待你的 DNS 配置生效对DNS的配置不是立即生效的，过10分钟再去访问你的域名看看有没有配置成功 : )","categories":[],"tags":[{"name":"git","slug":"git","permalink":"https://vlwq.github.io/tags/git/"}]},{"title":"gua5700","slug":"2016fe/20161115","date":"2016-11-15T02:36:00.000Z","updated":"2022-03-03T03:29:15.996Z","comments":true,"path":"2016/11/15/2016fe/20161115/","link":"","permalink":"https://vlwq.github.io/2016/11/15/2016fe/20161115/","excerpt":"5700奥义","text":"5700奥义 FE部分123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172173174175176177178179180181182183184185186187188189190191192193194195196197198199200201202203204205206207208209210211212213214215216217218219220221222223224225226227228229230231232233234235236237238239240241242243244245246247248249250251252253254255256257258259260261262263264265266267268269270271272273274275276277278279280281282283284285286287288289290291292293294295296297298299300301302303304305306307308309310311312313314315316317318319320321322323324325326327328329330331332333334HTML 部分localStorage 和 cookies// localStorage、 sessionStorage 与 cookies 的区别// localStorage 用于多页面通信FormData// 上传文件需要用到这个对象File API// 预览图片使用CSS 部分floatpositiondisplay flex (用 flexbox froggy 或者阮一峰的博客去学)水平居中 inline 的水平居中 block 的水平居中垂直居中 有完整的套路 父节点为 position: relative 自己为 position: absolute top: 50% transform: translateY(-50%)响应式设计移动开发 主要是微信网页开发JS 部分值类型与引用类型//var a = &#123; v: 1&#125;var b = aconsole.log(b.v)// 1a.v = 2console.log(b.v)// 2a = &#123; v: 3&#125;console.log(b.v)// 2// 变量声明提升(这是一个特性)// 这段代码console.log(a)var a = 1// 相当于var aconsole.log(a)a = 1// 所有以 function 函数名() &#123;&#125; 方式定义的函数都相当于提前定义了一遍// 这段代码console.log(b())function b() &#123; return 2&#125;// 相当于var b = function() &#123; return 2&#125;console.log(b())// 这段代码console.log(c())var c = function() &#123; return 3&#125;// 相当于var cconsole.log(c())c = function() &#123; return 3&#125;// 所以 console.log 会报错, 因为 c 在那个时候还不是一个函数, 只是 undefined// 注意，let 或者 const 声明的变量不具备 变量声明提升 的特性console.log(d)let d = 4// this//var x = 0function test() &#123; console.log(this.x)&#125;var o = &#123;&#125;o.x = 1o.m = testo.m()o[&#x27;m&#x27;]()o.m.apply()// apply 请看 apply bind call this 那节课// this + argumentsvar gua = &#x27;name 001&#x27;var foo = function()&#123; // arguments 并不是数组, 只是行为恰好和数组一样, 一般称为奇异数组 // 这个函数的 this 是 arguments console.log(arguments[&#x27;0&#x27;]()) // console.log(arguments[0]())&#125;var o = &#123;&#125;o.gua = &#x27;name 000&#x27;o.func = fooo.func(function()&#123; return this.gua&#125;)o.func2 = function()&#123; arguments.gua = &#x27;gua&#x27; // 这个函数的 this 是 arguments, 所以输出是 &#x27;gua&#x27; console.log(arguments[0]())&#125;o.func2(function()&#123; return this.gua&#125;)// prototype// 原型链//function Foo() &#123; this.name = &#x27;a&#x27;&#125;var f1 = new Foo()f1.name = &#x27;b&#x27;console.log(f1.name)var f2 = new Foo()console.log(f2.name)arguments//(function() &#123; return typeof arguments&#125;)()(function() &#123; console.log(arguments)&#125;)(1, 2, 3)(function(...args) &#123; console.log(args)&#125;)(1, 2, 3)call, apply, bind// call, apply 和 bind 的区别setTimeout 和 setInterval// 两者的区别setTimeout 与循环结合// 下面的输出全是 5, 因为引用的是 i 这个变量// 注意超时时间是 1000// 引用的 i 可以在函数内部访问到这件事称之为 闭包for(var i = 0; i &lt; 5; i++) &#123; setTimeout(function() &#123; console.log(new Date(), i) &#125;, 1000)&#125;console.log(new Date(), i)// 皇帝的闭包问题// 这根本不是闭包的问题// 因为 setTimeout 即便第二个参数是 0 也会在循环结束之后才执行函数// 所以 5 个输出都是 5for (var i = 0; i &lt; 5; i++) &#123; setTimeout(function() &#123; console.log(new Date(), i) &#125;, 0)&#125;for (let i = 0; i &lt; 5; i++) &#123; setTimeout(function() &#123; console.log(new Date(), i) &#125;, 0)&#125;let i = 0for (; i &lt; 5; i++) &#123; setTimeout(function() &#123; console.log(new Date(), i) &#125;, 0)&#125;事件冒泡, 事件捕获, 事件委托// 讲清楚这三个概念闭包// 所谓经典的闭包面试题(上面讲过的皇帝的闭包)// 使用闭包实现如下程序// 函数每调用一次，该函数的返回值加 1var foo = function()&#123; var i = 0 return function()&#123; i++ return i &#125;&#125;var a = foo()a()a()clone 和 deepClone// 实现 clone 和 deepClone 函数// 用 JSON.stringify 和 JSON.parse 实现 deepClone 是一个很有新意的方式// 具体实现会在 面试大全 里ajax（可能需要手写原生的 ajax）// 实现原生的 ajax 函数// readyState 0 1 2 3 4 各代表什么含义HTTP 请求方法, 常见状态码, 头部常见字段// HTTP 有哪些常见请求方法 GET POST PUT PATCH DELETE// HTTP 常见状态码有哪些 200 301 302 403 404 500 502// HTTP 头部常见字段有哪些 Content-Type Content-Length跨域 （jsonp, postMessage, cors, 用服务器(比如 node)转发请求和响应）// 跨域有哪些常见的解决方式网络安全: xss, csrf// xss 和 csrf 的原理是什么DOM 操作（查找, 添加, 删除, 修改）// DOM 查找/添加/删除/修改对应的 API 是什么jQuery 常见 API// jQuery 常见 API数据结构数组对象队列栈数组、对象、字符串的想换转化比如 a=1&amp;b=2&amp;c=3 怎样转成对象, 复习基础课程的作业就可以// 有这样一个 url： http://vip.qq.com/a.java?a=1&amp;b=2&amp;c=3&amp;d=xxx&amp;e// 写一段 JS 程序将 url 的参数转成对象的形式&#123; a: 1, b: 2, c: 3, d: &#x27;xxx&#x27;, e: &#x27;&#x27;,&#125;ES6ES6 的面试题一般是概念性质的, 所以清楚下面的概念就可以了let 和 const, 有一个 TDZ （暂时性死区的概念，了解下即可）箭头函数解构剩余参数(扩展符号)Promise, 可能会附带 async awaitclassSet// 用解构来简化参数列表var gua = function(&#123;name, height&#125;)&#123; console.log(name, height)&#125;var gua2 = function(info)&#123; console.log(info.name, info.height)&#125;var info = &#123; name: &#x27;gua&#x27;, height: 169,&#125;gua(info)React// React 也是概念性质的题目为主, 基本上不会考察写代码React Angular 这 2 个一般只会一个就可以的, 所以这里只说 React 的情况react 的广告virtual domdiff 算法的原理state 和 props组件生命周期组件通信：父组件 -&gt; 子组件, 子组件 -&gt; 父组件, A 组件 -&gt; B 组件React Router（react 路由）Redux/MobXreact ui 有两套很流行: Material UI 和 Ant Design, 国内流行的是 Ant Design 职业规划123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137写简历 个人基本信息(姓名 邮箱 手机) 技能 项目 教育经历 工作经验投简历 拉勾(假公司比较多, 100 中 5 差不多, 用小号投) boss 直聘, 野鸡比较多(100 中 5) 智联/51job(小城市) 原则是海投海面 不要有感情 注意不要被培训公司诈骗面试 记录面试情况, 有问题来找我反馈 反馈的时候要提供以下信息 1, 所在城市 2, 投递的简历数量 3, 面试次数 4, 面试遇到的问题工作1, 工作之后的规划 1) 规划跳槽, 从第一天起 规划好自己半年/一年后的状态 规划好达到那个状态需要做的计划 不要对公司/老板有盲目的感恩之心，互利双赢才能长久 要以自己的规划为主 2) 要设定职业规划, 探索职业方向 要照顾到自己的喜好, 做喜欢的事情 要保护好自己的热情(做喜欢的事情, 尽量避免被公司业务污染) 要符合自己的意义 公务员的工作有意义，但是你不认同也会做着痛苦 3) 认清自己的地位 你做了自己的选择，并不只是运气好 你只是一个流水线工人 一个公司相当于一个作坊, 由 前端/后端/设计/产品/测试 合作完成一个东西 资深工人 多工种工人 4) 个人增值的方式 把某个技术做精, 变成专家级流水工 坏处就是万一被淘汰就跪了 还有就是鸡蛋放到一个篮子里面了 选择的空间也少, 比如 nokia 和 moto 被裁员的员工 为了避免这个窘况, 大家要做流行性高/通用性强的方向 ios 安卓 就不行 web 更长青 编程能力是最重要的，切换语言很简单 市场如果有需求，一夜之间千万 xx 语言码农就出来了 横跨多个领域, 做复合型掏粪工 比如全栈, 就是典型的复合型掏粪工( node.js ) 掏得越多越好 越快越好 node 是趋势 前端没理由去接触别的语言 比如技术和其他领域的结合 软件 + 医疗 互联网 +2, 学习的计划 合理正确的规划方式 时间不要贪多, 以自己能接受为前提, 从小到大慢慢提高 计划太多学不完 学不完有负罪感 然后就炸了 所以要慢慢来，遵循客观规律 不要妄自菲薄（我自控力差，我做不好事） 目标要细化, 最好是把事情分解为 20 分钟甚至 10 分钟能解决的程度 目标大了就会拖，拖了就做不完 把目标写下来 一条条做 要合理看待不能完成的任务, 要有标准化的预案 比如超过设定的极限时间不能解决就提问 避免买包出斧心理 买包就是试图付出 xx 资源来得到 yy 好处（无视客观规律） 出斧就是情绪驱动，不按照客观规律做事 不要试图通过去学一些奇怪的东西来提高能力 我要看原版书，我看原版书，得到原汁原味的知识 有些东西英语就是英语，用中文是无法表达的 我要学 java 我要学人工智能 我要学底层（什么是底层？） 不要被情绪驱动, 要按照计划来做事/学习 不能说今晚做不出就不睡 不能说我一定要自己想出来才是我的，该问就问3, 前端知识点的聚合 react grunt gulp webpack babel es6 less sass 这些都是花哨的名词而已 都可以通过 阮一峰 的网站来了解 仅限于阮一峰的网站中介绍的内容，其他一概忽略 最重要的还是 js 编程能力 比如不断地练习写程序来提高 比如通过阅读《代码大全》这样的经典书籍来提高 这本书可以随机读自己喜欢的章节 编程能力在不同语言之间是互通的 其次是 html 和 css 的运用能力 多写 多抄 多看书 任何工具都只是帮助你更好更方便地构建网站, 本质还是写网页4, 其他 倍速视频 节约时间 集中精力 论坛提问的表格具有很高的价值, 要善加利用 比提问的智慧简单很多 是长期实践中归纳总结出来的方法 怎样选择要读的书(不限于技术书) 绝大部分书都是垃圾 即便是好书, 大部分内容很可能也没什么用 粗读, 不要精读 绝不要去读原版 这些是我长期实践的总结，仅供参考 更多的训练项目 electron 视频播放器 天气应用 计算器 浏览器插件（GIF ZhiHu） 爬虫 爬虫结果的图表化数据分析（数据可视化、数据分析） markdown 编辑器 美味便签 小游戏(phaser.js 网站上学习) HTTP 协议(主要用在 AJAX 上) 用到再学 改键位和快捷键 https://zhuanlan.zhihu.com/p/24020977 KISS keep it simple stupid 要把事情做得简单(一个函数简短 并且完成一个功能) DRY dont repeat yourself 不要写重复代码*/","categories":[],"tags":[{"name":"FE","slug":"FE","permalink":"https://vlwq.github.io/tags/FE/"}]},{"title":"gua.js","slug":"2016fe/20161112","date":"2016-11-12T02:36:00.000Z","updated":"2022-03-03T03:28:58.752Z","comments":true,"path":"2016/11/12/2016fe/20161112/","link":"","permalink":"https://vlwq.github.io/2016/11/12/2016fe/20161112/","excerpt":"备份","text":"备份 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130var log = function() &#123; console.log.apply(console, arguments)&#125;var e = function(selector) &#123; return document.querySelector(selector)&#125;var es = function (selector) &#123; return document.querySelectorAll(selector)&#125;var appendHtml = function(element, html) &#123; element.insertAdjacentHTML(&#x27;beforeend&#x27;, html)&#125;var bindEvent = function(element, eventName, callback) &#123; element.addEventListener(eventName, callback)&#125;var toggleClass = function(element, className) &#123; if (element.classList.contains(className)) &#123; element.classList.remove(className) &#125; else &#123; element.classList.add(className) &#125;&#125;var removeClassAll = function(className) &#123; var selector = &#x27;.&#x27; + className var elements = document.querySelectorAll(selector) for (var i = 0; i &lt; elements.length; i++) &#123; var e = elements[i] e.classList.remove(className) &#125;&#125;var bindAll = function(selector, eventName, callback) &#123; var elements = document.querySelectorAll(selector) for(var i = 0; i &lt; elements.length; i++) &#123; var e = elements[i] bindEvent(e, eventName, callback) &#125;&#125;// find 函数可以查找 element 的所有子元素var find = function(element, selector) &#123; return element.querySelector(selector)&#125;var closestClass = function(element, className) &#123; var e = element while (e != null) &#123; if (e.classList.contains(className)) &#123; return e &#125; else &#123; e = e.parentElement &#125; &#125;&#125;var closestId = function(element, idName)&#123; /* element 是一个 DOM 元素 idName 是一个 string 循环查找 element 的直系父元素 如果父元素拥有 idName 这个 id, 则返回这个父元素 如果找到 document 都还没有, 则返回 null */ var e = element while (e != null) &#123; // 判断 e 是否包含 idName 这个 id if (e.id == idName) &#123; return e &#125; else &#123; e = e.parentElement &#125; &#125;&#125;var closestTag = function(element, tagName)&#123; /* element 是一个 DOM 元素 tagName 是一个 string 循环查找 element 的直系父元素 如果父元素是一个 tagName 标签, 则返回这个父元素 如果找到 document 都还没有, 则返回 null tagName 是 &#x27;div&#x27; &#x27;p&#x27; &#x27;h1&#x27; 这样的标签名 获取一个 DOM 元素的标签名的方法如下 element.tagName 需要注意的是, tagName 属性返回的标签名是大写的 例如 &#x27;DIV&#x27; &#x27;H1&#x27; 所以你在比较的时候需要把 tagName 转换为大写字母 使用如下 js 标准库函数转换 tagName.toUpperCase() */ var e = element while (e != null) &#123; // 判断 e 是否和 tagName 相等 if (e.tagName.toUpperCase() == idName.toUpperCase()) &#123; return e &#125; else &#123; e = e.parentElement &#125; &#125;&#125;var closest = function(element, selector)&#123; /* element 是一个 DOM 元素 selector 是一个 string, 表示一个选择器 可能的值是 &#x27;div&#x27; &#x27;#id-div-gua&#x27; &#x27;.red&#x27; 这三种 循环查找 element 的直系父元素 如果父元素符合选择器, 则返回这个父元素 如果找到 document 都还没有, 则返回 null */ var flag = selector[0] if (flag == &#x27;.&#x27;) &#123; var className = selector.slice(1) return closestClass(element, className) &#125; else if (flag == &#x27;#&#x27;) &#123; var idName = selector.slice(1) return closestId(element, idName) &#125; else &#123; var tag = selector return closestId(element, tag) &#125;&#125;","categories":[],"tags":[{"name":"FE","slug":"FE","permalink":"https://vlwq.github.io/tags/FE/"}]},{"title":"guajs简单版本","slug":"2016fe/20161111","date":"2016-11-11T02:36:00.000Z","updated":"2022-03-03T03:28:24.995Z","comments":true,"path":"2016/11/11/2016fe/20161111/","link":"","permalink":"https://vlwq.github.io/2016/11/11/2016fe/20161111/","excerpt":"guajs简单版本，备用工具","text":"guajs简单版本，备用工具 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354var log = function() &#123; console.log.apply(console, arguments)&#125;var e = function(selector) &#123; return document.querySelector(selector)&#125;var es = function(selector) &#123; return document.querySelectorAll(selector)&#125;var appendHtml = function(element, html) &#123; element.insertAdjacentHTML(&#x27;beforeend&#x27;, html)&#125;var bindEvent = function(element, eventName, callback) &#123; element.addEventListener(eventName, callback)&#125;var toggleClass = function(element, className) &#123; if (element.classList.contains(className)) &#123; element.classList.remove(className) &#125; else &#123; element.classList.add(className) &#125;&#125;var removeClassAll = function(className) &#123; var selector = &#x27;.&#x27; + className var elements = document.querySelectorAll(selector) for (var i = 0; i &lt; elements.length; i++) &#123; var e = elements[i] e.classList.remove(className) &#125;&#125;var bindAll = function(selector, eventName, callback) &#123; var elements = document.querySelectorAll(selector) for(var i = 0; i &lt; elements.length; i++) &#123; var e = elements[i] bindEvent(e, eventName, callback) &#125;&#125;// find 函数可以查找 element 的子元素var find = function(element, selector) &#123; return element.querySelector(selector)&#125;// find 函数可以查找 element 的所有子元素var findAll = function(element, selector) &#123; return element.querySelectorAll(selector)&#125;","categories":[],"tags":[{"name":"FE","slug":"FE","permalink":"https://vlwq.github.io/tags/FE/"}]},{"title":"js同步异步","slug":"2016fe/20161110","date":"2016-11-10T02:36:00.000Z","updated":"2022-03-03T03:28:18.512Z","comments":true,"path":"2016/11/10/2016fe/20161110/","link":"","permalink":"https://vlwq.github.io/2016/11/10/2016fe/20161110/","excerpt":"guasync file&#x2F;* 同步和异步编程的概念 同步的意思是 函数通过返回值来传递数据 函数从获取数据一直到返回数据之间的时间一直在等待 异步的意思是 函数通过回调函数的方式来传递获取的数据 函数执行后立刻就返回了, 数据获取成功后, 调用回调函数并传递参数 *&#x2F;","text":"guasync file&#x2F;* 同步和异步编程的概念 同步的意思是 函数通过返回值来传递数据 函数从获取数据一直到返回数据之间的时间一直在等待 异步的意思是 函数通过回调函数的方式来传递获取的数据 函数执行后立刻就返回了, 数据获取成功后, 调用回调函数并传递参数 *&#x2F; 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859var fs = require(&#x27;fs&#x27;)var log = console.log.bind(console, &#x27;---&#x27;)// 我们先写入文件// 写入成功后 读取当前目录看是否有这个文件// 如果有这个文件, 我们读取文件的内容并打印出来// 然后我们删除这个文件var filename = &#x27;message.txt&#x27;console.log(&#x27;写入前&#x27;)fs.writeFile(filename, &#x27;你好 Node.js&#x27;, (err) =&gt; &#123; fs.readdir(&#x27;.&#x27;, function(err, files)&#123; console.log(&#x27;读取文件成功 files&#x27;, files) if(files.includes(filename)) &#123; fs.readFile(filename, (err, data) =&gt; &#123; // 读取文件成功, 打印并删除文件, data 并不是 string 而是一个 Buffer 对象(以后会讲) console.log(&#x27;读取成功&#x27;, data) fs.unlink(filename, (err) =&gt; &#123; console.log(`最后一步, 文件 $&#123;filename&#125; 成功删除`) &#125;) &#125;) &#125; &#125;)&#125;)console.log(&#x27;写入函数调用后&#x27;)var guasync = function(callback) &#123; // setTimeout 函数一定会把第一个参数放到后台去执行 setTimeout(function() &#123; callback() &#125;, 0)&#125;var processFiles = function() &#123; var filename = &#x27;guasync.txt&#x27; log(&#x27;同步写入前&#x27;) fs.writeFileSync(filename, &#x27;你好 同步 api&#x27;) var files = fs.readdirSync(&#x27;.&#x27;) console.log(&#x27;读取文件成功 files&#x27;, files) if(files.includes(filename)) &#123; var data = fs.readFileSync(filename) console.log(&#x27;读取成功&#x27;, data) fs.unlinkSync(filename) console.log(`最后一步, 文件 $&#123;filename&#125; 成功删除`) &#125; log(&#x27;同步写入完成后&#x27;)&#125;// http://www.kuaidadi.com/assets/js/animate.jsguasync(function () &#123; processFiles()&#125;)log(&#x27;干点别的事情&#x27;)// guasync(function() &#123;// step1()// step2()// &#125;) guasync ajax1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253var log = console.log.bind(console)var ajax = function(request) &#123; /* request 是一个 object, 有如下属性 method, 请求的方法, string url, 请求的路径, string data, 请求发送的数据, 如果是 GET 方法则没这个值, string callback, 响应回调, function 本题不会就放弃, 本题带了一个用法在下方 */ var data = null var r = new XMLHttpRequest() r.open(request.method, request.url, false) r.setRequestHeader(&#x27;Content-Type&#x27;, request.contentType) r.onreadystatechange = function(event) &#123; if(r.readyState === 4) &#123; log(&#x27;ajax 状态 4 准备执行 callback&#x27;) data = r.response // request.callback(r.response) &#125; &#125; if (request.method === &#x27;GET&#x27;) &#123; r.send() &#125; else &#123; r.send(request.data) &#125; return data&#125;var request = &#123; method: &#x27;GET&#x27;, url: &#x27;https://vip.cocode.cc/sandbox/todo/3400711034/all&#x27;, callback: function (r) &#123; log(&#x27;响应完成 callback&#x27;) &#125;&#125;var guasync = function(callback) &#123; // setTimeout 函数一定会把第一个参数放到后台去执行 setTimeout(function() &#123; callback() &#125;, 0)&#125;guasync(function() &#123; log(&#x27;ajax 开始&#x27;) var data = ajax(request) log(&#x27;ajax 结束&#x27;, data)&#125;)log(&#x27;guasync 结束&#x27;)","categories":[],"tags":[{"name":"FE","slug":"FE","permalink":"https://vlwq.github.io/tags/FE/"}]},{"title":"HTML5 新内容","slug":"2016fe/20161109","date":"2016-11-09T02:36:00.000Z","updated":"2022-03-03T03:28:13.546Z","comments":true,"path":"2016/11/09/2016fe/20161109/","link":"","permalink":"https://vlwq.github.io/2016/11/09/2016fe/20161109/","excerpt":"HTML5 新内容主要是以下几点 语义化标签如 article、footer、header、nav、section视频和音频标签 video 和 audio本地离线存储 localStorage 和 sessionStorage新增表单特性如新控件 calendar email color 等用于绘图的 canvas 标签(用于游戏等)用于高性能图形的 WebGL(用于游戏等, 这个是专用领域的知识, 我们不会直接接触)","text":"HTML5 新内容主要是以下几点 语义化标签如 article、footer、header、nav、section视频和音频标签 video 和 audio本地离线存储 localStorage 和 sessionStorage新增表单特性如新控件 calendar email color 等用于绘图的 canvas 标签(用于游戏等)用于高性能图形的 WebGL(用于游戏等, 这个是专用领域的知识, 我们不会直接接触) HTML5 语义化 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071727374757677787980818283848586878889909192939495969798原来的标签&lt;div id=&quot;wrapper&quot;&gt; &lt;div id=&quot;header&quot;&gt;&lt;/div&gt; &lt;div id=&quot;main&quot;&gt; &lt;div id=&quot;sidebar&quot;&gt;&lt;/div&gt; &lt;div id=&quot;content&quot;&gt;&lt;/div&gt; &lt;/div&gt; &lt;div id=&quot;footer&quot;&gt;&lt;/div&gt;&lt;/div&gt;完整的 html5 语义化标签是这样的&lt;!DOCTYPE html&gt;&lt;html&gt; &lt;title&gt;标题&lt;/title&gt; &lt;body&gt; &lt;header&gt;&lt;/header&gt; &lt;nav&gt;导航&lt;/nav&gt; &lt;article&gt; &lt;section&gt;区块&lt;/section&gt; &lt;/article&gt; &lt;aside&gt;侧栏&lt;/aside&gt; &lt;footer&gt;页脚&lt;/footer&gt; &lt;/body&gt;&lt;/html&gt;&lt;div class=&#x27;article&#x27;&gt; &lt;div class=&#x27;title&#x27;&gt; 前端掏粪指南 &lt;/div&gt; &lt;div class=&#x27;content&#x27;&gt; 前端掏粪指南 前端掏粪指南 前端掏粪指南 前端掏粪指南 前端掏粪指南 前端掏粪指南 前端掏粪指南 &lt;/div&gt;&lt;/div&gt;&lt;div class=&#x27;article&#x27;&gt; &lt;h1 class=&#x27;title&#x27;&gt; 前端掏粪指南 &lt;/h1&gt; &lt;p class=&#x27;content&#x27;&gt; 前端掏粪指南 前端掏粪指南 前端掏粪指南 前端掏粪指南 前端掏粪指南 前端掏粪指南 前端掏粪指南 &lt;/p&gt; &lt;gua&gt;&lt;/gua&gt;&lt;/div&gt;gua &#123; display: inline-block; width: 42px; height: 42px; background: url(&#x27;gua.png&#x27;);&#125;视频和音频标签和配套的 JS API 是新加入的功能以前的话只能依赖 flash, 现在有 video 和 audio带控制器的视频标签, 不同浏览器有不同的文件格式要求所以用 2 个 source 标签指定不同的视频格式&lt;video width=&quot;300&quot; height=&quot;200&quot; controls=&quot;controls&quot;&gt; &lt;source src=&quot;movie.mp4&quot;&gt; &lt;source src=&quot;movie.ogv&quot;&gt;&lt;/video&gt;带控制器的音频标签, 不同浏览器有不同的文件格式要求所以用 2 个 source 标签指定不同的音频格式&lt;audio id=&#x27;id-audio-player&#x27; controls=&quot;controls&quot;&gt; &lt;source src=&quot;audio.ogg&quot;&gt; &lt;source src=&quot;audio.mp3&quot;&gt;&lt;/audio &gt;audio 基本操作如下var a = document.querySelector(&#x27;#id-audio-player&#x27;)a.play() // 播放a.pause() // 暂停a.autoplay // bool 属性a.src // 音乐文件的地址a.volume // 音量, 0 - 1.0a.duration // 时长, 秒为单位a.currentTime = 1 // 当前播放时间, 秒为单位a.playbackRate // 播放速率, 默认为 1官方文档如下(文档永远是这样的)https://developer.mozilla.org/en/docs/Web/HTML/Element/audio HTML5 提供两种存储方法 localStorage 与 sessionStoragelocalStorage 与 sessionStorage 都是用来存储数据的使用方式一样, 区别只在于过期时间localStorage 没有过期时间, 要用 clear remove 主动删除数据sessionStorage 的数据在用户关闭浏览器后将被删除 由于之前有使用, 这里就不讲了 1234567891011121314新增表单特性如控件 calendar email color 等&lt;input type=&#x27;calendar&#x27;&gt;boolean 值的属性只要写了属性就是 truefalse&lt;input type=&quot;checkbox&quot;&gt;true&lt;input type=&quot;checkbox&quot; checked&gt;&lt;input type=&quot;checkbox&quot; checked=&quot;checked&quot;&gt;&lt;input type=&quot;checkbox&quot; checked=&quot;&quot;&gt;&lt;input type=&quot;checkbox&quot; checked=&quot;false&quot;&gt; 用于绘图的 canvas 标签(用于游戏等)canvas 标签提供一块画布, 可以访问画布中的像素点主要用途是游戏或者是高级复杂的图形效果例如 particles.js phaser.js 这些库, 例子如下https://phaser.io/examples/v2/weapon/fire-rate 移动网页手机网页和电脑网页的技术是一样的区别仅在屏幕尺寸和交互方式下面只列出手机页面开发中重要的点 1234567891011121 设置 viewportviewport 是 html 的父元素在手机上需要用下面的语句设置它的尺寸&lt;meta name=&quot;viewport&quot; content=&quot;width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no&quot;&gt;属性解释width=device-width 宽度等于设备宽度height=device-height 高度等于设备高度initial-scale 初始缩放比例minimum-scale 允许用户缩放的最小比例maximum-scale 允许用户缩放的最大比例user-scalable 是否允许用户缩放 2 调试页面可以用 chrome 的开发工具调试手机页面但是由于浏览器兼容性问题, 最终的外观得用手机真机来检验标签&#x2F;css 的兼容性问题有很多网站可以查询比如下面这个网站caniuse.com 3 媒体查询媒体查询实际上是用来做响应式设计的响应式设计就是一套 CSS 根据当前的分辨率选择不同的样式现在已经没有前几年那么热门了, 不过我们还是过一遍 媒体查询主要用来: 检测媒体的类型, 比如 screen, tv等 检测布局视口的特性, 比如视口的宽高分辨率等123456用法@media all and (min-width: 200px) and (max-width: 300px)&#123; body &#123; background: red; &#125;&#125; 上面代码中, all 是媒体类型, 代表任何设备and 是逻辑操作意思是, 对于任何设备, 在宽度在 200-300 的范围内应用这个样式 4 Hybrid App(混合开发)混合开发说的是, 你写的网页运行在手机程序里本来网页能提供的功能是有限的但是应用程序可以给页面添加函数在这种情况下, js 就可以调用别人提供的功能这就是混合开发的基础 比如你 js 不能实现让手机震动的功能但是别的程序能实现这个功能, 并且把这个功能注册为你网页中的一个 js 函数这样 js 也就拥有这个功能了然后你调用 vfds() 就让手机震动了 这样的效果就是原生代码(相对于 js 而言的官方开发语言)实现功能并且提供 js 函数js 代码用别人提供的功能写逻辑 说穿了就这么一回事, 无任何难度的普通掏粪而已","categories":[],"tags":[{"name":"FE","slug":"FE","permalink":"https://vlwq.github.io/tags/FE/"}]},{"title":"linux相关","slug":"2016linux/20161108","date":"2016-11-08T02:36:00.000Z","updated":"2022-03-03T03:15:33.823Z","comments":true,"path":"2016/11/08/2016linux/20161108/","link":"","permalink":"https://vlwq.github.io/2016/11/08/2016linux/20161108/","excerpt":"Linux 服务器介绍和使用常用 Linux 版本分析常用工具&#x2F;概念&#x2F;使用方式以前和现在的服务器(托管和云平台)服务器配置部署项目","text":"Linux 服务器介绍和使用常用 Linux 版本分析常用工具&#x2F;概念&#x2F;使用方式以前和现在的服务器(托管和云平台)服务器配置部署项目 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172173174175176177178179180181182183184185186187188189190191192193194195196197198199200201202203204205206207208209210211212213214215216217218219220221222223224225226227228229230231232233234235236237238239240241242243244245246247248249250251252253254255256257258259260261262263264265266267268269270271272273274275276277278279280281282283284285286287288289290291292293294295296297298299300301302303304305306307308309310311312313314315316317318319320321322323324325326327328329330331332333334335336337338339340341342343344345346347348349350351352353354355356357358359360361362363364365366367368369370371372373374375376377378379380381382383384385386387388389390391392393394395396397398399400401402403404405406407408409410411412413414415416417418419420421422423424425426427域名购买(腾讯云买 .cc 域名)VPS购买, 可以用下面的服务(论坛使用的主机商), 2.5刀/月的即可http://www.vultr.com/?ref=6991688 地址选 日本, 如果不能访问, 那么就删除再新建一个为什么服务器多用 Linux? 微软很贵, Linux 免费Linux 生态圈更好Linux 的各种版本分析Debian 最好的 最稳定Ubuntu 抄的 debian, 用途广泛, 用户多(我们用的是 ubuntu 1604)CentOS 垃圾 工具老旧, 使用不方便连接服务器推荐使用 cmder 软件(windows下)如果在 mac 下, 直接用终端连接系统配置程序安装PATH命令参数权限用户用户组常用操作pwdprint working dir显示现在所处的目录ls不带参数就显示当前目录下的所有文件程序可以加选项-l 显示详细信息-h 人性化显示文件尺寸-a 显示所有文件， 以 . 开头的文件是隐藏文件还可以带一个目录当参数，这样就会显示这个目录ls /usr下面两个是等价的ls -l -hls -lh输入命令时, 可以用 tab 补全cdcd /usr改变当前目录 . 代表当前目录 .. 代表上级目录cd 不带参数就回到默认的家目录, 与 cd ~ 的效果是一样的每个用户都有一个家目录，默认在 /home/用户名root 用户的家目录是 /root我们可以在 linux 命令行中使用 nano 这个编辑器, 很方便操作文件与目录cp复制出一个文件，用法如下cp a.txt b.txt复制 a.txt 并把新文件取名为 b.txt复制目录要加上 -r 参数cp -r a bmkdir创建一个目录-p 可以一次性创建多层目录mkdir -p a/b/crmdir只能用来删除一个空目录rm这个命令直接删除东西，很危险，一般不要用删除文件或者目录-f 强制删除-r 用来递归删除目录mv移动文件或者文件夹也可以用来改名mv a.txt b.txtmv b.txt ../mv b.txt ../gua.txt可以用 mv xx /tmp 的方式来将文件放入临时文件夹（/tmp是操作系统提供的临时文件夹，重启会删除里面的所有文件）ls -l /usr/bin/ &gt; b.txtcat显示文件内容tac反过来显示文件内容nl显示内容并附带行号more less head tailmore 可以分屏分批看文件内容less 比 more 更高级，可以前后退看文件h 显示屏幕帮助, q 退出 less 程序head 可以显示文件的前 10 行tail 可以显示文件的后 10 行head 和 tail 有一个 -n 参数head -n 20 a.guatouchtouch a.gua如果 a.gua 存在就更新修改时间如果 a.gua 不存在就创建文件权限操作腾讯主机默认是用 ubuntu 这个用户登录, 为了方便操作, 统一选择 root 用户登录sudo用管理员帐户执行程序比如安装程序或者修改一些系统配置都需要管理员权限文件权限 文件类型 用户 用户组 文件大小 修改日期 文件名-rw-r--r-- 1 root root 45 May 24 10:17 lazy_dog.txt-rw-r--r-- 1 root root 56 May 24 09:47 ls-error.txt-rw-r--r-- 1 root root 30 May 24 09:45 ls-output.txtdrwxr-xr-x 4 root root 4096 May 24 03:37 node9 drwxr-xr-x 第一位是表示文件类型, 后面每三位分为一组, 每组表示的权限意思是一样的文件类型 是否可读 是否可写 是否可执行d r w x- r w x其中 d 表示 目录 directory, - 表示普通文件三组 rwx 分表代表 所属用户|同组用户(文件所属的群组)|其他用户rwx 可以用数字表示为 421777 表示三组都是 rwx rwx rwx也就是 -rwxrwxrwx每一位使用的是 2 进制数字表示210于是乎r-- 就是 4rw- 就是 6rwx 就是 7r-x 就是 5-rw-rw-r-- 文件的访问权限1 文件的链接数目(这个不用关心)root 文件所有者的用户名root 文件所属用户组10 文件大小（单位是字节）11/09 20:28 上次修改文件的日期和时间b.gua 文件名// 我们只考虑一个 root 用户的情况, 所以这部分不演示了, 直接跳过chown改变文件的用户chown gua c.guachown gua:gua c.guachmod改变文件权限666 这种表示按照 8 进制数字更改, 换成字符就是 rw- rw- rw-u user 表示文件所有者g group 表示文件所属群组o others 表示其他用户a all 表示 ugo 的组合+x 表示添加 x 权限, 等价于 a+x, 文件所有者/文件所属群组/其他用户都添加 x 权限-x 表示减少 x 权限chmod 666 a.txtchmod +x b.txtchmod -x tmp信息查找file显示文件的类型（不是百分之百准确）uname显示操作系统的名字或者其他信息uname -runame -awhichwhich perl有时候开发语言里会提到 3p, 也就是 perl php pythonwhich pwd显示 pwd 的具体路径whereiswhereis ls显示更全面的信息whoamifind . -name &quot;&quot;奇怪符号~ 家目录快捷方式&gt; 覆盖式重定向&gt;&gt; 追加重定向| 管道, 很麻烦 以后说`` 获取命令执行的结果比如 echo pwd 输出的就是 pwd 这个字符串echo `pwd` 输出的是 pwd 命令执行的结果, 相当于一个变量&amp; 后台执行node app.js &amp;可以用 fg 命令把一个在后台的程序拉到前台来可以用 Ctrl-z 来把一个前台的程序放到后台去挂起() 开新的子进程shell执行(不用掌握这一条, 因为几乎没人用)history查看历史命令grep查找这两个一般配合使用history | grep touchps查看进程, 一般用下面的用法ps axps ax | grep node查看带 node 字符串的进程kill 和 killall 杀进程用 ps ax 找到进程id (pid)kill [pid]kill -9 [pid]kill -15 [pid]killall 是用进程名字来杀进程后台前台fgjobs快捷键C-z 把正在运行的程序挂起并放在后台C-c 中断程序的执行C-d 输入文件终止符(end of file, EOF)比如输入 cat(不带参数), 会等待着从键盘输入内容hello输入 Ctrl-d 后会结束输入输入快捷键C-t 交换光标前面的两个字符(只在终端有效)C-w 一次删除一个单词C-u 一次删除一行（从光标删除到行首）C-k 从光标删除到行尾C-d 删除后一个字符C-h 删除前一个字符C-f forward 往前 就是右C-b backward 往后 就是左箭头C-p pres 往上 就是上箭头C-n next 往下 就是下箭头C-a 光标回到行首C-e 光标跳到行尾快捷键C-z 挂起到后台C-c 中断程序reboot重启shutdown关机可以用参数指定时间halt关机配置服务器免登陆设置ssh-key===生成 ssh-key===*** 注意, 不懂就在群里问Mac 用户直接打开终端输入命令Win 打开 cmder 程序, 在里面输入下面的命令1. 在本机生成 ssh key 公钥私钥注意 下面的 mykey 随便换一个你喜欢的名字, 这是一个标注, 方便你看的ssh-keygen -C &lt;mykey&gt;会提示你生成的文件的地址, 并且让你输入密码, 你不要输入密码, 直接回车这样你就得到了一对 ssh-key, 这是用于登录服务器用的默认你会得到两个文件id_rsa 是私钥 自己保存 不要给别人看id_rsa.pub 是公钥, 是要到处使用的这个是我们之前提到的非对称加密===重建服务器并且配置 ssh-key===去 vultr 的管理界面先删除(Destory)现有的服务器新建服务器的时候, 把刚才生成的 id_rsa.pub 文件(用 atom/webstorm 可以打开)里面的内容加入到 ssh-key 步骤中这样你就可以不用密码, 自动登录服务器了// 如果你不想重建服务器, 配置 ssh-key 的方法如下// 在服务器把本机生成的 public key 添加到 /root/.ssh/authorized_keys 文件中// 1 用 root 用户登录到服务器, 创建 .ssh 目录cd /rootmkdir .ssh// 2 编辑 authorized_keys 文件, 把刚才生成的 id_rsa.pub 文件里面的内容粘贴进去并保存退出// 注意, 这里可以粘贴多个 key, 一行一个nano .ssh/authorized_keys// 安装必备软件// 安装 oh-my-zsh 配置(方便你使用命令行的配置)wget https://github.com/robbyrussell/oh-my-zsh/raw/master/tools/install.sh -O - | sh// 安装防火墙 和 防火墙的基本套路配置// 防火墙的作用(redis安全漏洞)apt-get install ufwufw allow 22ufw allow 80ufw allow 443ufw allow 3000ufw allow 8090/8388(这个是留给飞机用的端口)ufw default deny incomingufw default allow outgoingufw status verboseufw enable部署项目软件安装====安装 git nginxapt-get install git nginxubuntu 的软件仓库中的 nodejs 更新很慢, 几乎可以认为不可用,所以我们从 nodeSource 仓库中安装新款 nodejs配置 nodeSource 仓库curl -sL https://deb.nodesource.com/setup_7.x | sudo -E bash -配置之后就可以安装最新的 nodejsapt-get install nodejs安装 yarnnpm install yarn -g(这个官网不推荐) curl -sS https://dl.yarnpkg.com/debian/pubkey.gpg | sudo apt-key add - echo &quot;deb https://dl.yarnpkg.com/debian/ stable main&quot; | sudo tee /etc/apt/sources.list.d/yarn.list sudo apt-get update &amp;&amp; sudo apt-get install yarn用 git pull 项目用 sourcetree安装依赖yarn install配置 nginxln -s /var/www/weibo/weibo.nginx /etc/nginx/sites-enabled/weibo` 这部分和部署无关列出 nginx/sites-enabled 下面的文件root@linlab:~# ls -l /etc/nginx/sites-enabled/第一个字母是 l, 这个表示 weibo 是一个软链接, 当访问 weibo 时,实际上访问的是 /var/www/weibo/weibo.nginx这样做的好处是我们只需要更新 weibo.nginx 就可以软链接类似 windows 下的快捷方式lrwxrwxrwx 1 root root 26 May 23 14:09 weibo -&gt; /var/www/weibo/weibo.nginx`移除默认的配置文件mv /etc/nginx/sites-enabled/default /tmp重启 nginxservice nginx restart运行程序yarn run start安装 pm2yarn global add pm2pm2 日志/root/.pm2/logs 文件夹会包含所有应用的日志实时日志命令pm2 logs我们已经有 node 的情况下, 为什么要用 nginx1. node 性能是不如 nginx 的, nginx 处理静态文件的性能非常高2. nginx 接收 80 端口的请求(来自用户的请求), 然后转发给各个 app.js(app.js实际上是应用服务器, 也就是我们常说的框架)3. nginx 是使用非常广泛的静态服务器, 安全性方面是非常好的 给静态资源增加一个路由，如果发现请求是静态资源， nginx直接处理, 不用让node来处理，可以这么理解吗 当然可以, 这个是完全正确的1. 高性能的静态服务器 nginx nginx nginx nginx nginx2. 高性能的网络(?)服务器 node gunicorn unicorn tomcat/jetty3. 一般性能的开发服务器 node app app app// ===// 服务器中文编码问题// ===//// 编辑下面的文件, 不要拼错nano /etc/environment// 加入下面的内容, 保存退出LC_CTYPE=&quot;en_US.UTF-8&quot;LC_ALL=&quot;en_US.UTF-8&quot;*/","categories":[],"tags":[{"name":"linux","slug":"linux","permalink":"https://vlwq.github.io/tags/linux/"}]},{"title":"数据结构与算法","slug":"2016fe/20161107","date":"2016-11-07T02:36:00.000Z","updated":"2022-03-03T03:27:34.984Z","comments":true,"path":"2016/11/07/2016fe/20161107/","link":"","permalink":"https://vlwq.github.io/2016/11/07/2016fe/20161107/","excerpt":"","text":"123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172173174175176177178179180181182183184185186187188189190191192193194195196197198199200201202203204205206207208209210211212213214215216217218219220221222223224225226227228229230231232233234235236237238239240241242243244245246247248249250251252253254255256257258259260261262263264265266267268269270271272273274275276277278279280281282283284285286287288289290291292293294295296297298299300301302303304305306307308309310311312313314315316317318319320321322323324325326327328329330331332333334335336337338339340341342343344345346// 数据结构与算法分析/*数据结构就是存储数据的方式算法分析是对一个算法的时间的大略估计算法是有特定的套路的了解 5 种时间复杂度即可*/// 时间、空间复杂度(空间复杂度一般不考虑)// 复杂度是对一个操作的大致估计// 复杂度从小到大依次如下&lt;!-- more --&gt;/*五种常见时间复杂度复杂度用 大 O 记法 来描述(大 O 记法是描述算法复杂度的符号)O(1) 常数复杂度，最快速的算法。 求数组前 10000 个元素的和 字典和集合的存取都是 O(1) 数组的存取是 O(1)O(lgN) 对数复杂度 假设有一个有序数组，以二分法查找O(n) 线性复杂度 假设有一个数组，以遍历的方式在其中查找元素O(NlogN) 求两个数组交集，其中一个是有序数组 假设 A 数组的长度是 M, 无序 假设 B 数组的长度是 N, 有序 A 数组每一个元素都要在 B 数组中进行查找操作 每次查找如果使用二分法则复杂度是 lgN 加起来就是 M * lgN 所以时间复杂度是 NlogNO(N²) 平方复杂度 求两个无序数组的交集 假设 A 数组的长度是 M, 无序 假设 B 数组的长度是 N, 无序 A 数组每一个元素都要在 B 数组中进行查找操作 每次查找只能使用遍历操作, 所以每次查找都是 N 加起来就是 M * N 所以时间复杂度是 N²*//*数据结构===针对常用的操作，我们发明了一套常用的数据结构四大数据结构1，数组 连续的一块内存 读取元素时间是 O(1) 插入、删除是 O(n)2，链表 手拉手的盒子，一个盒子只能访问左右手的盒子 以下标方式读取元素的时间是 O(n) 插入、删除是 O(1) 栈和队列是链表的特定场景应用(当然, 不用链表也能实现栈和队列)3，字典(Hash Table 哈希表) 把字符串转为数字作为下标存储到数组中 字符串转化为数字的算法是 O(1) 所以字典的存取操作都是 O(1) 除非对数据有顺序要求，否则字典永远是最佳选择 字符串转化为数字的算法 1，确定数据规模，这样可以确定容器数组的大小 Size 2，把字符当作 N 进制数字得到结果 &#x27;gua&#x27; 被视为 g * 1 + u * 10 + a * 100 得到结果 n n % Size 作为字符串在数组中的下标 通常 Size 会选一个 素数4，搜索树(平衡二叉搜索树)（我们只用，不写，甚至只是隐含在用，你并不知道你用的是树） AVL 树 红黑树额外的，图是一种有时候有用但你一辈子都可能写不到的数据结构只了解，不用学习如何实现图的应用举例 地图导航 全国几个大城市之间的出行方案(有价格/时间/路途等权重)*/var log = console.log.bind(console)// 队列结构(先进先出)// 主要有 2 个操作// enqueue dequeue//var Queue = function() &#123; // data 是存储元素的数组 this.data = []&#125;// 入队Queue.prototype.enqueue = function (element) &#123; this.data.push(element)&#125;// 出队Queue.prototype.dequeue = function () &#123; return this.data.splice(0, 1)&#125;// 队列长度Queue.prototype.length = function () &#123; return this.data.length&#125;// 清空队列Queue.prototype.empty = function() &#123; this.data = []&#125;// var q = new Queue()// q.enqueue(1)// q.enqueue(2)// q.enqueue(3)// log(&#x27;length&#x27;, q.length())// log(q.dequeue())// q.enqueue(4)// log(q.dequeue())// log(q.dequeue())// log(q.dequeue())// Stack 栈(先进后出)// 常见的 3 个操作// push pop top//var Stack = function() &#123; this.data = []&#125;// push 添加一个元素Stack.prototype.push = function(e) &#123; this.data.push(e)&#125;// pop 删除并返回最新添加的元素Stack.prototype.pop = function() &#123; var index = this.data.length - 1 return this.data.splice(index, 1)&#125;// top 仅返回最新添加的元素Stack.prototype.top = function() &#123; var index = this.data.length - 1 return this.data[index]&#125;var s = new Stack()s.push(&#x27;hello&#x27;)s.push(&#x27;world&#x27;)log(s.pop())log(s.pop())var str = &#x27;hello&#x27;for (var i = 0; i &lt; str.length; i++) &#123; s.push(str[i])&#125;var str1 = &#x27;&#x27;for (var i = 0; i &lt; str.length; i++) &#123; str1 += s.pop(str[i])&#125;log(str1)/*((1 + 2) * 3)作业 验证括号匹配*/// 链表// LinkedList// [1, 2, 3, 4, 15, 16, 27]// [1, 2, 3, 0, 4, 5, 6, 7]// 链表实现//var Node = function(e) &#123; this.element = e this.next = null&#125;// var n1 = new Node(1)// var n2 = new Node(2)// var n3 = new Node(3)// n1.next = n2// n2.next = n3//// var n = n1// while(n != null) &#123;// log(&#x27;遍历链表&#x27;, n.element)// n = n.next// &#125;var LinkedList = function() &#123; this.head = new Node() this._length = 0&#125;// 在链表末尾增加一个元素LinkedList.prototype.append = function(e) &#123; var node = new Node(e) var n = this.head while(n.next != null) &#123; n = n.next &#125; n.next = node // this._length++&#125;// 返回一个元素的 indexLinkedList.prototype.indexOf = function(e) &#123; var index = -1 var n = this.head var i = 0 while(n.next != null) &#123; if (e === n.element) &#123; index = i break &#125; n = n.next i++ &#125; return index&#125;// 返回链表的长度LinkedList.prototype.length = function() &#123; return this._length&#125;LinkedList.prototype.log = function() &#123; var n = this.head.next log(&#x27;遍历链表&#x27;) while(n != null) &#123; log(&#x27; &gt; &#x27;, n.element) n = n.next &#125;&#125;var list = new LinkedList()list.append(&#x27;hello&#x27;)list.append(&#x27;gua&#x27;)list.append(&#x27;你好&#x27;)list.log()log(list.length())/*面向对象 多态 继承 大致讲一下多态在某些语言里面 比如 java你函数定义的参数必须有类型 类型不匹配就是错误的var add = function(a, b) &#123; return a + b&#125;// 在其他语言里面可能是这样的 比如 java cvar add = function(int:a, int:b) &#123; return a + b&#125;add(1.1, 2.2)// 报错， 类型不匹配var add = function(float:a, float:b) &#123; return a + b&#125;add(1.1, 1)var add = function(int:a, float:b) &#123; return a + b&#125;var add = function(float:a, int:b) &#123; return a + b&#125;// 现在就不会报错了。。。add(1.1, 1)// 在 js 中没这个问题// 我们称之为 duck type继承继承是说 子类拥有父类的某些东西定义一个类 人再定义 男人 女人然后设置 男人 女人的 prototype = 人*//*其他数据结构hash table 哈希表（散列表）tree 树set 集合graph 图哈希表就是用 字符串 当下标，也就是 js 中的对象的实现方式也就是其他语言中的 字典原理是用字符串 算出一个数字 然后用这个数字当下标存东西比如 gua 这个字符串 我们用每个字符乘以一个数字最后求余得到下标从字符串到数字的操作叫做 hash// hash(&#x27;gua&#x27;) = 1// hash(&#x27;hs&#x27;) = 3【坑1， 坑2， 坑3， 坑4， 坑5， 坑6】 gua hs wh xiao lj bl树一般是用来实现二叉搜索树的，应用范围不多 6 / \\ 4 8 \\ / \\ 57 9*/","categories":[],"tags":[{"name":"FE","slug":"FE","permalink":"https://vlwq.github.io/tags/FE/"}]},{"title":"css动画","slug":"2016fe/20161106","date":"2016-11-06T02:36:00.000Z","updated":"2022-03-03T03:27:31.185Z","comments":true,"path":"2016/11/06/2016fe/20161106/","link":"","permalink":"https://vlwq.github.io/2016/11/06/2016fe/20161106/","excerpt":"CSS动画","text":"CSS动画 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116&lt;!DOCTYPE html&gt;&lt;html&gt; &lt;head&gt; &lt;meta charset=&quot;utf-8&quot;&gt; &lt;title&gt;fe 21&lt;/title&gt; &lt;style&gt; .b + .b &#123; /*background: red;*/ border-top: 1px solid black; &#125; .c &#123; transform: translate(20px, 40px); &#125; wujcxy::after &#123; content: &#x27;★&#x27;; font-size: 32px; text-shadow: 1px 1px black; &#125; .orange &#123; color: # FF9800; &#125; .gray &#123; color: lightgray; &#125; &lt;/style&gt; &lt;style&gt; /* transition 动画 */ .gua-cube &#123; width: 100px; height: 200px; background: red; &#125; .gua-cube:hover &#123; width: 200px; height: 100px; background: blue; transform: scale(1.2, 2); &#125; .gua-cube &#123; transition: 1s; &#125; /* animation 动画 */ .gua-animation div &#123; height: 30px; background: lightblue; margin: 10px 10px; &#125; /* 定义一个动画 改变背景色 */ @keyframes changecolor &#123; 0% &#123; background: lightblue; /*height: 30px;*/ &#125; 100% &#123; background: black; height: 100px; &#125; &#125; @keyframes vr &#123; 0% &#123; transform: rotate(0deg); &#125; 50% &#123; transform: rotate(280deg); &#125; 100% &#123; transform: rotate(360deg); &#125; &#125; /* 播放动画 1s 完成， 动画名是 changecolor */ .gua1:hover &#123; animation: 1s changecolor; &#125; /* 利用 play-state 属性实现动画暂停 */ .gua2 &#123; animation: 1s vr infinite; animation-timing-function: linear; animation-play-state: paused; &#125; .gua2:hover &#123; animation-play-state: running; &#125; &lt;/style&gt; &lt;/head&gt; &lt;body&gt; &lt;div class=&quot;b&quot;&gt; a &lt;/div&gt; &lt;div class=&quot;c&quot;&gt; c &lt;/div&gt; &lt;div class=&quot;b&quot;&gt; &lt;wujcxy class=&quot;orange&quot;&gt;&lt;/wujcxy&gt; &lt;wujcxy class=&quot;orange&quot;&gt;&lt;/wujcxy&gt; &lt;wujcxy class=&quot;orange&quot;&gt;&lt;/wujcxy&gt; &lt;wujcxy class=&quot;gray&quot;&gt;&lt;/wujcxy&gt; &lt;wujcxy class=&quot;gray&quot;&gt;&lt;/wujcxy&gt; &lt;/div&gt; &lt;!-- transition 动画 --&gt; &lt;div class=&quot;gua-transition&quot;&gt; &lt;div class=&quot;gua-cube&quot;&gt; &lt;/div&gt; &lt;/div&gt; &lt;div class=&quot;gua-animation&quot;&gt; &lt;div class=&quot;gua1&quot;&gt;1&lt;/div&gt; &lt;div class=&quot;gua2&quot;&gt;2&lt;/div&gt; &lt;div class=&quot;gua3&quot;&gt;3&lt;/div&gt; &lt;/div&gt; &lt;/body&gt;&lt;/html&gt; js部分123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475// ============// 内容如下// 1, css3 的新特性// 2, css3 动画和动态效果// ============//// CSS选择器介绍// 阮一峰 http://www.ruanyifeng.com/blog/2009/03/css_selectors.html// 1. 4种基本选择器CSS 2.1// 2. 4种多元素的 组合选择器div, p 同时匹配div h1 匹配后代div &gt; p 匹配子元素div + div 匹配同级的下一个元素(仅匹配一个)其中 div p 与 div &gt; p 的区别前者匹配全部的后代元素，而后者仅匹配向下一层（子元素）// 3. 4种属性选择器 根据某类的属性来查找选择器E[att]E[att=val]// 4. 伪类选择器 实际不存在的类E:first-childE:linkE:lang(c)// 5. 伪元素E::first-lineE::first-letterE::before# CSS 3//CSS 3 中的新特性// 应该利用 CSS 3 generator生成CSS3代码(上课会讲)border-radius 边框圆角box text shadow 盒子阴影transform 2D 变形columns 属性 将文本分隔成多列transition 动画keyframes 动画和生成软件https://daneden.github.io/animate.css/http://cssanimate.com/其他 css3 生成软件http://css3generator.com/http://www.css3generator.in/http://css3.me/https://www.tutorialspoint.com/css/css3_boarder_image.htmCSS3 动画主要用到了 3 个属性transform 的全部函数https://developer.mozilla.org/en-US/docs/Web/CSS/transformtransition 可动画列表https://developer.mozilla.org/en-US/docs/Web/CSS/CSS_animated_propertiesanimation 动画123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120&lt;!DOCTYPE html&gt;&lt;html&gt; &lt;head&gt; &lt;meta charset=&quot;utf-8&quot;&gt; &lt;title&gt;fe 21 css3 animation&lt;/title&gt; &lt;style&gt; .gua-block &#123; background: lightblue; width: 100px; height: 100px; &#125; .gua-spin &#123; animation: spin linear 2s; animation-iteration-count: 1; &#125; @keyframes spin &#123; 0% &#123; transform: rotate(0deg); &#125; 100% &#123; transform: rotate(360deg); &#125; &#125; .shake &#123; animation: shake linear 0.6s; animation-iteration-count: 1; &#125; @keyframes shake &#123; 0% &#123; transform: translateX(0px); &#125; 10% &#123; transform: translateX(-10px); &#125; 30% &#123; transform: translateX(10px); &#125; 50% &#123; transform: translateX(-10px); &#125; 70% &#123; transform: translateX(10px); &#125; 90% &#123; transform: translateX(-10px); &#125; 100% &#123; transform: translateX(0px); &#125; &#125; .gua-shake &#123; transform: translateX(100px); &#125; &lt;/style&gt; &lt;/head&gt; &lt;body&gt; &lt;div class=&quot;gua-block&quot;&gt; 方块 &lt;/div&gt; &lt;button class=&quot;play&quot;&gt;播放动画&lt;/button&gt; &lt;div class=&quot;gua-shake&quot;&gt; &lt;input class=&#x27;input&#x27; value=&quot;&quot;&gt; &lt;br&gt; &lt;button class=&quot;login&quot;&gt;登录&lt;/button&gt; &lt;/div&gt; &lt;script&gt; var e = function(sel) &#123; return document.querySelector(sel) &#125; var playAnimation = function() &#123; var block = e(&#x27;.gua-block&#x27;) // 让它开始播放动画 block.classList.add(&#x27;gua-spin&#x27;) &#125; var shake = function(element) &#123; element.classList.add(&#x27;shake&#x27;) &#125; var __main = function() &#123; e(&#x27;.login&#x27;).addEventListener(&#x27;click&#x27;, function(event) &#123; // if 登录不成功 var input = e(&#x27;.input&#x27;) shake(input) &#125;) // 绑定一个 animationend 事件, 在动画结束后删除动画 class e(&#x27;.input&#x27;).addEventListener(&#x27;animationend&#x27;, function()&#123; e(&#x27;.input&#x27;).classList.remove(&#x27;shake&#x27;) &#125;) e(&#x27;.play&#x27;).addEventListener(&#x27;click&#x27;, function(e) &#123; playAnimation() &#125;) // 绑定一个 animationend 事件, 在动画结束后删除动画 class var block = e(&#x27;.gua-block&#x27;) block.addEventListener(&#x27;animationend&#x27;, function()&#123; block.classList.remove(&#x27;gua-spin&#x27;) &#125;) &#125; __main() /* animationend 事件 在动画播完后触发 动画播放被暂停不会触发 animationiteration 事件 在动画播放一轮后触发 如果动画只播放一轮, 那么不会触发此事件 利用事件测试动画 */ &lt;/script&gt; &lt;/body&gt;&lt;/html&gt;","categories":[],"tags":[{"name":"FE","slug":"FE","permalink":"https://vlwq.github.io/tags/FE/"}]},{"title":"ES6中的promise对象","slug":"2016fe/20161105","date":"2016-11-05T02:36:00.000Z","updated":"2022-03-03T03:27:28.582Z","comments":true,"path":"2016/11/05/2016fe/20161105/","link":"","permalink":"https://vlwq.github.io/2016/11/05/2016fe/20161105/","excerpt":"ES6中的promise对象","text":"ES6中的promise对象 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071727374757677/*Promise 是抽象异步处理对象以及对其进行各种操作的组件简而言之, 就是让异步操作变得好看一些Promise 的用法如下*/// 将 fs.readFile 的操作封装成 promise// 这样就可以使用 promise 的 api 了const readFile = function(filename) &#123; // 一般前端的写法 // return new Promise(function(resolve, reject) &#123;&#125;) const p = new Promise(function(resolve, reject) &#123; const fs = require(&#x27;fs&#x27;) const options = &#123; encoding: &#x27;utf8&#x27; &#125; fs.readFile(filename, options, function(error, content) &#123; if (error !== null) &#123; reject(error) &#125; else &#123; resolve(content) &#125; &#125;) &#125;) return p&#125;// 使用 promise 读取文件就不用写成回调的形式了// 直接按照同步的写法就好了// 可以无限 then, 只要你保证上一个 then 返回了东西即可let promise = readFile(&#x27;foo.txt&#x27;)promise.then(function(content) &#123; console.log(&#x27;debug file content&#x27;, content) const c = content + &#x27; suffix1&#x27; return c&#125;, function(error) &#123; console.log(&#x27;debug error message&#x27;, error)&#125;).then(function(c1) &#123; console.log(&#x27;second then&#x27;, c1) const c = c1 + &#x27; suffix2&#x27; return c&#125;).then(function(c) &#123; console.log(&#x27;third then&#x27;, c)&#125;)// 上面的写法也可以写成下面这样// 把 reject 的操作放在 catch 里面promise.then(function(content) &#123; console.log(&#x27;debug file content&#x27;, content)&#125;).catch(function(error) &#123; console.log(&#x27;debug error message&#x27;, error)&#125;)// 有时候会碰到批量执行异步操作，如果直接用循环 + 调用函数的形式会比较麻烦// 使用 Promise.all 就很方便了// all 方法是直接挂在 Promise 类上的// 而 then catch 这些方法是挂在原型上const fileList = [ &#x27;t1.txt&#x27;, &#x27;t2.txt&#x27;, &#x27;t3.txt&#x27;,]const list = fileList.map(function(item) &#123; const r = readFile(item) return r&#125;)Promise.all(list).then(function(content) &#123; console.log(&#x27;content&#x27;, content)&#125;)/*这是一个完整的参考, 如果有兴趣以后可以翻翻看, 但是现在没必要看了http://liubin.org/promises-book/*/","categories":[],"tags":[{"name":"FE","slug":"FE","permalink":"https://vlwq.github.io/tags/FE/"}]},{"title":"lodash","slug":"2016fe/20161104","date":"2016-11-04T02:36:00.000Z","updated":"2022-03-03T03:27:25.797Z","comments":true,"path":"2016/11/04/2016fe/20161104/","link":"","permalink":"https://vlwq.github.io/2016/11/04/2016fe/20161104/","excerpt":"lodash的demo","text":"lodash的demo 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172173174175176177178179180181182183184185186187188189190191192193194195196197198199200201202203204205206207208209210211212213214215216217&lt;!DOCTYPE html&gt;&lt;html&gt;&lt;head&gt; &lt;title&gt;lodash demo&lt;/title&gt; &lt;script src=&quot;https://cdn.jsdelivr.net/lodash/4.17.4/lodash.js&quot;&gt;&lt;/script&gt;&lt;/head&gt;&lt;body&gt;&lt;/body&gt;&lt;script&gt; /* lodash 是一个非常实用的 js 工具库 在 node 中可以安装 也可以自己下载来导入 在 浏览器 中, 可以通过 CDN 的方式使用 */ // _ 是 lodash 的套路用法 // const _ = require(&#x27;./lodash.js&#x27;) // each 用法 const list = [ &#x27;a&#x27;, &#x27;b&#x27;, &#x27;c&#x27;, ] const dict = &#123; k1: &#x27;a&#x27;, k2: &#x27;b&#x27;, k3: &#x27;c&#x27;, &#125; _.each(list, (v, k) =&gt; &#123; // each 方法的两个参数 // 如果 list 是 列表，那么 v 和 k 分别是指 list 的 element/index // 如果 list 是 对象（字典），那么 v 和 k 分别是指 object 的 value/key console.log(&#x27;element and index&#x27;, v, k) &#125;) _.each(dict, (v, k) =&gt; &#123; console.log(&#x27;value and key&#x27;, v, k) &#125;) // map 用法 // 用 map 可以用一个旧数组生成一个新数组 // 比如旧数组为 const list1 = [ 10, 20, 30, ] const list2 = _.map(list1, (v, k) =&gt; &#123; const r = v * v return r &#125;) console.log(&#x27;list2&#x27;, list2) // filter // 遍历数组/对象，返回符合判断函数中的元素 var us = [ &#123; &#x27;name&#x27;: &#x27;a&#x27;, &#x27;score&#x27;: 70, &#125;, &#123; &#x27;name&#x27;: &#x27;b&#x27;, &#x27;score&#x27;: 90, &#125;, &#123; &#x27;name&#x27;: &#x27;c&#x27;, &#x27;score&#x27;: 80, &#125;, &#123; &#x27;name&#x27;: &#x27;d&#x27;, &#x27;score&#x27;: 70, &#125;, ] var u = _.filter(us, (e) =&gt; &#123; var b = e.score &gt; 70 return b &#125;) console.log(&#x27;filter u&#x27;, u) // orderBy // 根据条件排序 // 先按照 score 升序，如果有 score 一样的 // 再按照 name 降序 var users = _.orderBy(us, [&#x27;score&#x27;, &#x27;name&#x27;], [&#x27;asc&#x27;, &#x27;desc&#x27;]) console.log(&#x27;order by users&#x27;, users) // flatten // 减少一层嵌套数组 // 也就是可以直接将二维数组拍成一维数组 var l = [ 1, [2], [3, [4]], [5, [6], [7]], ] var f = _.flatten(l) console.log(&#x27;flatten result&#x27;, f) // compact // 剔除数组中的假值元素 // js 中假值元素分别为 // false null 0 NaN &#x27;&#x27; undefined // 这个方法可以和 map 配合使用 // 剔除返回数组的数组中的假值元素 var l = [ 0, 1, NaN, &#x27;&#x27;, &#x27;hello&#x27;, false, undefined, null, &#123;&#125;, ] var result = _.compact(l) console.log(&#x27;compact result&#x27;, result) // isEqual // 比较两个对象是否相等 // 数组也可以用这个方法比较 var o1 = &#123; &#x27;key&#x27;: 1, &#125; var o2 = &#123; &#x27;key&#x27;: 1, &#125; var result = _.isEqual(o1, o2) console.log(&#x27;isEqual result&#x27;, result) // 获取嵌套对象的值 var o = &#123; &#x27;k1&#x27;: &#123; &#x27;k2&#x27;: &#123; &#x27;k3&#x27;: &#123; &#x27;k4&#x27;: &#x27;value in nested dict&#x27; &#125; &#125; &#125; &#125; var path = &#x27;k1.k2.k3.k4&#x27; var result = _.result(o, path) console.log(&#x27;result nested result&#x27;, result) // 生成数组 // 使用 range 生成数组后，就可以使用 // each map filter 这些方法操作数组了 var l = _.range(10) console.log(&#x27;range l&#x27;, l) // cloneDeep // 深拷贝 var o = &#123; &#x27;a&#x27;: [1], &#x27;b&#x27;: [2], &#125; var deep = _.cloneDeep(o) console.log(&#x27;deep&#x27;, deep) // random // 返回给定范围的随机值 var a = 10 var b = 20 // 返回 a 和 b 之间的一个整数 var r1 = _.random(a, b) console.log(&#x27;random r1&#x27;, r1) // 如果指定第三个参数为 true，这个参数的意思是指 floating // 那么返回的就是一个浮点数 var r2 = _.random(a, b, true) console.log(&#x27;random r2&#x27;, r2) // shuffle // 返回打乱顺序后的数组 var l = [1, 2, 3, 4,] const s = _.shuffle(l) console.log(&#x27;shuffle l&#x27;, s)&lt;/script&gt;&lt;/html&gt;","categories":[],"tags":[{"name":"FE","slug":"FE","permalink":"https://vlwq.github.io/tags/FE/"}]},{"title":"ajax,Bom","slug":"2016fe/20161103","date":"2016-11-03T02:36:00.000Z","updated":"2022-03-03T03:27:22.611Z","comments":true,"path":"2016/11/03/2016fe/20161103/","link":"","permalink":"https://vlwq.github.io/2016/11/03/2016fe/20161103/","excerpt":"&#x2F;&#x2F; 1, HTTP 协议(Hyper-Text Transportation Protocol)&#x2F;&#x2F; 2, AJAX&#x2F;&#x2F; 3, BOM (Browser Object Model 浏览器对象模型)&#x2F;&#x2F;","text":"&#x2F;&#x2F; 1, HTTP 协议(Hyper-Text Transportation Protocol)&#x2F;&#x2F; 2, AJAX&#x2F;&#x2F; 3, BOM (Browser Object Model 浏览器对象模型)&#x2F;&#x2F; 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172173174175176177178179180181182183184185186187188189190191192193194195196197198199200201202203204205206207208209210211212网址组成（四部分） 协议 http, https（https 是加密的 http） 主机 g.cn zhihu.com之类的网址 端口 HTTP 协议默认是 80，因此一般不用填写 路径 下面的「/」和「/question/31838184」都是路径http://www.zhihu.com:80/http://www.zhihu.com/question/3183818410101000168ASCIIa 97 01100001A 65 01000001电脑通信靠IP地址，IP地址记不住就发明了域名（domain name），然后电脑自动向DNS服务器（domain name server）查询域名对应的IP地址比如g.cn这样的网址，可以通过电脑的ping程序查出对应 IP 地址➜ ping g.cnPING g.cn (74.125.69.160): 56 data bytes端口是什么？一个比喻：用邮局互相写信的时候，ip相当于地址（也可以看做邮编，地址是域名）端口是收信人姓名（因为一个地址比如公司、家只有一个地址，但是却可能有很多收信人）端口就是一个标记收信人的数字。端口是一个 16 位(二进制的 位)的数字，所以范围是 0-65535（2**16）——HTTP协议——一个传输协议，协议就是双方都遵守的规范。为什么叫超文本传输协议呢，因为收发的是文本信息。1，浏览器（客户端）按照规定的格式发送文本数据（请求）到服务器2，服务器解析请求，按照规定的格式返回文本数据到浏览器3，浏览器解析得到的数据，并做相应处理请求和返回是一样的数据格式，分为4部分：1，请求行或者响应行2，Header（请求的 Header 中 Host 字段是必须的，其他都是可选）3，\\r\\n\\r\\n（连续两个换行回车符，用来分隔Header和Body）4，Body（可选）请求的格式，注意大小写（这是一个不包含Body的请求）：原始数据如下&#x27;GET / HTTP/1.1\\r\\nhost:g.cn\\r\\n\\r\\n&#x27;打印出来如下GET / HTTP/1.1Host: g.cn&#x27;GET / HTTP/1.1\\r\\nhost:www.qq.com\\r\\n\\r\\n&#x27;其中1， GET 是请求方法（还有POST等，这就是个标志字符串而已）2，/ 是请求的路径（这代表根路径）3，HTTP/1.1 中，1.1是版本号，通用了20年具体字符串是 &#x27;GET / HTTP/1.1\\r\\nhost:g.cn\\r\\n\\r\\n&#x27;返回的数据如下HTTP/1.1 301 Moved PermanentlyAlternate-Protocol: 80:quic,p=0,80:quic,p=0Cache-Control: private, max-age=2592000Content-Length: 218Content-Type: text/html; charset=UTF-8Date: Tue, 07 Jul 2015 02:57:59 GMTExpires: Tue, 07 Jul 2015 02:57:59 GMTLocation: http://www.google.cn/Server: gwsX-Frame-Options: SAMEORIGINX-XSS-Protection: 1; mode=blockBody部分太长，先不贴了其中响应行（第一行）：1，HTTP/1.1 是版本2，301 是「状态码」，参见文末链接3，Moved Permanently 是状态码的描述浏览器会自己解析Header部分，然后将Body显示成网页2xx 表示成功3xx 表示移动走了或者别的什么情况4xx 表示你发错了请求(比如你发的路径根本不存在 或者你发的请求是错的)5xx 表示服务器挂了, 各种原因挂了——前端掌握 HTTP 协议有什么用——可以用 JS 动态抓取内容构建页面比如动态评论、加载数据比如天气预报程序比如壁纸图片库浏览器提供了使用 HTTP 协议收发数据的接口，名为 AJAX这是一个重要的技术——浏览器安全问题——跨域请求问题和解决方案 1, 服务器设置 HTTP 协议头*/// ——AJAX 和使用方法——// ajax 就是浏览器提给的用 js 获取链接内容的 API// 你可以理解为发送网络请求的标准库//// 获取登录页面// 创建 AJAX 对象var r = new XMLHttpRequest()// 设置请求方法和请求地址, 第三个别管, 就写 truer.open(&#x27;GET&#x27;, &#x27;/login&#x27;, true)// 注册响应函数r.onreadystatechange = function() &#123; console.log(&#x27;onreadystatechange&#x27;, r.readyState, r.readyState == 4) if(r.readyState == 4) &#123; console.log(&#x27;state change&#x27;, r) &#125;&#125;// 发送请求r.send()// 发送登录数据// 创建 AJAX 对象var r = new XMLHttpRequest()// 设置请求方法和请求地址r.open(&#x27;POST&#x27;, &#x27;/login&#x27;, true)// 设置发送的数据的格式r.setRequestHeader(&#x27;Content-Type&#x27;, &#x27;application/json&#x27;)// 注册响应函数r.onreadystatechange = function() &#123; if (r.readyState == 4) &#123; console.log(&#x27;state change&#x27;, r, r.status, r.response) var response = JSON.parse(r.response) console.log(&#x27;response&#x27;, response) &#125; else &#123; console.log(&#x27;change&#x27;) &#125;&#125;// 发送请求var account = &#123; username: &#x27;gua&#x27;, password: &#x27;123&#x27;,&#125;var data = JSON.stringify(account)r.send(data)# 可以封装成这样的一个函数, 避免总监吃瘪var ajax = function(method, path, data, reseponseCallback) &#123; var r = new XMLHttpRequest() // 设置请求方法和请求地址 r.open(method, path, true) // 设置发送的数据的格式 r.setRequestHeader(&#x27;Content-Type&#x27;, &#x27;application/json&#x27;) // 注册响应函数 r.onreadystatechange = function() &#123; if (r.readyState == 4) &#123; // console.log(&#x27;state change&#x27;, r, r.status, r.response) reseponseCallback(r.response) // var response = JSON.parse(r.response) // console.log(&#x27;response&#x27;, response) &#125; else &#123; // console.log(&#x27;change&#x27;) &#125; &#125; // 发送请求 r.send(data)&#125;/*// BOMBOM(browser object model) 包含5个东西&gt;location 管理 URL&gt;navigator 管理浏览器&gt;history 管理历史记录&gt;screen 管理屏幕&gt;window 管理浏览器所有的东西location 对象是用来管理 URL 的, 下面是例子改变 href 属性就可以跳转页面hash: &quot;&quot;host: &quot;s.taobao.com&quot;hostname: &quot;s.taobao.com&quot;href: &quot;https://s.taobao.com/search?q=3ds&amp;imgfile=&amp;js=1&amp;stats_click=search_radio_all&amp;ie=utf8&quot;search: &quot;?q=3ds&amp;imgfile=&amp;js=1&amp;stats_click=search_radio_all&amp;ie=utf8&quot;origin: &quot;https://s.taobao.com&quot;pathname: &quot;/search&quot;port: &quot;&quot;protocol: &quot;https:&quot;reload: 函数, 刷新当前页面replace: 函数, 替换当前页面, 有参数navigator 对象是用来查询浏览器的信息的比如当前的操作系统平台, 浏览器型号厂商等等例如navigator.userAgent&quot;Mozilla/5.0 (Macintosh; Intel Mac OS X 10_11_6) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/54.0.2840.71 Safari/537.36&quot;navigator.platform&quot;MacIntel&quot;history 对象是用来处理历史纪录的在 HTML5 它增加了一些 API 使得它也可以做单页应用(SPA, single page app)history.length // 历史列表中的 url 数量history.back() // 相当于点击后退按钮history.forward() // 相当于点前进history.go(-2) // 相当于点击两次后退按钮// 下面是 HTML5 新函数history.pushState(null, &#x27;title&#x27;, &quot;/profile&quot;)三个参数分别是 自定义对象 新页面的标题, 但是现在还没有浏览器实现这个功能 新页面的地址var state = &#123; page: &quot;settings&quot;&#125;history.pushState(state, &quot;settings&quot;, &quot;/settings&quot;)用户点击 前进 后退 按钮的时候, 会触发 window 的 popstate 事件于是可以在这里操作window.addEventListener(&quot;popstate&quot;, function(e) &#123; var state = e.state; // state 就是 pushState 的第一个参数 console.log(&#x27;pop state&#x27;, state)&#125;)还有一个 replaceState 函数, 它的作用和 pushState 一样, 只是不生成一条历史纪录其他只能在相同域名下可以使用 queryString主要作用是来做 SPA(single page application 单页应用)*/+","categories":[],"tags":[{"name":"FE","slug":"FE","permalink":"https://vlwq.github.io/tags/FE/"}]},{"title":"console的apply,call,bind","slug":"2016fe/20161102","date":"2016-11-02T02:36:00.000Z","updated":"2022-03-03T03:27:19.675Z","comments":true,"path":"2016/11/02/2016fe/20161102/","link":"","permalink":"https://vlwq.github.io/2016/11/02/2016fe/20161102/","excerpt":"console的apply,call,bind","text":"console的apply,call,bind 12345678910111213141516171819202122232425262728293031323334353637383940414243444546// apply call bind 是用来给函数指定 this 用的// 但是用法稍有区别, 以我们长久以来使用的 log 为例var log = function() &#123; // log 是一个函数 // js 中的函数是一个对象 // 所以函数可以有方法 // apply, call, bind 都是函数的方法, 用来指定 this // // apply 接受两个参数 // 第一个参数是函数里面的 this, 这里指定了是 console, 这样就相当于 console.log // 第二个参数是要传给函数的参数列表, 类型是 数组 // apply 会把数组拆成一个个的参数传给函数 // 假设你调用 log(1, 2, 3, 4) // 那么 arguments 是 [1, 2, 3, 4] 这样的一个数组 // (实际上 arguments 不是数组, 但是表现和数组一模一样, 你就暂时当它是一个数组) // 下面这句就相当于调用 console.log(1, 2, 3, 4) // console.log.apply(console, [1, 2, 3, 4]) console.log.apply(console, arguments) // call 和 apply 类似, 但是小有区别, 如下 // 第一个参数和 apply 一样 // 第 2, 3, 4, 5, ... 个参数会依次作为参数传给函数 console.log.call(console, 1, 2, 3, 4) // 相当于调用下面的函数, 区别在于参数的类型 // console.log.apply(console, [1, 2, 3, 4]) // 相当于调用 console.log(1, 2, 3, 4) // var print = console.log // print.call(console, 1, 2, 3)&#125;// bind 函数不直接调用, 而是返回一个函数让你来调用// 第一个参数是用来指定函数里面的 this, 和 apply call 一样// 用法就是这样, 返回一个指定了 this 的函数// 下面的例子中, bind 函数把 console 参数指定为 log 函数的 thisvar log = console.log.bind(console)log(&#x27;hello&#x27;, 1, 2, 3)// hello 1 2 3// bind 还可以有额外的参数, 效果如下// 给返回的函数加上部分参数var error = console.log.bind(console, &#x27;*** ERROR&#x27;)// 下面的调用相当于 console.log(&#x27;*** ERROR&#x27;, &#x27;错误&#x27;)error(&#x27;错误&#x27;)// *** ERROR 错误","categories":[],"tags":[{"name":"FE","slug":"FE","permalink":"https://vlwq.github.io/tags/FE/"}]},{"title":"flex布局","slug":"2016fe/20161012","date":"2016-10-12T02:36:00.000Z","updated":"2022-03-03T03:28:39.970Z","comments":true,"path":"2016/10/12/2016fe/20161012/","link":"","permalink":"https://vlwq.github.io/2016/10/12/2016fe/20161012/","excerpt":"flex布局，做了3个demo","text":"flex布局，做了3个demo #垂直水平居中 123456789101112131415161718192021222324252627282930313233&lt;!DOCTYPE html&gt;&lt;html lang=&quot;en&quot;&gt;&lt;head&gt; &lt;meta charset=&quot;UTF-8&quot;&gt; &lt;title&gt;首页&lt;/title&gt; &lt;style&gt; body&#123; margin:0px; &#125; .parent&#123; position:absolute; background-color: #00a2d4; width: 100%; height: 100%; display: flex; justify-content: center; align-items: center; &#125; .child&#123; width: 150px; height: 150px; background-color: red; &#125; &lt;/style&gt;&lt;/head&gt;&lt;body&gt;&lt;div class=&quot;parent&quot;&gt; &lt;div class=&quot;child&quot;&gt; &lt;/div&gt;&lt;/div&gt;&lt;/body&gt;&lt;/html&gt; #博客布局 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071727374757677&lt;!DOCTYPE html&gt;&lt;html lang=&quot;en&quot;&gt;&lt;head&gt; &lt;meta charset=&quot;UTF-8&quot;&gt; &lt;title&gt;首页&lt;/title&gt; &lt;style&gt; body&#123; margin:0px; &#125; .blog&#123; position:absolute; width: 100%; height: 100%; &#125; .navbar&#123; width: 100%; height:50px; background-color: black; &#125; .main&#123; background-color: lightgoldenrodyellow; width: 100%; position: absolute; top: 50px; bottom: 0px; /* 水平垂直居中 */ display: flex; justify-content: center; align-items: center; &#125; .content&#123; width: 90%; height: 100%; background-color: #00a2d4; display: flex; &#125; .article&#123; background-color: chocolate; flex: 1; flex: 0 0 75%; &#125; .aside&#123; background-color: rebeccapurple; flex: 1; flex: 0 0 25%; display: flex; align-items: center; flex-direction: column; &#125; .box&#123; background-color: #2D82FF; width: 80%; margin-top :10px; margin-bottom: 10px; &#125; &lt;/style&gt;&lt;/head&gt;&lt;body&gt;&lt;div class=&quot;blog&quot;&gt; &lt;div class=&quot;navbar&quot;&gt;&lt;/div&gt; &lt;div class=&quot;main&quot;&gt; &lt;div class=&quot;content&quot;&gt; &lt;div class=&quot;article&quot;&gt;&lt;/div&gt; &lt;div class=&quot;aside&quot;&gt; &lt;div class=&quot;box&quot;&gt;111111111111111&lt;/div&gt; &lt;div class=&quot;box&quot;&gt;222222222222&lt;/div&gt; &lt;div class=&quot;box&quot;&gt;33333333333&lt;/div&gt; &lt;div class=&quot;box&quot;&gt;4444444444444&lt;/div&gt; &lt;div class=&quot;box&quot;&gt;55555555555555&lt;/div&gt; &lt;/div&gt; &lt;/div&gt; &lt;/div&gt;&lt;!-- &lt;div class=&quot;footer&quot;&gt;&lt;/div&gt;--&gt;&lt;/div&gt;&lt;/body&gt;&lt;/html&gt; #Gird布局 12345678910111213141516171819202122232425262728293031323334353637383940414243444546&lt;!DOCTYPE html&gt;&lt;html lang=&quot;en&quot;&gt;&lt;head&gt; &lt;meta charset=&quot;UTF-8&quot;&gt; &lt;title&gt;Flex布局&lt;/title&gt; &lt;style type=&quot;text/css&quot;&gt; .Grid&#123; display: flex; &#125; .Grid-cell&#123; flex: 1; &#125; .Grid-cell.u-full&#123; flex: 0 0 100%; &#125; .Grid-cell.u-1of2&#123; flex: 0 0 50%; &#125; .Grid-cell.u-1of3&#123; flex: 0 0 33.3333%; &#125; .Grid-cell.u-1of4&#123; flex: 0 0 25%; &#125; &lt;/style&gt;&lt;/head&gt;&lt;body&gt;&lt;div class=&quot;Grid&quot;&gt; &lt;div class=&quot;Grid-cell u-1of4&quot; style=&quot;background-color: #2D82FF&quot;&gt;1/4&lt;/div&gt; &lt;div class=&quot;Grid-cell&quot; style=&quot;background-color: #6DDA79&quot;&gt;auto&lt;/div&gt; &lt;div class=&quot;Grid-cell u-1of3&quot; style=&quot;background-color: #46A0CE&quot;&gt;1/3&lt;/div&gt;&lt;/div&gt;&lt;p&gt;&lt;/p&gt;&lt;div class=&quot;Grid&quot;&gt; &lt;div class=&quot;Grid-cell&quot; style=&quot;background-color: #2D82FF&quot;&gt;auto&lt;/div&gt; &lt;div class=&quot;Grid-cell u-1of3&quot; style=&quot;background-color: #6DDA79&quot;&gt;1/3&lt;/div&gt;&lt;/div&gt;&lt;p&gt;&lt;/p&gt;&lt;div class=&quot;Grid&quot;&gt; &lt;div class=&quot;Grid-cell u-1of2&quot; style=&quot;background-color: #2D82FF&quot;&gt;1/2&lt;/div&gt; &lt;div class=&quot;Grid-cell&quot; style=&quot;background-color: #6DDA79&quot;&gt;auto&lt;/div&gt; &lt;div class=&quot;Grid-cell&quot; style=&quot;background-color: #46A0CE&quot;&gt;auto&lt;/div&gt;&lt;/div&gt;&lt;/body&gt;&lt;/html&gt; #圣杯布局 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152&lt;!DOCTYPE html&gt;&lt;html lang=&quot;en&quot;&gt;&lt;head&gt; &lt;meta charset=&quot;UTF-8&quot;&gt; &lt;title&gt;Title&lt;/title&gt; &lt;style&gt; body&#123; margin: 0px; &#125; .HolyGrail &#123; display: flex; min-height: 100vh; flex-direction: column; &#125; header, footer &#123; flex: 1; &#125; .HolyGrail-body &#123; display: flex; flex: 1; &#125; .HolyGrail-content &#123; flex: 1; &#125; .HolyGrail-nav, .HolyGrail-ads &#123; /* 两个边栏的宽度设为5em */ flex: 0 0 5em; &#125; .HolyGrail-nav &#123; /* 导航放到最左边 */ order: -1; &#125; &lt;/style&gt;&lt;/head&gt;&lt;body&gt;&lt;body class=&quot;HolyGrail&quot;&gt;&lt;header style=&quot;background-color: #2D82FF&quot;&gt;...&lt;/header&gt;&lt;div class=&quot;HolyGrail-body&quot;&gt; &lt;main class=&quot;HolyGrail-content&quot; style=&quot;background-color: #6DDA79&quot;&gt;...&lt;/main&gt; &lt;nav class=&quot;HolyGrail-nav&quot; style=&quot;background-color: yellow&quot;&gt;...&lt;/nav&gt; &lt;aside class=&quot;HolyGrail-ads&quot; style=&quot;background-color: rebeccapurple&quot;&gt;...&lt;/aside&gt;&lt;/div&gt;&lt;footer style=&quot;background-color: #2D82FF&quot;&gt;...&lt;/footer&gt;&lt;/body&gt;&lt;/body&gt;&lt;/html&gt;","categories":[],"tags":[{"name":"FE","slug":"FE","permalink":"https://vlwq.github.io/tags/FE/"}]},{"title":"差距","slug":"2015others/20161005","date":"2016-10-05T02:36:00.000Z","updated":"2022-03-03T03:40:45.371Z","comments":true,"path":"2016/10/05/2015others/20161005/","link":"","permalink":"https://vlwq.github.io/2016/10/05/2015others/20161005/","excerpt":"其实差别在上高中的时候就产生了。 到了高二文理分科的时候，其实就是一个人生的选择转折点。 因为从那个时候，摆在你面前的是一条又一条的十字路口。 前十几年不可改变的生活背景，教育方式和水平，以及生活重心慢慢发生改变。 人生的方向盘慢慢转交到了自己的手上。 那个时候还是一脸天真，未谙世事的学生。哪里知道以后生活的路呢？ 但是作为一个典型的危机主义者，对未来充满曙光的同时也就会有巨大的压力。 排解压力的方式也就是跟身边的好朋友谈想法谈未来。","text":"其实差别在上高中的时候就产生了。 到了高二文理分科的时候，其实就是一个人生的选择转折点。 因为从那个时候，摆在你面前的是一条又一条的十字路口。 前十几年不可改变的生活背景，教育方式和水平，以及生活重心慢慢发生改变。 人生的方向盘慢慢转交到了自己的手上。 那个时候还是一脸天真，未谙世事的学生。哪里知道以后生活的路呢？ 但是作为一个典型的危机主义者，对未来充满曙光的同时也就会有巨大的压力。 排解压力的方式也就是跟身边的好朋友谈想法谈未来。 慢慢发现人与人之间真的是有差别的。不同家庭条件的人之间是有差别的，相同家庭条件的人之间也是有差别的。 有的人读书是知道知识改变命运，有的人知道读书是为了让自己接触更高层次的人，有的人读书是为了在家庭聚会上作为长辈表扬自己的资本。 有的人以批判应试教育为理由作为自己不学习的借口，有的人明明很反对800字的八股文却还是研究如何写好。 有的人过一天算一天，有的人连大学生活都规划好了。 有的人开始学会自己搜集资料填报学校和专业，有的人高考结束将填报志愿的事情推给父母。 如果说高中是方向盘慢慢的交到自己手上，上了大学那就是方向盘完全交到了自己手上。 自由的时间多了，喝酒的机会也就多了，喝多了之后也会谈谈自己的想法和打算。 好朋友A一直强调他没有远大的志向，只想找个工作娶个媳妇不愁吃喝也就够了，想在所学的行当干干在做打算。每天干的就是打撸，所以人称外号小撸子。好朋友B是家里当地官二代，生性不羁，情商过人，却思维懒惰。大学后期家父心脏除了问题，做了搭桥手术，听了家里意见考了公务员。好朋友C 家里倾尽财力想让他去澳大利亚留学定居，为了省下学费，每天自学雅思。希望以后能在国外留学定居好朋友D 独来独往，每天准时早上六点左右起来独自一人去图书馆看书或者出去玩或者逛。很有自己的思想和见解。大学后期不喜欢土木，自己在网上投简历去上海实习转行it。 到了工作领域，接触的人也就慢慢不太一样，联系也就越来越少。但是情况却大致了解，未来的发展也大致能够估算的出来，人的感觉嘛都大致一样。 一个人的人生路程别人大致能看在眼里。 后来A还是在这个行业坚持干了下去，虽然委屈和难处很多，没有好的出路，迫于生活压力选择留守。也算努力工作。收入不高也没有用钱的地方，勉强维持生活。 B回家考了公务员，头两年生活还算潇洒，家里有房有车，经常换女朋友待在一起。后来发现自己工资还是一点点工资，而以前的同学都月薪上万了。心里开始不平衡了，也没有了出去的勇气。 C后来雅思考了七点几分，收到了澳大利亚第二好的学校的offer。努力也得到了回报，称为世界水平的高校研究生，并有定居的打算。 D转行之后，在上海也是慢慢顺手了，工作虽然辛苦却小有成就，成长的也很快。目前的月薪也是接近三万。 其实说了这么多，还就是想说明一点。 其实差别从高中的时候就开始了，从读大学的时候就开始了，从参加工作就开始了。你和任何人的差别，从你认识他的时候就开始了。只不过随着时间推移，形成了差距你才看到。 而这些差距就是你之前对于生活的的规划，和人生的摸索定位。 如今社会的发展速度只会越来越快，大城市和小城市的眼界差距也会越来越大。 千万不要在年轻的时候选择安逸的不奋斗，等哪一天发现跟身边人的差距时后悔也就来不及了。创建于 2017-02-02作者保留权利","categories":[],"tags":[{"name":"others","slug":"others","permalink":"https://vlwq.github.io/tags/others/"}]},{"title":"能得到锻炼能力的机会","slug":"2015others/20161001","date":"2016-10-01T02:36:00.000Z","updated":"2022-03-03T03:40:42.734Z","comments":true,"path":"2016/10/01/2015others/20161001/","link":"","permalink":"https://vlwq.github.io/2016/10/01/2015others/20161001/","excerpt":"“能得到锻炼能力的机会”本身就是一项极其稀缺的资源。没有锻炼的机会，你就算本身有天分也够努力，但没用，你得不到外界的营养，就会长得慢。 为什么有的宝宝长得强壮，有的宝宝长得孱弱？妈妈们会告诉你“营养摄入”的区别。为什么森林里有的树木长得高大，有的树木萎靡？因为有的树木得到了阳光，肥沃的土壤，有的树木得不到阳光，阳光被其他树木抢去了。","text":"“能得到锻炼能力的机会”本身就是一项极其稀缺的资源。没有锻炼的机会，你就算本身有天分也够努力，但没用，你得不到外界的营养，就会长得慢。 为什么有的宝宝长得强壮，有的宝宝长得孱弱？妈妈们会告诉你“营养摄入”的区别。为什么森林里有的树木长得高大，有的树木萎靡？因为有的树木得到了阳光，肥沃的土壤，有的树木得不到阳光，阳光被其他树木抢去了。 人的职业成长也一样。在中等以上资质的基础上，把你放到有阳光、有营养的岗位上，每天大量机会给你练手，你很快就能成长起来。但可惜，大部分人之所以能得到一份工作，因为那些占据着阳光营养的人，需要“打下手”、“做杂事”的人，而已。从一开始，就根本没打算让你成长。那些占据上位的人们，自己还要成长呢。当然，场面上的漂亮话还是要说的，什么帮助你成长之类，你听听就算了。 不过，就算环境这么恶劣，依然有大量年轻人能出头，他们怎么做到的？除了一部分家里人一开始就安排好阳光营养的岗位的，主要两个途径。一个是走运登上一条高速前进的大船，进去的时候还是小舢板，高速发展过程中涌进大量练手机会，巨鳄还没注意到以前，自己捞到了锻炼机会。第二条是自己摸索，不管是自己画画、做装置、写作、做生意，自己独自做事得到的锻炼机会是给人打工不能比的，但这条路比较苦痛，不建议承受能力差的人尝试。 工作这么多年，各种例子也见得很多，不过我有大量前领导同事也上知乎，具体例子就不说了。有些话，点到为止就好。成人世界之所以困难，是因为大量谎言包裹其中，“帮助你成长”即是其中之一。创建于 2016-12-29作者保留权利","categories":[],"tags":[{"name":"others","slug":"others","permalink":"https://vlwq.github.io/tags/others/"}]},{"title":"毕业一年","slug":"2015others/20160921","date":"2016-09-21T02:36:00.000Z","updated":"2022-03-03T03:40:40.068Z","comments":true,"path":"2016/09/21/2015others/20160921/","link":"","permalink":"https://vlwq.github.io/2016/09/21/2015others/20160921/","excerpt":"毕业接触社会是人生的又一次挑战。不论你的大学是如何度过的，成绩好坏，有无社会经验，是否准备充分以及是否愿意，在毕业的那一刻，你都将进入一个陌生的领域开始一段全新的人生旅程，并且你很可能再也回不到身后的象牙塔里去了。从此，无论前方是风霜雨雪，还是晴空暖阳，是陷阱沟壑，还是坦途平原，你都得坚持走下去。 希望你能有这样的心理准备：接下来要走的路，要打交道的人和组织、要经历的事以及评判你的标准，都将和你人生前20多年的经历完全不同，你将会亲眼目睹亲身体验这世界的现实和残酷，承担责任，接受挑战。 除非你有特殊的人生选择，否则进入社会将与未来要经历的择偶、结婚、生育等一样都是这辈子的大事。你得认真面对问题和处理事情，不能再稀里糊涂的混日子。如果你不是富二代或官二代，那以后的日子基本得靠你自己了。 这样挺好，你的人生终于开始动真格的了。","text":"毕业接触社会是人生的又一次挑战。不论你的大学是如何度过的，成绩好坏，有无社会经验，是否准备充分以及是否愿意，在毕业的那一刻，你都将进入一个陌生的领域开始一段全新的人生旅程，并且你很可能再也回不到身后的象牙塔里去了。从此，无论前方是风霜雨雪，还是晴空暖阳，是陷阱沟壑，还是坦途平原，你都得坚持走下去。 希望你能有这样的心理准备：接下来要走的路，要打交道的人和组织、要经历的事以及评判你的标准，都将和你人生前20多年的经历完全不同，你将会亲眼目睹亲身体验这世界的现实和残酷，承担责任，接受挑战。 除非你有特殊的人生选择，否则进入社会将与未来要经历的择偶、结婚、生育等一样都是这辈子的大事。你得认真面对问题和处理事情，不能再稀里糊涂的混日子。如果你不是富二代或官二代，那以后的日子基本得靠你自己了。 这样挺好，你的人生终于开始动真格的了。 首先，从毕业开始，你的身份就不再是学生了，从今以后不论成绩荣誉还是挫折委屈，都需要你以成年人的身份去承受。 这对所有大学生都是第一道关。过这一关没那么容易，很多人在工作了多年之后，依然没顺利通过，言谈举止思维方式为人处世依然像个学生。 这些人的问题通常在于没分清这些：过去在学校里取得的分数和学历，只是教育体制对你的考核、评判以及要求，你付了学费，所以学校要为你提供服务。而在进入社会之后，对你的评判标准是你为社会或所在的组织创造的价值，你得为别人创造价值才能实现自己的价值，而且无论自己创业还是进入组织，都是如此，你都得对自己的言行和造成的后果负责， 如果你希望自己能快速成长，希望早日通过这道关，就要学会承担责任，这是你的第一步。 还有，你也许很快就会发现，外界的人和事似乎都是不以你个人意志和喜好为转移的。不管你的主观意愿如何，事情都照常发生，很少有人在乎你的感受，就好比你用手指着太阳和月亮痛骂100年，也不会让它们的光辉减弱一丝一毫。甚至你会觉得自己很渺小，无依无靠。而这才是真实的世界。 你将逐渐体会到人在社会中生存的艰辛和不易，你会逐渐明白眼下所经历的这些也是很多人都经历过的，你得开始培养自己的韧劲和坚强，它们是你在社会上打拼所必备的意志品质。 其次，做事要认真，并且得有点激情，得有个年轻人的样子。 认真与韧劲和坚强一样，都是你最应该坚持的品质，从长远来看它能带给你最大的收益。认真的人往往会得到更多的信任和更大的机会，因为没有谁愿意把重要的任务和责任托付给不认真的人，尤其是不认真的年轻人。 这里说的激情，指的是做事情要抱有积极进取的态度。 初入社会，人的内心都会有些忐忑，对于未知的世界，都心里没底。但不管怎样，你已经“下水”了，除了尽快学会游泳，获得在社会中生存的能力，你别无选择。你慢慢发现，除了爹妈，没几个人会真正担心你会不会淹死、关心你将游向哪里、能游多远。你不扑腾，没人能替你扑腾。 年轻的优势在于能承受失败，敢于试错，敢于担当。认真和积极的态度会让你得到更多的机会，在初入社会时，别犯懒也别患得患失，看准了机会就出手。 或许你以前在性格上比较蔫，做事主动性也不强，但在进入社会之后得赶紧调整自己。这个时代的发展速度和竞争激烈程度很惊人，对人能力的要求远超过去，如果你的态度和行为不积极，很难在社会中快速找到自己的位置。 再次，在灰暗和处于低谷的日子里，你得坚定信心，培养自励的习惯。 我打赌，你们当中很快就会有人得知自己的薪资水平之后产生受挫感，会瞬间觉得理想，房子，车子和美好生活都离自己很远，每天早出晚归挤地铁坐公交的日子也会让自己觉得很渺小，甚至每个月的薪水在帝都魔都等大城市租个离公司近一点的房子都很吃力，毫无归属感。 这时候你只能坚定信心咬紧牙关继续向前，你要明白对于家境普通的孩子，眼下经历的这个阶段几乎是必须经历的。 这不是煲鸡汤，你得把这个阶段有意识地当成对你的磨砺。每个人都会遇到机会，难点在于在磨砺阶段你得在咬紧牙努力谋生的同时努力做好准备，努力去学习和积累抓住机会所要具备的知识和资源。在这个阶段，你更多的得靠自己给自己打气，自己鼓励自己。实话实说，这一关很考验人。 有很多人都说过很感谢当年处于低谷时的那个一直没放弃努力的自己，他们说的都是实话。 初入社会遇到挫折打击出现停滞或反复时，你要保持耐心。 人与人之间在认知水平、个人能力、反应速度和方法手段上都存在着差异，适应社会的速度也有快有慢。 年轻人常想迅速打开局面站稳脚跟实现价值成就理想，但这个过程的速度快慢，是要具备一定的条件，而且存在偶然性。这世界上很少有一帆风顺的事，万事开头难，能在最初阶段就做出成绩的年轻人不多，因为年轻人通常都欠缺做成事情的能力和资源。 可能没多久，你还会发现有些在学校里没怎么努力但家庭有背景关系硬的同学的起点会比你高很多，比你混得好。这时，你得摆正自己的心态，别轻易地做自我否定，或认同那些会导致你平庸的观点。 很多人会把进入社会看成一次全新的超越别人的机会，但别简单地把它当作一次比赛。你和其他人往往从事的不是同一个领域，而你自己在成长的过程中的不同阶段的目标也是不一样的，你只需做好你自己想做和该做的事，不要把眼光窄化到总盯着同学和同事的薪水和职位，踏踏实实地尽快提高你自己的能力和价值才是最应该做的事。 如果你出身于普通家庭，没背景没人脉没资金，那你除了个人努力，基本上别无选择。而且你还得记住这句话：雄心的一半是耐心。从一开始就要踏踏实实把基础打牢。就如同盖个大楼要先打地基，该挖多深，该用多少号的水泥，该采用什么材质的砖，该采用什么建筑标准，都不能含糊，不能自己糊弄自己。 学习和积累是你一进入社会就必须养成的习惯，而且应该变成长期的习惯，。 这两点的重要性无需多言，不管你在校园里是不是混日子过来的，也不管你在学校里正没正经学习，一旦进入社会参加工作，你都得快点长本事。能否在没有老师，没有考试的状态下养成学习和积累的习惯，而且是长期的习惯，对于需要快速学习大量学习各种知识，迅速成长的你来说非常重要。 如果有条件，可以买个电子阅读器，多看书，别把上下班路上的时间都花在手机上，如果每周能读一本书，每年就是50本，在注意记录和整理笔记，三五年下来，知识储备的底子就打下了，那时候你思考问题的方式和看待事物和社会的角度将有很大的提升。 PS：初入社会，在认真工作之余，超越别人的奥秘都在工作八小时之外，关键看你怎么利用时间。 进入社会和职场后的首要目标是早日令自己拥有不可替代性。 所谓不可替代性，通俗点讲就是什么事是只有你能做到而别人做不到的，什么工作是缺了你就玩不转的，什么技能是只有你会而别人不会的，什么资源是只有你有而别人没有的，什么角色是只有你能担当的而换别人就不行的。 即使在短期内你不能在行业范围内拥有不可替代性，也要努力在组织和公司内部拥有。越早具备不可替代性，你的价值就会实现得越早，薪资待遇就会与你的价值更匹配，在职场的竞争力就越强。 PS:一个判断自己价值的方法：工作几年后，是否会有猎头给你打电话给你推荐职位，这是个小信号。在此之前，基本上你的价值都很有限。 尽早做决定：自己究竟适不适合在大城市发展，究竟适不适合离开爹妈在北上广深等大城市做个单枪匹马的“兰博”。 这条算个小提醒吧，你要想清楚自己内心更看重的是什么，追求的是什么，并估算出你要付出的成本和代价。 如果你现在还不清楚的话，可以在大城市先折腾几年再做决定。人有梦想是好事，但不是每个人都适合做北上广深做“兰博”，幸福未必只有在大城市才能得到。 还有个提醒：有很多人在大城市努力了很久，却一直没有突破，这时要多反观自身的能力。有些人能做到的事，换个人未必也能做到。这世界并不是努力就有回报，而是能力、资源和运气都具备了，机会才有可能被你抓住。 千万别忽略自身具备的能力和资源，只怀着一颗热情执着的心与不切合实际的目标死磕。人的奋斗过程有些类似于上台阶，如果你经过长期努力但连最基础的台阶都上不去，那你就应该慎重考虑了。 再送剂预防针： 理想和现实是有差距的，刚毕业的大学生初步体验了社会之后，可能会多少有些失望，甚至更加迷茫，为自己的前途和处境上火、闹心、焦虑。这都是正常状态，说明你有进取心。其实，每个年轻人要面对的事和要学习的东西都很多，除非你是富二代，有爹妈帮着铺好了路，搞定了一切，否则作为普通家庭出身的你，如果天天都睡得着睡的香，什么也不合计，什么也不琢磨，未必是好事。 最后送一段话，特别送给那些在大学期间没认真学习，迷迷糊糊就毕业走进社会的年轻人： “我们常常有勇气改变，因为这只需要一个晚上的鸡汤。我们往往没能力改变，因为这真需要经年累月的苦干” 加油。创建于 2016-11-24作者保留权利 发自我的华为手机","categories":[],"tags":[{"name":"others","slug":"others","permalink":"https://vlwq.github.io/tags/others/"}]},{"title":"25岁前你必须要做完的7件事","slug":"2015others/20160822","date":"2016-07-25T02:36:00.000Z","updated":"2022-03-03T03:40:37.543Z","comments":true,"path":"2016/07/25/2015others/20160822/","link":"","permalink":"https://vlwq.github.io/2016/07/25/2015others/20160822/","excerpt":"人生中有很多要做的事情，也一定会有更多的缺憾，无论你怎么拼了命去做，都会留下遗憾。 我知道你我都会活得没那么容易，我愿你是活得潇洒精彩的人，别沦落到中年时热血已凉，回忆年少轻狂的梦，没一件做成，心酸又心凉。 趁你在还可以犯错的年纪，趁你在犯错还可以挽回的岁月，趁你还没有太多牵挂时，做完这7件事。","text":"人生中有很多要做的事情，也一定会有更多的缺憾，无论你怎么拼了命去做，都会留下遗憾。 我知道你我都会活得没那么容易，我愿你是活得潇洒精彩的人，别沦落到中年时热血已凉，回忆年少轻狂的梦，没一件做成，心酸又心凉。 趁你在还可以犯错的年纪，趁你在犯错还可以挽回的岁月，趁你还没有太多牵挂时，做完这7件事。 25岁前你必须要做完的7件事 我不愿你有一场不管个人安危说走就走的旅行，也不要你接受什么大学没挂过科没谈过恋爱就不完整这种烂鸡汤，更不希望你还没拥有过人的实力前就学名人们退学。 人生中有很多要做的事情，也一定会有更多的缺憾，无论你怎么拼了命去做，都会留下遗憾。 我知道你我都会活得没那么容易，我愿你是活得潇洒精彩的人，别沦落到中年时热血已凉，回忆年少轻狂的梦，没一件做成，心酸又心凉。 趁你在还可以犯错的年纪，趁你在犯错还可以挽回的岁月，趁你还没有太多牵挂时，做完这7件事。 过了25岁，你的人生不会再是你一个人的了。 好自为之。 第一件事：要有个一辈子都喜欢的爱好人可以为很多东西活，为名利活，为自由活，为自己活，为别人活。 在我大学快毕业时，我终于醒悟：无论哪一种活法，都不可能真正自由。 每一种活法，都有它迷人的地方，更有它无奈的地方。无论你选择了哪一种活法，你都有一个一辈子都喜欢的爱好，它不一定给你带来名，带来利，它只会在你疲惫不堪时，做起它时，你会笑，你也会哭。 笑得开心，哭得解忧。 你要有这样的爱好。 第二件事：有一份足够养活你的工作过了25岁，你不可以再跑到父母怀里又哭又闹了，你更应该去照顾他们。 你的人生中当然会遇到很多很多愿意照顾你的人，可是啊，你也要学会照顾别人，照顾自己。 我知道你想任性，任性之前先让自己有任性的资本与能力吧。有一份足够养活你的工作，并且是你喜欢的事情。 不要和我说没办法做自己喜欢的事情，要知道，只有做自己喜欢的事情才更有可能获得更大收益。 这一份让你能够想吃什么就吃什么想去哪里就去哪里的工作，是你任性的底气，最最基础最最普通的底气。 第三件事：有一个可能要花几十年才能完成的目标当你有了可以爱一辈子的爱好，和一份让你足够养活自己的工作后，你不可以就此满足了。 要知道，人总是在满足中变得平庸的，你不可以只待在舒适区。 你要明白，呼唤你每早起床的最大动力是什么，不要告诉我是为了赚吃饭租房的钱，那不该是你人生的最后归宿。 你要有一个可能要花几十年才能完成的目标，哪怕它看起来有多疯狂，你也要不断朝着它迈进，不管你最后有没有成功，这个目标都是你在25岁前要找到的。 就像你的梦想是触及星辰，我们都明白，穷极一生你也摸不到它，可你为了摸到它，站在了少人可及的最高峰。 第四件事 完成一件你中学时期的梦想很多人说：莫欺少年穷。 你有多少少年时的梦，都随着年纪增长搁置到一旁了？你是不是偶尔想起时，还会自嘲，摇摇头不再去想。 你对得起年少的你吗？那时候的梦，真的有那么难实现吗？ 去做吧，中学时期的你或许有100个梦，碎了99个梦又如何，在你还没有真正老去的年纪，就不要学着真正老去的人倚老卖老，去做，去做，去做啊。 当你完成了一件少年时的梦后，你永远也不会老去。 第五件事：看完100本好书在日渐浮躁的如今，我仍想将生活过成诗。 无视那群鼓吹“读书无用论”的愤青吧，没用的人做什么都无用，强悍的人喝鸡汤都能成就一番事业，读书从来不是让你功成名就，读书是教会你如何更轻松更有趣地活。 绝大多数人的人生，活得都过于疲惫，过于无趣了。 不要带有功利性去读书，更不要读那些毫无意义的书，在25岁前，慢慢读，认真读，读100本真正经典的书。 那时候的你，会更知道你为什么活。 第六件事：独自走过10座城市你之所以活得狭隘无知，是因为你不知道世界是什么样子的。 哪怕你活在信息爆炸的互联网时代，你在书上了解的，你在视频里看见的，你听阅历丰富人说的，都不代表你真的明白世界上其他地方的人的生活。 你不会知道千里之外的城市街头会有怎样的风景，更不会知道某个咖啡屋里正认真画图的女孩也许和你志同道合，你永远都不可能知道，你为何和他们不同，你为何和他们相同，除非，你走出去。 不要穷游，我从来不赞成所谓的穷游。 第七件事：不要因为寂寞恋爱，遇上正确的人就立刻爱爱情与婚姻或许是生命中的必需品，但不是作业题，更不可以着急。 在25岁前，不要因为寂寞谈恋爱，你会浪费了自己的感情，糟蹋了别人的时间，最好的感情本应该留给最好的人。 如果没有遇见合适的人，不要因为身边的人怂恿，去谈一场无疾而终甚至因不爱也生恨的恋情，太不值得。 如果遇见正确的人，不要想以后，不要考虑现实，人生中已有无数错过，你真甘心难得心动的人在你面前远去？ 哪怕最后的结果不尽人意，你也要奋不顾身去爱这个来之不易的人。 说不定，到最后，她会是陪你走过一生的人。 25岁前，你要做完这7件事。 有些事，你不做，真的来不及了，你的青春，比昙花都还要短暂。","categories":[],"tags":[{"name":"others","slug":"others","permalink":"https://vlwq.github.io/tags/others/"}]},{"title":"执行力","slug":"2015others/20160304","date":"2016-03-04T02:36:00.000Z","updated":"2022-03-03T03:40:35.167Z","comments":true,"path":"2016/03/04/2015others/20160304/","link":"","permalink":"https://vlwq.github.io/2016/03/04/2015others/20160304/","excerpt":"前几天和一位初中好友一起吃饭，我和他的友谊，从那个时候开始，至今都没有中断过，经常出来喝喝酒，拉拉家常，谈谈人生理想。 吃饭的期间，他跟我说，再过一个月，自己就要辞职出来创业了。 我第一次听到这个消息时，说实话，还是挺惊讶的，毕竟他才刚刚毕业两年多，按照常理来说，现在工作应该才步入正轨，怎么就要出来创业了呢？ 那天和他聊完，再到后来和一些跑得比较快的同龄人聊过之后，我才发现，毕业三年，混得好的同学，其实已经和其他的人，拉开了越来越大的差距。 有的月薪过两万，有的出来创业，有的组建了自己的小团队，各有各的精彩。 其实我关心的不是差距的大小，而是那些跑得快的人，他们究竟是怎么做到的？","text":"前几天和一位初中好友一起吃饭，我和他的友谊，从那个时候开始，至今都没有中断过，经常出来喝喝酒，拉拉家常，谈谈人生理想。 吃饭的期间，他跟我说，再过一个月，自己就要辞职出来创业了。 我第一次听到这个消息时，说实话，还是挺惊讶的，毕竟他才刚刚毕业两年多，按照常理来说，现在工作应该才步入正轨，怎么就要出来创业了呢？ 那天和他聊完，再到后来和一些跑得比较快的同龄人聊过之后，我才发现，毕业三年，混得好的同学，其实已经和其他的人，拉开了越来越大的差距。 有的月薪过两万，有的出来创业，有的组建了自己的小团队，各有各的精彩。 其实我关心的不是差距的大小，而是那些跑得快的人，他们究竟是怎么做到的？ 1， 行业和平台很重要。 不知道是谁曾经说过：站在风口上，猪都能飞起来，这里的风口，你可以理解为平台的意思。 前不久咪蒙助理月薪过五万的消息，刷爆了朋友圈，我一位做传统行业的朋友，看得十分眼红，直呼凭什么。 同样都是在打工，同样都是在付出劳动，同样都是刚出社会不久，为什么有人就可以做到日入2千，有些人拼死拼活，每个月都还要掐着手指来过日子？ 说到底，都是行业和平台的不同，造就了这样的一种局面。 试想一下，同样都是一个专业出来的大学生，一个毕业之后去了传统的商业地产行业，一个毕业之后去了腾讯或者华为，两三年后，哪个同学的发展会更好一点？ 我想，你应该能猜出来是哪个。 因为资本，人才，信息不断地往新兴的行业靠拢，导致这些行业的发展极为快速，而传统行业，不仅有时候千年不变，上升通道极为狭窄，而且所属的行业，还不断下滑萎缩。 那些毕业两三年，就实现自己巨大跨越的同学，无不是依托于高速发展的行业和平台：电商，移动互联网，游戏，金融，等等。 在这些行业里，只要你足够努力，就能获得超额的回报，而在传统的行业里，无论你怎么努力，怎么奋斗，都不可能与整体衰败的外部环境相抗衡。 和我经常来往的初中同学，大学学的是食品检测，毕业之后，经过仔细地分析，认为电商会持续不断地发展，于是全身心投入到电商公司里面去，几乎可以说是All—In的状态，经过这两三年的努力和积累，不仅实现了月入过5万，还有底气出来创业单干。 这是很多人在传统行业里，想都不敢去想的事情。 2， 努力，努力，再努力。 其实我和他在初中认识的时候，他的身上，就有一种韧劲。 每次考试，都会拼尽全力，就为了多拿多几分；每次背单词，都会比设定的目标，多背几个；每次做数学习题，不单单只要求自己掌握一种解题方法，而且还不断地向别人，老师请教其他的解题思路。 这样的一种努力和勤奋，一直延续到了大学，紧接着跟随他步入了职场。 有人常会说：努力会成为一种习惯。 这种从小养成的努力状态，可以让你节省很多的意志力资源。 因为每次当你需要更加努力地投入到工作当中去的时候，你会自然而然地去用力，去沉浸其中，而不是次次都还没有开始做的时候，就表示自己做不到，不想做，或者干脆逃避。 像我的初中同学，从一开始，就保持着努力的习惯，所以，对他来说，多干一点活，多做一点事情，多学一点知识，这些所谓的“超额”，都是理所当然的，都是名正言顺的，都是可以理解和接受的。 反观有些人，在还没有努力的时候，就觉得自己已经用尽全力的样子，为公司，为部门多做一点事情，就觉得整个人被欺负了一样，业余的时候，根本就不想怎么去提高自己的技能，也不琢磨如何才能变得更好，更加优秀。 想要得到什么，你就得拿东西出来置换，这个道理，是亘古不变的。 如果你甘于平庸，那就不要做什么英雄梦，如果你总觉得自己的理想还有抱负没有实现，那就打起精神来，穿上铠甲，去战斗，去屠龙。 不要每次都说自己这样不行，那样不想要，试试转变下自己的思维方式，面对美好的事物时，多问问自己： 我怎么样才能得到它？ 每一次的内心消极对话，无疑都是在慢性自杀，而只有正视自己内心的声音和力量，才能激励你不断地往前走。 一个是让你后退不止，一个是让你不断前行，你应该知道怎么做选择。 3， 不是光想不做，而是有强大的执行力。 如果我现在跟你讲一个非常好的idea，大概有50%的人听进去了，在这50%的人里面，有40%的人有去做思考，在这40%的人里面，只有不到10%的人会去执行。 实际上，这个世界从来不缺乏好的想法，只是大道理谁都懂，但却没有人真的想要去执行。 谁都知道早起早睡身体好，谁都知道坚持健身，可以让你保持身体匀称协调，谁都知道无论多忙，都要挤出时间来进行自我增值和提升。 但有谁真正去做了？又有谁真正做了，还不间断地坚持了下去？ 每个人都想按照自己最为舒服的状态来过日子，谁都不想逼着自己去走出自己的舒适圈，所以，在面对外部环境带来的巨大不安全感时，很多人宁愿选择口头上的宣誓，也不愿意动起身体，去立刻执行。 口头上的宣誓，可以让自己的内心，得到抚慰，可以自己给自己营造一种假象：“我做到了”，而行动呢，却带有更大的不确定性，因为你不知道现在行动了，究竟能不能给你带来收益，于是看似理想的选择，其实让你次次成为思想上的巨人，行动上的侏儒。 我的初中同学，有一次在和部门经理开会的时候，因为有一份紧急的文件需要去处理，但部门经理又分身乏术，忙不过来，这时候，我同学主动请缨，接下了这个任务，连夜加班将这份文件给出色地完成好。 大部分人，都是在晚上睡觉前，信誓旦旦地对自己说： 我要这个，我要那个。 明天早上起来，依旧是按照自己的老路走到底，你叫他去做，去改变，去追求梦想，比登天还难。 想了不做，等于白想。 希望对你们有所启发。 感谢阅读。","categories":[],"tags":[{"name":"others","slug":"others","permalink":"https://vlwq.github.io/tags/others/"}]},{"title":"目标-三十而立","slug":"2015others/20160301","date":"2016-03-01T02:36:00.000Z","updated":"2022-03-03T03:40:32.650Z","comments":true,"path":"2016/03/01/2015others/20160301/","link":"","permalink":"https://vlwq.github.io/2016/03/01/2015others/20160301/","excerpt":"我今年41岁了，古人说三十而立，四十不惑。不敢妄称“不惑”。职业生涯几经起落，最终走上了创业的道理。家有两个调皮的女儿。成家立业的立算是做到了。 这里的“立”，我的理解，并不是指事业或者家庭，而是一种承担责任的能力。 这种能力，并不是随着年龄的增长就能获得，它需要你转变自己的思维模式，去不断挑战自己，训练自己，最终才能得到真正的成长。","text":"我今年41岁了，古人说三十而立，四十不惑。不敢妄称“不惑”。职业生涯几经起落，最终走上了创业的道理。家有两个调皮的女儿。成家立业的立算是做到了。 这里的“立”，我的理解，并不是指事业或者家庭，而是一种承担责任的能力。 这种能力，并不是随着年龄的增长就能获得，它需要你转变自己的思维模式，去不断挑战自己，训练自己，最终才能得到真正的成长。 你问我：你经历过哪些思维上的转变？ 一个让我获益良多的改变是： 我意识到，很多时候我们停止成长，是因为一时的成绩让我们骄傲和固执，使得我们不再去探索更多可能性。只有怀着空杯心态，我们才能获得更多的成长。 这里，我想讲讲自己的故事。 刚毕业那会儿，由于很想做市场营销，所以辞去了收入更高的记者的工作，去做了最底层的销售代表。 由于什么都不懂，所以一切对我来说都是困难的。但同时，一切对我来说，又是新鲜的。 譬如，有一次批发客户“发难”，说半年前进的一批卫生巾的背胶粘不牢，要退货。按照规定，半年前的产品是不能做退货处理的。好说歹说，客户就是坚持要退。 那时候我不知道该怎么办，就去请教了一些经验更丰富的“老”销售，但他们也说这事也没有太多很好的办法，说要不就退了呗。 但作为初生牛犊的我，并不觉得有什么事是不可能的，一定有解决的办法。 可能是比较楞的缘故，最后我决定亲自试验这批卫生巾，身为大老爷们的我把一片卫生巾贴在自己的内裤上，之后一天走街串巷，下班后还打了一场篮球，并没有出现脱胶现象。第二天和颜悦色地跟批发商说，大姐这批卫生巾我亲测过，粘得很牢。批发商又好笑又好气，也就不再提退货的事了。 功不唐捐，半年后，我成了正式员工，之后，更是成功转岗，到了品牌部门。 但是，当我在公司呆了几年之后，在不知不觉中，变成了当初请教的那些“老员工”那样。 虽然业务能力得到了很大提升，但思维模式得到了固化，做事更多的开始依赖过往的“经验”，而不去思考它的其他可能性。 我再也没有像当初那样，把卫生巾贴自己内裤上，跑一天试验它到底粘不粘的牢。 换言之，我封闭了自己成长的边界，停止了进一步的成长。 有一次，我接到了一个非常棘手的项目，出于经验，我判断很多地方是不可能做到的，所以当时就在反驳，一条条说明，哪些地方是不可能的，因为什么什么。 的确，在业务水平方面，我是当时全组最强的，所以当我听到一些不太合理的要求，我都是嗤之以鼻的，觉得领导很外行，很傻比，一定要反驳。 但那时候新进来的几个新人，却一直在努力思考，尝试着各种可能性。 后来，我就没管了，跟进了其他的项目，并觉得那几个新人都是在做无用功。几天之后，我惊讶的发现，那几个实习生做出了我以前从没想过的方案，而且所有问题都得到了巧妙的解决。 我十分震惊，并且羞愧。 我震惊于他们的成功，我羞愧于我的轻慢。看到他们，我仿佛看到了当年的自己。 “我以前不也是那样的吗？怎么现在变成了这副模样。” 痛定思痛，我开始有意识的让自己不再去轻易说“不可能”，我收掉了自己的傲慢，而是积极探索一切可能性。 之后的几年，我的成长速度非常快，而且开始领悟到工作的真谛—— 工作并不是生活的对立面，它是生活的一部分，不能享受工作的人，也无法真正享受生活。 没有思想上的转变，我之后也不会几次离开较高的职位、选择在新的岗位、公司从零做起（这些经历可以写一篇新的回答了，敬请期待）。 在2015年离开宝洁前，我曾任年薪百万的市场总监职务，负责过几十亿年销售额的国民洗发水品牌的营销工作。之后我还是走上了创立自己的氨基酸洗发水品牌的道路。我们这个月刚完成了数千万的A轮融资，天猫双十一也做到了美发护发类目的第11名。妄论成功现在还太早，这在资本寒冬的当下也算是不容易了。 现在，我有了自己的公司和一起奋斗的小伙伴们。我能看到像当初刚工作时的我那么拼的，但也能看到像工作了几年以后的我的那种年轻人，我能看到他眼神里对工作的痛苦和煎熬。 每当这个时候，我就会跟他讲我的故事，告诉他，我也是这么过来的。做为公司的创始人，我最希望看到小伙伴眼里闪着的光芒。41岁的我还充满着激情和梦想呢。20多岁的人不要跟我说你已经没有激情和学习的动力了。 Stay hungry and stay foolish！ 最后，我想啰嗦几句提一些具体的建议： 1，不要轻易说不：工作、生活中遇到问题，不要轻易放弃，不要轻易说“不可能”，而是积极去思考它的可能性。这里面，蕴含着宝贵的成长机会。 2，不要轻易跳槽：工作里遇到问题，往往可能是你自己的问题，虽然跳槽之后，你因为新的环境，一开始会打开自己的边界，积极学习，但一旦熟悉了业务模式后，你又会变成那个故步自封的人，新的问题又会接踵而来。所以不要轻易跳槽，而是去想自己的问题在哪里。 3，不要天天熬夜：熬夜并不意味着工作时间的增多，它只能让你的工作效率下降。而且年轻的时候觉得熬夜没什么，但要知道，你25岁要是继续熬夜，熬到30岁，很大可能你会变秃。 4，不要忽略家人：家人比任何事情都重要，25岁以后往往会因为工作繁忙，很少有时间能与自己的家人在一起。但你至少需要多去和他们沟通，聊聊自己的生活，不要多年以后去悲叹“子欲养而亲不待”，后悔自己年轻的时候什么都没做。","categories":[],"tags":[{"name":"others","slug":"others","permalink":"https://vlwq.github.io/tags/others/"}]},{"title":"颈椎病","slug":"2015others/20160203","date":"2016-02-03T02:36:00.000Z","updated":"2022-03-03T03:40:30.345Z","comments":true,"path":"2016/02/03/2015others/20160203/","link":"","permalink":"https://vlwq.github.io/2016/02/03/2015others/20160203/","excerpt":"本文内容包括：症状，诊断方式，治疗方式，三部分。 01 我是在2015年5月，才知道自己得了颈椎病。 可笑的是，在这之前的N年里，虽然有一堆症状，我却对颈椎病一无所知。能够确诊，也是因为偶然。 当知道了颈椎病后，才发现，原来身边的人，只要常办公室，或是常对着电脑手机的人，竟然都有颈椎病症状……何其可怕…… 医生说， 曾经在他的课本中，老年后才会高发的病症，却因为手机IPAD电脑的普及，开始有越来越多二十一二岁的病人。","text":"本文内容包括：症状，诊断方式，治疗方式，三部分。 01 我是在2015年5月，才知道自己得了颈椎病。 可笑的是，在这之前的N年里，虽然有一堆症状，我却对颈椎病一无所知。能够确诊，也是因为偶然。 当知道了颈椎病后，才发现，原来身边的人，只要常办公室，或是常对着电脑手机的人，竟然都有颈椎病症状……何其可怕…… 医生说， 曾经在他的课本中，老年后才会高发的病症，却因为手机IPAD电脑的普及，开始有越来越多二十一二岁的病人。 02 颈椎病会有很多看似不关联的症状，然而细究其原因，还是能得出一些端倪的。 因为连接大脑，而大脑又掌管全身，当颈椎出问题时，最大的影响是——大脑。 想象一下，颈椎动脉是一根粗水管。水管在弯折扭曲的时候，会受到挤压——我们小时候应该都玩过呲水的游戏，当挤压水管时，水管变细，能通过的水流量变小了，但水管内的压力更大，水花呲得更远了。 对颈椎动脉来说，也是如此。 颈椎变型，动脉受到挤压。结果是，一方面，流向大脑的血液变少了，另一方面，血流的速度也更快了。 这两个状态，导致了很多问题的出现。 大脑供血减少时，最先出现的症状是——记忆力减退、易困嗜睡。长期脑供血不足，会引起大脑的损伤。大脑为了避免这种结果，会命令心脏更加积极地供血，于是又出现了心跳过快的症状。 血流的速度更快时，对血管的冲击力也变大了。血管不断承受着高频次的冲击，于是产生了头痛问题。 在年轻时，血管弹性较好，不会出现较大的危险。然而，随着年龄增长，血管弹性降低，面对冲击时，最可怕的后果，是脑部血管爆裂，颅内出血……（当时医生为了让我重视问题，把后果说得很严重）。 头供血不足，脸上皮肤差，脸色不好，这都算小事。更难受的是干眼症。 可能因为眼部都是毛细血管，毕竟血液都优先供脑了，眼睛顾不上吧，于是眼疲劳来得很快，渐渐的泪液也分泌得越来越少。眼皮内侧，其实是一堆鸡皮疙瘩似的不光滑的平面，平时全靠泪液润滑。当没有泪液时，每眨眼一次，眼皮内侧都像刀片一样刮眼，疼痛难忍…… 心脏长期快速跳动的时候，人也很容易疲惫，经常觉得累，做什么都需要一会一歇息。 当心脏加速供血，还脑部缺血时，人体会有应激反应——呕吐、眩晕，无法直立，必须躺倒休息。到这一步时，其实颈椎病已经进入的非常严重的地步了。 还有的症状，还包括手脚麻等症状（然而原理未知，我忘问医生了） 我的症状出现的很早，持续了不少年。 进入2015年时，已经非常严重了 。当时每天都在头疼，脑门随手一捏，就出来一道道紫色印子。平时静止状态的心跳一直在110以上，下班回家15分钟的步行路程，也需要中途休息个两三次。 再后来，频繁地头痛呕吐，开始影响到工作了。那段时间，又遇到个同行加班后突然猝死的新闻，导致我心理压力也很大，于是终于不敢再拖延，开始了治病岁月。 03 上面说的，都是自己很容易观察到的表面症状。 确诊的话，确切地说，需要到骨科做两项检查：颈椎X光片，和TCD脑血流检测。同时也建议挂一下心内科，检查一下心脏。 骨科的检测，类似下图这种。（我在2014年底就拍了X光片显示颈椎变直，然而当时的医生却没重视，后来重复走了很多冤枉路，所以碰上一个好医生也是不容易……） TCD检查，学名叫经颅多普勒检查，原理就是检查脑部血液流速。流速过快的话，结果会显示“动脉痉挛”，最多的结果，好像就是3个部位痉挛吧。 （我拿着3个部位痉挛的结果时，医生很震惊，说这是他当时见过的最严重的病人……） 然而我却从14年12月一直到15年的5月间，无数次的波折。跑过N家医院，内科，外科，脑病科，骨科，肺病科（当时肺也不好，不戴口罩就咳），眼科（因为干眼症），针灸科，挨个科室，轮流挂号。就是这么两个检查，就能确诊的结果。 脑部拍过核磁共振，吃过癌症止痛的药，做了很多检查，却听了太多的医生说“无法解释头疼的原因”。 后来一个信任的内科医生随口说，颈椎也会引起头疼，建议去骨科做个检查。然后我才决定，再去一次骨科。 先挂了一个号，随机碰了个医生。我说头疼，不知是不是颈椎的问题，医生看了我一眼，什么话也没说，直接开了两盒膏药，就让我去付费。 我顿时觉得被唬弄了。于是又去重新挂了个号，换了个医生，这次的医生叫汤俊，终于被重视了。 做完TCD检查，他又解释一遍原理，症状和原因一对照，我顿时拔开迷雾，豁然开朗了。 后来我的颈椎病能治好，也是亏了这个医生。 （一直想给他送个锦旗，然而因为人懒……如果汤医生能看到这篇文章，很想说，汤俊，谢谢你治好我！） 04 前面说了外部症状、确诊的检查方式。 然而谈到治疗，就不得不先说，为什么会得。 医生解释说，无论是颈椎病还是腰椎病，本质上都是肌肉无力，肌肉不能分担受力，就会造成骨头受力太大，从而在弯曲后，无法再恢复到初始状态。 治疗方式上，推拿、牵引、包括后面我要说到的颈椎枕，都是属于用外力，强行将骨头复位。然而这种方式，治标不治本，还会复发。 最根本的方式，其实是加强自身的肌肉力量，强有力的肌肉，会自己将骨头推回原位，并在后续的时间里，帮骨骼分担压力，从而防止复发。 上海中医医院（汤医生在的医院）的治疗方法，其实就是刺激肌肉生长。 针灸颈部的四个穴位，针上连着电线（电池供电），然后用微弱的电流，刺激穴位周围肌肉纤维的生长。 治疗的过程中，确实能感受到变化。最初针灸时，针扎入皮肤，没几分钟就掉出来了，然后就得召唤医生来补针。一个小时的治疗，需要叫四五次医生。 医生也很无奈，解释说，针扎到皮下，肌肉纤维会包裹住针。所以，如果肌肉萎缩，纤维无力，裹不住针的，就会掉出来。 治疗一段时间后，最明显的变化是，针终于不掉了。医生看了也很高兴，说你肌肉纤维终于有点力量了，扎针时也终于能感觉到有弹性了，不像刚来时，扎进肉里感觉像扎到纸里似的。 我还是每一个多月去做一次TCD检测。到了11月时，X光片也显示正常了。 从确诊颈椎病，直到治疗结束，历时5个多月，这期间每周两次去医院治疗。05 然而我知道，这种治疗方式，不是所有人都能够接受。一方面，不是每家医院都能治，另一方面，长时间的请假也不是所有人都能接受的（比如我那年的升职加薪年终奖，就统统消失了……）。 所以如果无法医院治疗的话，就只能自己锻炼肌肉了。 再补充几个我自己的经验： 1、当剧烈头痛爆发时（甚至开始呕吐时）：这是大脑的应激状态开始了，只能立即平躺休息了，再强忍着做各种事，很可能会造成脑损伤。不过我在亲身检测中，发现《藿香正气口服液》能很快缓解症状。（原因未知。我一度怀疑，是不是因为其中含有酒精，从而使血液循化加快，进而缓解了脑供血不足） 2、当长期头痛，身体虚弱时，可以考虑颈椎枕（外力方式）。颈椎枕就是一个圆柱型的枕头，睡觉时垫在颈部。可以淘宝买，也可以自己用杂志卷一个筒，外面包上毛巾。但需要注意的是，这种外力改变颈椎弧度的方式，是短期治标不治本的方法，该锻炼仍要锻炼。 3、长远来看，最终的方式仍是肌肉的恢复。比如，打羽毛球，放风筝，游泳 有一个从老中医处讨来的颈椎运动偏方，也满有效。 这个方法，用一句话描述就是：用下巴画最大的圆弧。下巴前伸，然后向下，再向后尽力缩，再向上尽力仰。（做的时候要小心，正常人做是没问题的，然而肌肉无力的颈椎病人做，会听见骨头咔咔作响的声音……） 写在最后，帮毛毛同学做个推荐。 她是关注我很久的粉丝了。 6月5日， 她将开一个免费直播， 会有专业的健身教练来分享 如何改善肩颈问题。 http://weixin.qq.com/r/dirL0zTE5WmarXCw939k (二维码自动识别) 蜜圈小课堂第1期｜不良坐姿会导致圆肩驼背？教你如何缓解肩颈不适，远离不良体态。欢迎点击链接，报名参加。","categories":[],"tags":[{"name":"others","slug":"others","permalink":"https://vlwq.github.io/tags/others/"}]},{"title":"别给自己找借口","slug":"2015others/20160123","date":"2016-01-23T02:36:00.000Z","updated":"2022-03-03T03:40:22.279Z","comments":true,"path":"2016/01/23/2015others/20160123/","link":"","permalink":"https://vlwq.github.io/2016/01/23/2015others/20160123/","excerpt":"我经常能收到各种回复、提问、私信，有五种我不会回答，有这五种思维的人在现实生活中，我也会尽量远离，这是我爸活着的时候教我的。后来我一位广东朋友跟我说，这不是我爸一个人悟出来的，这是一种在他们那边流传很久的智慧，用广东话讲“费神教会你”。","text":"我经常能收到各种回复、提问、私信，有五种我不会回答，有这五种思维的人在现实生活中，我也会尽量远离，这是我爸活着的时候教我的。后来我一位广东朋友跟我说，这不是我爸一个人悟出来的，这是一种在他们那边流传很久的智慧，用广东话讲“费神教会你”。 给自己找借口 我收到很多人抱怨自己特别有天赋，被家庭环境所耽误，有些人的确是，这我不否认。但是如果你继续在抱怨的泥潭里，谁也帮不了你。你必须行动起来，改变这一切，大多数时候，尤其是你成年以后，很少有人能干涉你的生活，除了你自己，只有你自己同意。 有位姑娘抱怨“我视野不够是被家庭条件所限，父母没有钱让我环游世界，开拓眼界，所以我发展一直不好。我该怎么办？” 我爸妈也没给我钱让我环游世界去，不光如此我和妹妹还都是大学家里就不再给钱了，我和妹妹的大学假期都是在打工中度过的。可我妹妹在大学就帮助瑞士老师做过设计展。 开拓视野，真的只有环游世界这一个办法吗？你不思考总结，你环游了世界又怎么样。人生开拓视野读书、见人、行路、历事都可以，没钱环游世界，读书不就行了？没钱买书，大学图书馆又不收费，多读点书不就行了。为什么《认识商业》《沟通的艺术：看入人里，看出人外》《成功心理学：发现工作与生活的意义》在开头章节都通过总结、评测进行自我认知。我们必须了解自己，正视自己，学会承担责任，为自己的决定负责。你自己被家庭条件阻碍，视野不够，又有几个人的父母资助他们的孩子环游世界去了？你如果不正视自己之前的错误决策，继续为自己找借口，那就只能被困在原地。 大学没有利用好，那毕业后就好好努力呗！为自己找了借口，是舒服了，心理安慰了。潜意识，也会觉得反正不是我的错，那我就继续这样呗。这种思维方式何谈改变呀？！ 偷换概念 这种人更可怕，我们北京俗语说“干什么不吆喝什么”，“你说前门楼子，他说胯骨肘子”。 比如我们如果想吸粉成为大号，那就充分搜集信息，找到渠道、学习写作技巧。大家聊天也是围绕这个，可是善于偷换概念的人，他思维是跳跃的，他不围绕这个。 有个人问抱怨他文章浏览量低，我说你提高文章质量看的人就多了。他说你是红人，所以浏览量高。 他问你怎么能在短时间内让微信公众号粉丝多起来。我给了他几个平台，建议他写完文章都发发。他说“你怎么这么浮躁。” 有个姑娘单身，问我怎么能够建立亲密关系，我给她推荐《沟通的艺术：看入人里，看出人外》里关于亲密关系的章节。她说“跟男朋友耍心机，感情得不到好结果。”你跟你妈不讲沟通技巧，你妈都讨厌你，别说跟男朋友了。讲沟通技巧怎么就变成耍心机了？你跟他保持亲密关系，进行语言和非语言沟通就变成耍心机了？ 不要觉得这是个例，大家可以看看我浏览量几十万的《如何通过爱好赚钱》那篇文章，有几十个回复都是“做自己喜欢的事赚不到钱”，你赚不到钱是能力不行，跟做自己喜欢的事有什么关系？我一直做自己喜欢的事、特立独行的猫一直做自己喜欢的事，我们没有比别人赚钱少呀？赚钱这个事，跟你的能力、思维逻辑有直接关系，跟你喜欢不喜欢你的工作，没什么关系。三百六十行，行行出状元。《理解未来的7个原则：如何看到不可见，做到不可能》用整本书讲如何赚钱，明确提出周期性和线性的决定性作用：周期性变化告诉我们许多种不同的确定性。人类已经找出300个显著的周期，可以在某种程度上精确的预测未来。莎士比亚说：世间事，也有涨潮时节，及时把握，终可功成名就。 这种偷换概念的思维方式、沟通方式，是最好的拒绝别人分享的方式。因为沟通太累，大多数人都会闭嘴，有这种思维的人因为沟通效率差、做事效率低、抓不住重点会被处处受限。 看什么都是“鸡汤” 直接上个截图当例子，大家就明白了。 正常我们的逻辑，我会问怎么当上旅行体验师？这个工作前景如何？薪水如何？需要什么技能？工作内容是什么？ 逻辑思维的关键是“学会提问”，以开放式的心态，学会提问，你学习知识的途径就是一个立体的 ，随时随地都在接受信息，都在吸收知识，这也被称为“淘金式”思维。 相反，截图里的这个例子，是封闭式思维的学习方式。想有孩子，以后会做家长的人千万要注意，教育孩子一定要确认孩子的思维方式，在上学前，教会孩子开放式的思维方式，让孩子学会主动摄取知识，这样孩子学习轻松成绩好。封闭式学习思维的孩子尽管很用功，很努力成绩也总是不尽如人意，尤其是在中学以后，他们在学习上会更痛苦。 行动前，先给自己设置障碍，然后放弃 我经常会收到，问我如何写作的，我写过很多关于基础写作的文章，帮助他们。可是他们总会说“这太难了。” 还有人问我什么样的读书类文章会受欢迎，我说横向或者纵向阅读的主题书单，然后他说正常人根本就没有这种阅读量。然后我给他推荐《沟通圣经：听说读写全方位沟通技巧》第12章增进阅读速度，第13章提高阅读效率，然后他说“还得先学阅读，这工程太浩大了。” 有人说我不喜欢现在工作，怎么能找到喜欢的工作并且赚到钱。我的建议只需要评估自己、树立自己想要的目标、了解实现目标需要的技能、学习和提高自身能力、努力实现目标。他们通常会说“可是怎么开始呢？” 他们在行动前，就被自己抛出的问题吓到了，然后就没有然后了。他们会说自己拖延症、选择恐惧症。 通过片面信息、以点概面的否定 逻辑分析的首要条件是什么？“充分占有信息”。盲目的通过片面信息否定，有时候很可笑。 比如有人看了我的便签说“字如其人，看这字就是个生活混乱的男人。”难道我两个孩子都是你生的？你给喂的奶？ 我还收到过“第三行打了两个句号，作者是个浮躁的人。” 我鼓励大家无论男女都要经济独立，马上有人说“满身铜臭，就知道钱。” 我总是做工具书总结，有人说“你应该多读名著陶冶情操，就不会这么世俗了。”我上学的时候，一直担任班里的图书管理员，在初中、高中的假期协助图书馆老师完成了两个学校的图书馆电子化录入，就是把书读完，把主要内容录入到电脑里，方便检索。学校给学生选的书，大家可以想想算不算名著。我个人分析我世俗应该跟读不读名著没什么关系。 我分享理财攻略，马上有人说“这个人充满物欲。”你父母生病，住院办给你打电话跟你说“单间自费，1000元每天，您预定吗？”的时候，咱们可以再来聊这个话题。 写了这么多，希望能帮到大家。改变对话的方式，传递真正想说的信息，而不是表达攻击。","categories":[],"tags":[{"name":"others","slug":"others","permalink":"https://vlwq.github.io/tags/others/"}]},{"title":"别给自己设定界限","slug":"2015others/20160101","date":"2016-01-01T02:36:00.000Z","updated":"2022-03-03T03:40:18.883Z","comments":true,"path":"2016/01/01/2015others/20160101/","link":"","permalink":"https://vlwq.github.io/2016/01/01/2015others/20160101/","excerpt":"你会发现，大部分人对事物的理解多为道听途说，他们会告诉你“你做不到”，不是因为“他们知道你做不到”也不是因为“他们自己做不到”而是因为:“他们听别人说做不到”。","text":"你会发现，大部分人对事物的理解多为道听途说，他们会告诉你“你做不到”，不是因为“他们知道你做不到”也不是因为“他们自己做不到”而是因为:“他们听别人说做不到”。 就这个问题，答主在MIT的时候，问过自己的一位老师，诺贝尔物理学奖得主，夸克的发现人，弗里德曼。 在这里，答主要揭示一个关键的逻辑，这个关键的逻辑，诅咒着99%的人。 这个逻辑是什么呢？ 请紧跟下面对话，不要快速阅读，要慢慢看，一句一句地看： 弗里德曼：地球是圆的吗？ 答主：是的。 弗里德曼：你知道地球是圆的吗？ 答主：知道。 弗里德曼：但是，你知道地球是圆的，说明你很厉害吗？ 答主：不。 弗里德曼：你知道一个很重要的实事，而且你是对的，为什么不能证明你很厉害？ 答主：因为：这个事情已经得到大家的认同了！ 弗里德曼：是啊。只要是大家都已经认同的东西，你再对，也没有意义了。 其实，任何个人的成就，特别是在学科领域，都是在大家不知道、不同意，甚至强烈反对的时候，你坚持，并且发现你是对的之后，才产生的。也就是说，想要做出成就，最主要的就是：不能做大家都已经认同的事情。也就是，要出众，则不能从众。在这方面，中国的学生是最差的。 答主认为，这才是“钱学森之问”真正的答案。","categories":[],"tags":[{"name":"others","slug":"others","permalink":"https://vlwq.github.io/tags/others/"}]},{"title":"过去","slug":"2015others/20150701","date":"2015-07-01T02:36:00.000Z","updated":"2022-03-03T03:46:40.396Z","comments":true,"path":"2015/07/01/2015others/20150701/","link":"","permalink":"https://vlwq.github.io/2015/07/01/2015others/20150701/","excerpt":"不要害怕，很多你怕的事情并不会发生。不要想太多，很多事情你永远想不到。没事别给自己找事，有事不要怕事。直接行动会带来比设想万全计划带来更直接的改变。因为行动会构成既定现实的一部分，而想一堆不会。","text":"不要害怕，很多你怕的事情并不会发生。不要想太多，很多事情你永远想不到。没事别给自己找事，有事不要怕事。直接行动会带来比设想万全计划带来更直接的改变。因为行动会构成既定现实的一部分，而想一堆不会。 能处理事情，需要复杂。能过得开心，需要简单。如果处理不了事情，那就复杂一些。如果过得不快乐，那就丢掉一些。 如果焦虑或者烦躁，就减少日程。计划排的太满超出自我能力后，会进入拖延什么也做不了。 如果你觉得社交很累很有负担很麻烦，一群很low的人说着很low的话。那你可以尝试着把社交变为一种放松的方式。别把社交当舞台当工作，拼命想要表现好，你就当你是去玩的就好了。把平常很多想说的废话说了，大家一起low一会儿，开心完了放松了就可以开始死正经的工作啦。 想当社交核心，你不用表现出社交达人的样子，你只需要一个一个拿下。跟一个一个人慢慢处理好关系，当你和人群中大多数的人一步一步建立起关系的时候，你就是核心。 一定要给自己放松和休息留出时间。人是需要一些时间用来发呆，睡觉，说废话，拖延的。如果你连这些时间都想要压榨用来努力，你的心理生理平衡会被打破。不按时定期娱乐和放松，时间久了，你会付出一直高速运转带来的代价。那就是整个人状态的下滑和效率降低。 哪怕对自己的能力很自信，也不要一开始就上最大强度最高难度。循序渐进会让你走的更稳。想一步登天会直接挫伤你的自信。 一鼓作气，再而衰，三而竭。做到一半了，千万别放弃太久。不断重启很耗电的～ 通过情绪进行自我检查。一般能特别触动你负面情绪的事情，指向些你内心的伤口或者不合理的观点。比如有人攻击了你，你非常愤怒。很可能意味着，你的想法在一定程度上被他说中了。 如果你遇到了挫折，不用全部否定自己的努力和成果。也不用改掉自己所有的缺点，更不用颠覆自己本有的个性。你只需要做出一丁点的调整，你的缺点就能变成你独有的优势。 不要自责。很多事情的发生并不是你的错。只有保护好自己的自信，不陷入自我怀疑，你才有力量重新站起来。对自己好一点，你自己是一切的开始。 不要拉低自己的底线。不要在灰色地带游走。出卖掉的东西，想要再买回来就很难了。有的时候你会遇到一些拉低自己底线而获得一些利益的人。他们看似没有付出什么代价就得到了一些本不该得到的东西。好像坏人也并没有收到惩罚。但坏的行事手段，会加大坏的结果出现的概率。一次两次三次，也许谁都没发现。十次八次九次，次次幸免于难怎么可能？同样，做好事也是一样的道理，也许一次两次三次你并没有获得什么好处。十次八次九次，做的越多，概率越大。你会更容易遇到幸福。 目标是类似于月亮的东西。在你累的时候，抬头看看月亮，可以重新鼓起勇气。月亮的光芒会一直照着你前进的路。不要一直仰望着它，脖子会酸，会停住脚步，会掉进坑里。更不要把月亮背在身上，你会被压垮。 对一个人好的最佳方式，就是努力。你成功了，有能力了，你收益，所有的人也跟着你收益。而停下自己的脚步用已有的东西低效的付出，不仅你会累垮，周围的人对同样的东西的一再刺激也会麻木不知感恩。 挫折无法避免。挫折是常态。适当的挫折和压力会让你整个人趋于平稳。放心吧，不会只有你一个人那么惨的，大家都是这样。很多人看似一帆风顺，只不过是因为他们没有把那些事说出来罢了。挫折只是个小路障，不要一直对这个障碍物发火，或者怀疑自己怎么会遇到这种事。你要做的就是绕开它，处理它，处理掉你就又可以一帆风顺。 不要太计较。不要觉得别人心机重心思多，能活到现在这个岁数的人，多多少少都会有些自己的算盘和想法。这是正常的。你也有。太单纯的人，是活不下去的。 无论是多么开心的事情，最多过两个月，你就没那么开心了。无论是多么难过的事情，最多过两月，你也会好很多。所以，开心的时候就尽情的开心吧，因为它很快就会过去，所以才值得珍惜。悲伤的时候也不要害怕，因为它也会很快的过去。 我有一个独家小秘方，能让你更快乐。那就是写日记。写你最悲伤的，最痛苦的，最羞于启齿的，最无法接受的痛苦的事。重复写一件事也可以，换着事儿写也可以。以前发生的也行，最近发生的也行。每天写一会儿，到第四天左右，你可能觉得更糟糕了。因为你在重新面对这些事情。到一周以后，通过这样的过程，你的负面能量得到了一个出口，当他们被疏导，发泄后，就不会再影响你了。你的经验也会被提纯，整理，你会有更多的掌控力。在那些痛苦的事情面前，你不再无助和失意，你不仅放下了，走出来了，你还获得了你应该得到的报酬。 负面情绪和正面情绪是同一种机制在运作的。你压抑了自己痛苦的同时，你快乐的情绪也会被压制。所以，允许自己成为一个人吧。 编辑于 2015-06-23","categories":[],"tags":[{"name":"others","slug":"others","permalink":"https://vlwq.github.io/tags/others/"}]}],"categories":[],"tags":[{"name":"node","slug":"node","permalink":"https://vlwq.github.io/tags/node/"},{"name":"linux","slug":"linux","permalink":"https://vlwq.github.io/tags/linux/"},{"name":"git","slug":"git","permalink":"https://vlwq.github.io/tags/git/"},{"name":"base","slug":"base","permalink":"https://vlwq.github.io/tags/base/"},{"name":"FE","slug":"FE","permalink":"https://vlwq.github.io/tags/FE/"},{"name":"高程","slug":"高程","permalink":"https://vlwq.github.io/tags/%E9%AB%98%E7%A8%8B/"},{"name":"others","slug":"others","permalink":"https://vlwq.github.io/tags/others/"}]}