{"meta":{"title":"Andrew的博客","subtitle":"practice makes perfect","description":"此为博客一枚。","author":"Andrew Li","url":"https://vlwq.github.io","root":"/vlwq/vlwq.github.io/"},"pages":[{"title":"","date":"2022-03-02T09:31:31.285Z","updated":"2017-07-01T04:45:00.443Z","comments":true,"path":"photos/ins.css","permalink":"https://vlwq.github.io/photos/ins.css","excerpt":"","text":"#post-instagram{ padding: 30px; } #post-instagram .article-entry{ padding-right: 0; } .instagram{ position: relative; min-height: 500px; } .instagram img { width: 100%; } .instagram .year { font-size: 16px; } .instagram .open-ins{ padding: 10px 0; color: #cdcdcd; } .instagram .open-ins:hover{ color: #657b83; } .instagram .year{ display: inline; } .instagram .thumb { width: 25%; height: 0; padding-bottom: 25%; position: relative; display: inline-block; text-align: center; background: #ededed; outline: 1px solid #ddd; } .instagram .thumb a { position: relative; } .instagram .album h1 em{ font-style: normal; font-size: 14px; margin-left: 10px; } .instagram .album ul{ display: flex; flex-wrap: wrap; clear: both; width: 100%; text-align: left; } .instagram .album li{ list-style: none; display: inline-block; box-sizing: border-box; padding: 0 5px; margin-bottom: -10px; height: 0; width: 25%; position: relative; padding-bottom: 25%; } .instagram .album li:before{ display: none; } .instagram .album div.img-box{ position: absolute; width: 90%; height: 90%; -webkit-box-shadow: 0 1px 0 rgba(255,255,255,0.4), 0 1px 0 1px rgba(255,255,255,0.1); -moz-box-shadow: 0 1px 0 rgba(255,255,255,0.4), 0 1px 0 1px rgba(255,255,255,0.1); box-shadow: 0 1px 0 rgba(255,255,255,0.4), 0 1px 0 1px rgba(255,255,255,0.1); } .instagram .album div.img-box img{ width: 100%; height: 100%; position: absolute; z-index: 2; } .instagram .album div.img-box .img-bg{ position: absolute; top: 0; left: 0; bottom: 0px; width: 100%; margin: -5px; padding: 5px; -webkit-box-shadow: 0 0 0 1px rgba(0,0,0,.04), 0 1px 5px rgba(0,0,0,0.1); -moz-box-shadow: 0 0 0 1px rgba(0,0,0,.04), 0 1px 5px rgba(0,0,0,0.1); box-shadow: 0 0 0 1px rgba(0,0,0,.04), 0 1px 5px rgba(0,0,0,0.1); -webkit-transition: all 0.15s ease-out 0.1s; -moz-transition: all 0.15s ease-out 0.1s; -o-transition: all 0.15s ease-out 0.1s; transition: all 0.15s ease-out 0.1s; opacity: 0.2; cursor: pointer; display: block; z-index: 3; } .instagram .album div.img-box .icon { font-size: 14px; position: absolute; left: 50%; top: 50%; margin-left: -7px; margin-top: -7px; color: #999; z-index: 1; } .instagram .album div.img-box .img-bg:hover{ opacity: 0; } .photos-btn-wrap { border-bottom: 1px solid #e5e5e5; margin-bottom: 20px; } .photos-btn { font-size: 16px; color: #333; margin-bottom: -4px; padding: 5px 8px 3px; } .photos-btn.active { color: #08c; border: 1px solid #e5e5e5; border-bottom: 5px solid #fff; } @media screen and (max-width:600px) { .instagram .thumb { width: 50%; padding-bottom: 50%; } .instagram .album li { width: 100%; position: relative; padding-bottom: 100%; text-align: center; } .instagram .album div.img-box{ margin: 0; width: 90%; height: 90%; } }"},{"title":"","date":"2022-03-02T09:31:31.288Z","updated":"2017-07-01T04:45:00.443Z","comments":true,"path":"photos/lazyload.min.js","permalink":"https://vlwq.github.io/photos/lazyload.min.js","excerpt":"","text":""},{"title":"标签","date":"2017-10-25T14:05:00.000Z","updated":"2022-03-02T07:32:56.615Z","comments":true,"path":"tags/index.html","permalink":"https://vlwq.github.io/tags/index.html","excerpt":"","text":""},{"title":"相册","slug":"photos","date":"2022-03-02T09:31:31.287Z","updated":"2017-07-01T04:45:00.443Z","comments":false,"path":"photos/index.html","permalink":"https://vlwq.github.io/photos/index.html","excerpt":"","text":"Ins 摄影 图片来自instagram，正在加载中… (function() { var loadScript = function(path) { var $script = document.createElement('script') document.getElementsByTagName('body')[0].appendChild($script) $script.setAttribute('src', path) } setTimeout(function() { loadScript('./ins.js') }, 0) })()"},{"title":"","date":"2022-03-02T09:31:31.284Z","updated":"2017-07-01T04:45:00.443Z","comments":true,"path":"photos/ins.js","permalink":"https://vlwq.github.io/photos/ins.js","excerpt":"","text":"/******/ (function(modules) { // webpackBootstrap /******/ // The module cache /******/ var installedModules = {}; /******/ /******/ // The require function /******/ function __webpack_require__(moduleId) { /******/ /******/ // Check if module is in cache /******/ if (installedModules[moduleId]) /******/ return installedModules[moduleId].exports; /******/ /******/ // Create a new module (and put it into the cache) /******/ var module = installedModules[moduleId] = { /******/ exports: {}, /******/ id: moduleId, /******/ loaded: false /******/ }; /******/ /******/ // Execute the module function /******/ modules[moduleId].call(module.exports, module, module.exports, __webpack_require__); /******/ /******/ // Flag the module as loaded /******/ module.loaded = true; /******/ /******/ // Return the exports of the module /******/ return module.exports; /******/ } /******/ /******/ /******/ // expose the modules object (__webpack_modules__) /******/ __webpack_require__.m = modules; /******/ /******/ // expose the module cache /******/ __webpack_require__.c = installedModules; /******/ /******/ // __webpack_public_path__ /******/ __webpack_require__.p = \"/dist/\"; /******/ /******/ // Load entry module and return exports /******/ return __webpack_require__(0); /******/ }) /************************************************************************/ /******/ ([ /* 0 */ /***/ function(module, exports, __webpack_require__) { 'use strict'; __webpack_require__(1); var _view = __webpack_require__(2); var _view2 = _interopRequireDefault(_view); function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; } /** * @name impush-client * @description 这个项目让我发家致富… * @date 2016-12-1 */ var _collection = []; var _count = 0; var searchData; function addMask(elem) { var rect = elem.getBoundingClientRect(); var style = getComputedStyle(elem, null); var mask = document.createElement('i'); mask.className = 'icon-film'; mask.style.color = '#fff'; mask.style.fontSize = '26px'; mask.style.position = 'absolute'; mask.style.right = '10px'; mask.style.bottom = '10px'; mask.style.zIndex = 1; elem.parentNode.appendChild(mask); } var createVideoIncon = function createVideoIncon() { var $videoImg = document.querySelectorAll('.thumb a[data-type=\"video\"]'); for (var i = 0, len = $videoImg.length; i < len; i++) { addMask($videoImg[i]); } }; var render = function render(res) { var ulTmpl = \"\"; for (var j = 0, len2 = res.list.length; j < len2; j++) { var data = res.list[j].arr; var liTmpl = \"\"; for (var i = 0, len = data.link.length; i < len; i++) { var minSrc = 'http://litten.me/ins-min/' + data.link[i] + '.min.jpg'; var src = 'http://litten.me/ins/' + data.link[i]; var type = data.type[i]; var target = src + (type === 'video' ? '.mp4' : '.jpg'); src += '.jpg'; liTmpl += '\\ \\ \\ \\ ' + data.text[i] + '\\ '; } ulTmpl = ulTmpl + '' + data.year + '' + data.month + '月\\ ' + liTmpl + '\\ '; } document.querySelector('.instagram').innerHTML = '' + ulTmpl + ''; createVideoIncon(); _view2.default.init(); }; var replacer = function replacer(str) { var arr = str.split(\"/\"); return \"/assets/ins/\" + arr[arr.length - 1]; }; var ctrler = function ctrler(data) { var imgObj = {}; for (var i = 0, len = data.length; i < len; i++) { var y = data[i].y; var m = data[i].m; var src = replacer(data[i].src); var text = data[i].text; var key = y + \"\" + ((m + \"\").length == 1 ? \"0\" + m : m); if (imgObj[key]) { imgObj[key].srclist.push(src); imgObj[key].text.push(text); } else { imgObj[key] = { year: y, month: m, srclist: [src], text: [text] }; } } render(imgObj); }; function loadData(success) { if (!searchData) { var xhr = new XMLHttpRequest(); xhr.open('GET', './ins.json?t=' + +new Date(), true); xhr.onload = function() { if (this.status >= 200 && this.status < 300) { var res = JSON.parse(this.response); searchData = res; success(searchData); } else { console.error(this.statusText); } }; xhr.onerror = function() { console.error(this.statusText); }; xhr.send(); } else { success(searchData); } } var Ins = { init: function init() { loadData(function(data) { render(data); }); } }; Ins.init(); // export default impush; /***/ }, /* 1 */ /***/ function(module, exports, __webpack_require__) { /* WEBPACK VAR INJECTION */ (function(global) { 'use strict'; var inViewport = __webpack_require__(3); var lazyAttrs = ['data-src']; global.lzld = lazyload(); // Provide libs using getAttribute early to get the good src // and not the fake data-src replaceGetAttribute('Image'); replaceGetAttribute('IFrame'); function registerLazyAttr(attr) { if (indexOf.call(lazyAttrs, attr) === -1) { lazyAttrs.push(attr); } } function lazyload(opts) { opts = merge({ 'offset': 333, 'src': 'data-src', 'container': false }, opts || {}); if (typeof opts.src === 'string') { registerLazyAttr(opts.src); } var elts = []; function show(elt) { var src = findRealSrc(elt); if (src) { elt.src = src; } elt.setAttribute('data-lzled', true); elts[indexOf.call(elts, elt)] = null; } function findRealSrc(elt) { if (typeof opts.src === 'function') { return opts.src(elt); } return elt.getAttribute(opts.src); } function register(elt) { elt.onload = null; elt.removeAttribute('onload'); elt.onerror = null; elt.removeAttribute('onerror'); if (indexOf.call(elts, elt) === -1) { inViewport(elt, opts, show); } } return register; } function replaceGetAttribute(elementName) { var fullname = 'HTML' + elementName + 'Element'; if (fullname in global === false) { return; } var original = global[fullname].prototype.getAttribute; global[fullname].prototype.getAttribute = function(name) { if (name === 'src') { var realSrc; for (var i = 0, max = lazyAttrs.length; i < max; i++) { realSrc = original.call(this, lazyAttrs[i]); if (realSrc) { break; } } return realSrc || original.call(this, name); } // our own lazyloader will go through theses lines // because we use getAttribute(opts.src) return original.call(this, name); }; } function merge(defaults, opts) { for (var name in defaults) { if (opts[name] === undefined) { opts[name] = defaults[name]; } } return opts; } // http://webreflection.blogspot.fr/2011/06/partial-polyfills.html function indexOf(value) { for (var i = this.length; i-- && this[i] !== value;) {} return i; } module.exports = lazyload; // export default impush; /* WEBPACK VAR INJECTION */ }.call(exports, (function() { return this; }()))) /***/ }, /* 2 */ /***/ function(module, exports) { 'use strict'; var initPhotoSwipeFromDOM = function initPhotoSwipeFromDOM(gallerySelector) { // parse slide data (url, title, size ...) from DOM elements // (children of gallerySelector) var parseThumbnailElements = function parseThumbnailElements(el) { el = el.parentNode.parentNode; var thumbElements = el.getElementsByClassName('thumb'), numNodes = thumbElements.length, items = [], figureEl, linkEl, size, type, // video or not target, item; for (var i = 0; i < numNodes; i++) { figureEl = thumbElements[i]; // // include only element nodes if (figureEl.nodeType !== 1) { continue; } linkEl = figureEl.children[0]; // size = linkEl.getAttribute('data-size').split('x'); type = linkEl.getAttribute('data-type'); target = linkEl.getAttribute('data-target'); // create slide object item = { src: linkEl.getAttribute('href'), w: parseInt(size[0], 10), h: parseInt(size[1], 10) }; if (figureEl.children.length > 1) { item.title = figureEl.children[1].innerHTML; } if (linkEl.children.length > 0) { item.msrc = linkEl.children[0].getAttribute('src'); item.type = type; item.target = target; item.html = ''; if (type === 'video') { //item.src = null; } } item.el = figureEl; // save link to element for getThumbBoundsFn items.push(item); } return items; }; // find nearest parent element var closest = function closest(el, fn) { return el && (fn(el) ? el : closest(el.parentNode, fn)); }; // triggers when user clicks on thumbnail var onThumbnailsClick = function onThumbnailsClick(e) { e = e || window.event; e.preventDefault ? e.preventDefault() : e.returnValue = false; var eTarget = e.target || e.srcElement; // find root element of slide var clickedListItem = closest(eTarget, function(el) { return el.tagName && el.tagName.toUpperCase() === 'FIGURE'; }); if (!clickedListItem) { return; } // find index of clicked item by looping through all child nodes // alternatively, you may define index via data- attribute var clickedGallery = clickedListItem.parentNode, // childNodes = clickedListItem.parentNode.childNodes, // numChildNodes = childNodes.length, childNodes = document.getElementsByClassName('thumb'), numChildNodes = childNodes.length, nodeIndex = 0, index; for (var i = 0; i < numChildNodes; i++) { if (childNodes[i].nodeType !== 1) { continue; } if (childNodes[i] === clickedListItem) { index = nodeIndex; break; } nodeIndex++; } if (index >= 0) { // open PhotoSwipe if valid index found openPhotoSwipe(index, clickedGallery); } return false; }; // parse picture index and gallery index from URL (#&pid=1&gid=2) var photoswipeParseHash = function photoswipeParseHash() { var hash = window.location.hash.substring(1), params = {}; if (hash.length < 5) { return params; } var vars = hash.split('&'); for (var i = 0; i < vars.length; i++) { if (!vars[i]) { continue; } var pair = vars[i].split('='); if (pair.length < 2) { continue; } params[pair[0]] = pair[1]; } if (params.gid) { params.gid = parseInt(params.gid, 10); } return params; }; var openPhotoSwipe = function openPhotoSwipe(index, galleryElement, disableAnimation, fromURL) { var pswpElement = document.querySelectorAll('.pswp')[0], gallery, options, items; items = parseThumbnailElements(galleryElement); // define options (if needed) options = { // define gallery index (for URL) galleryUID: galleryElement.getAttribute('data-pswp-uid'), getThumbBoundsFn: function getThumbBoundsFn(index) { // See Options -> getThumbBoundsFn section of documentation for more info var thumbnail = items[index].el.getElementsByTagName('img')[0], // find thumbnail pageYScroll = window.pageYOffset || document.documentElement.scrollTop, rect = thumbnail.getBoundingClientRect(); return { x: rect.left, y: rect.top + pageYScroll, w: rect.width }; } }; // PhotoSwipe opened from URL if (fromURL) { if (options.galleryPIDs) { // parse real index when custom PIDs are used // http://photoswipe.com/documentation/faq.html#custom-pid-in-url for (var j = 0; j < items.length; j++) { if (items[j].pid == index) { options.index = j; break; } } } else { // in URL indexes start from 1 options.index = parseInt(index, 10) - 1; } } else { options.index = parseInt(index, 10); } // exit if index not found if (isNaN(options.index)) { return; } if (disableAnimation) { options.showAnimationDuration = 0; } // Pass data to PhotoSwipe and initialize it gallery = new PhotoSwipe(pswpElement, PhotoSwipeUI_Default, items, options); gallery.init(); var $tempVideo; var stopVideoHandle = function stopVideoHandle() { if ($tempVideo) { $tempVideo.remove(); $tempVideo = null; } }; var changeHandle = function changeHandle() { var item = gallery.currItem; stopVideoHandle(); if (item.type === 'video') { var $ctn = item.container; var style = $ctn.getElementsByClassName('pswp__img')[0].style; var $video = document.createElement('video'); $video.setAttribute('autoplay', 'autoplay'); $video.setAttribute('controls', 'controls'); $video.setAttribute('src', item.target); $video.style.width = style.width; $video.style.height = style.height; $video.style.position = 'absolute'; $video.style.zIndex = 2; $tempVideo = $video; $ctn.appendChild($video); } }; gallery.listen('initialZoomIn', changeHandle); gallery.listen('afterChange', changeHandle); gallery.listen('initialZoomOut', stopVideoHandle); }; // loop through all gallery elements and bind events var galleryElements = document.querySelectorAll(gallerySelector); for (var i = 0, l = galleryElements.length; i < l; i++) { galleryElements[i].setAttribute('data-pswp-uid', i + 1); galleryElements[i].onclick = onThumbnailsClick; } // Parse URL and open gallery if it contains #&pid=3&gid=1 var hashData = photoswipeParseHash(); if (hashData.pid && hashData.gid) { openPhotoSwipe(hashData.pid, galleryElements[hashData.gid - 1], true, true); } }; var Viewer = function() { function init() { initPhotoSwipeFromDOM('.photos'); } return { init: init }; }(); module.exports = Viewer; /***/ }, /* 3 */ /***/ function(module, exports) { /* WEBPACK VAR INJECTION */ (function(global) { module.exports = inViewport; var instances = []; var supportsMutationObserver = typeof global.MutationObserver === 'function'; function inViewport(elt, params, cb) { var opts = { container: global.document.body, offset: 0 }; if (params === undefined || typeof params === 'function') { cb = params; params = {}; } var container = opts.container = params.container || opts.container; var offset = opts.offset = params.offset || opts.offset; for (var i = 0; i < instances.length; i++) { if (instances[i].container === container) { return instances[i].isInViewport(elt, offset, cb); } } return instances[ instances.push(createInViewport(container)) - 1 ].isInViewport(elt, offset, cb); } function addEvent(el, type, fn) { if (el.attachEvent) { el.attachEvent('on' + type, fn); } else { el.addEventListener(type, fn, false); } } function debounce(func, wait, immediate) { var timeout; return function() { var context = this, args = arguments; var callNow = immediate && !timeout; clearTimeout(timeout); timeout = setTimeout(later, wait); if (callNow) func.apply(context, args); function later() { timeout = null; if (!immediate) func.apply(context, args); } }; } // https://github.com/jquery/sizzle/blob/3136f48b90e3edc84cbaaa6f6f7734ef03775a07/sizzle.js#L708 var contains = function() { if (!global.document) { return true; } return global.document.documentElement.compareDocumentPosition ? function(a, b) { return !!(a.compareDocumentPosition(b) & 16); } : global.document.documentElement.contains ? function(a, b) { return a !== b && (a.contains ? a.contains(b) : false); } : function(a, b) { while (b = b.parentNode) { if (b === a) { return true; } } return false; }; } function createInViewport(container) { var watches = createWatches(); var scrollContainer = container === global.document.body ? global : container; var debouncedCheck = debounce(watches.checkAll(watchInViewport), 15); addEvent(scrollContainer, 'scroll', debouncedCheck); if (scrollContainer === global) { addEvent(global, 'resize', debouncedCheck); } if (supportsMutationObserver) { observeDOM(watches, container, debouncedCheck); } // failsafe check, every 200ms we check for visible images // usecase: a hidden parent containing eleements // when the parent becomes visible, we have no event that the children // became visible setInterval(debouncedCheck, 150); function isInViewport(elt, offset, cb) { if (!cb) { return isVisible(elt, offset); } var remote = createRemote(elt, offset, cb); remote.watch(); return remote; } function createRemote(elt, offset, cb) { function watch() { watches.add(elt, offset, cb); } function dispose() { watches.remove(elt); } return { watch: watch, dispose: dispose }; } function watchInViewport(elt, offset, cb) { if (isVisible(elt, offset)) { watches.remove(elt); cb(elt); } } function isVisible(elt, offset) { if (!contains(global.document.documentElement, elt) || !contains(global.document.documentElement, container)) { return false; } // Check if the element is visible // https://github.com/jquery/jquery/blob/740e190223d19a114d5373758127285d14d6b71e/src/css/hiddenVisibleSelectors.js if (!elt.offsetWidth || !elt.offsetHeight) { return false; } var eltRect = elt.getBoundingClientRect(); var viewport = {}; if (container === global.document.body) { viewport = { top: -offset, left: -offset, right: global.document.documentElement.clientWidth + offset, bottom: global.document.documentElement.clientHeight + offset }; } else { var containerRect = container.getBoundingClientRect(); viewport = { top: containerRect.top - offset, left: containerRect.left - offset, right: containerRect.right + offset, bottom: containerRect.bottom + offset }; } // The element must overlap with the visible part of the viewport var visible = ( (eltRect.right > viewport.left) && (eltRect.left < viewport.right) && (eltRect.bottom > viewport.top) && (eltRect.top < viewport.bottom) ); return visible; } return { container: container, isInViewport: isInViewport }; } function createWatches() { var watches = []; function add(elt, offset, cb) { if (!isWatched(elt)) { watches.push([elt, offset, cb]); } } function remove(elt) { var pos = indexOf(elt); if (pos !== -1) { watches.splice(pos, 1); } } function indexOf(elt) { for (var i = watches.length - 1; i >= 0; i--) { if (watches[i][0] === elt) { return i; } } return -1; } function isWatched(elt) { return indexOf(elt) !== -1; } function checkAll(cb) { return function() { for (var i = watches.length - 1; i >= 0; i--) { cb.apply(this, watches[i]); } }; } return { add: add, remove: remove, isWatched: isWatched, checkAll: checkAll }; } function observeDOM(watches, container, cb) { var observer = new MutationObserver(watch); var filter = Array.prototype.filter; var concat = Array.prototype.concat; observer.observe(container, { childList: true, subtree: true, // changes like style/width/height/display will be catched attributes: true }); function watch(mutations) { // some new DOM nodes where previously watched // we should check their positions if (mutations.some(knownNodes) === true) { setTimeout(cb, 0); } } function knownNodes(mutation) { var nodes = concat.call([], Array.prototype.slice.call(mutation.addedNodes), mutation.target ); return filter.call(nodes, watches.isWatched).length > 0; } } /* WEBPACK VAR INJECTION */ }.call(exports, (function() { return this; }()))) /***/ } /******/ ]);"},{"title":"关于","date":"2022-03-02T07:34:58.000Z","updated":"2022-03-02T07:35:48.701Z","comments":true,"path":"about/index.html","permalink":"https://vlwq.github.io/about/index.html","excerpt":"","text":""},{"title":"","date":"2022-03-02T09:31:31.272Z","updated":"2017-07-01T04:45:00.412Z","comments":true,"path":"assets/demo/hack_demo.html","permalink":"https://vlwq.github.io/assets/demo/hack_demo.html","excerpt":"","text":"h3,h4{ text-align: center; } #main{ width: 350px; height: 100px; border: 1px solid #000; margin: 0 auto; } #main .box{ width: 100px; height: 100px; margin-left: 10px; position: relative; float: left; background: #333; color:#ddd; } #main .task1:hover{ z-index: 999; } #main .task2:hover{ z-index: 999; background: #999; } #main .task3:hover{ z-index: 999; background: #333; } 三个background为#333的box - 请在IE6，IE7中触发hover - box1 - 未设置backgorund box2 - background: #999 box3 - background: #333"},{"title":"","date":"2022-03-02T09:31:31.279Z","updated":"2017-07-01T04:45:00.412Z","comments":true,"path":"assets/demo/jiugongge_demo.html","permalink":"https://vlwq.github.io/assets/demo/jiugongge_demo.html","excerpt":"","text":"jiugongge_demo *{ margin:0; padding: 0; } table{ margin: 30px; border-collapse: collapse; } #test0{ margin: 30px; width: 200px; height: 200px; } #test0 div{ width: 50px; height: 50px; float: left; background: #eee; border: 5px solid #00f; text-align: center; line-height: 50px; color: #090; position: relative; } #test0 .lr_indent{ margin-left: -5px; margin-right: -5px; } #test0 .tb_indent{ margin-top: -5px; margin-bottom: -5px; } #test0 div:hover{ border: 5px solid #f00; z-index: 999; background: #eee; } #test1 td{ width: 50px; height: 50px; background: #eee; position: relative; border: 5px solid #00f; text-align: center; } #test1 td span{ color: #090; display:block; width: 50px; height: 50px; position: absolute; top: 0; left: 0; line-height: 50px; } #test1 td span:hover{ border: 5px solid #f00; margin-top:-5px; margin-left: -5px; } #test2 td{ width: 50px; height: 50px; background: #eee; border: 5px solid #00f; text-align: center; vertical-align: top; } #test2 td div{ position:relative; width: 50px; height: 50px; } #test2 td div span{ color: #090; display:block; width: 50px; height: 50px; position: absolute; top: 0; left: 0; line-height: 50px; } #test2 td div span:hover{ border: 5px solid #f00; margin-left: -5px; margin-top: -5px; } 1) div+负margin实现 1 2 3 4 5 6 7 8 9 2.1) table border-collapse: collapse实现 1 2 3 4 5 6 7 8 9 2.2) table思路改进 1 2 3 4 5 6 7 8 9"},{"title":"","date":"2022-03-02T09:31:31.286Z","updated":"2017-07-01T04:45:00.443Z","comments":true,"path":"photos/ins.json","permalink":"https://vlwq.github.io/photos/ins.json","excerpt":"","text":"{\"list\":[{\"date\":\"2016-12\",\"arr\":{\"year\":2016,\"month\":12,\"src\":[\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\"],\"link\":[\"BOAF_bbA9H0\",\"BN9ZdHuAqL1\",\"BN30BiDAVGo\",\"BN2CjzagYQK\",\"BNyLQGUgdma\",\"BNwOJYlgAOL\",\"BNtsL5QgEts\",\"BNn5V7oA_nc\"],\"text\":[\"末班车\",\"树影，好似一只黄鹂和蜣螂\",\"街拍 | 晴天\",\"“望”\",\"午睡\",\"“黄昏之时”\",\"枯萎的植物，最后的光\",\"街拍 | 也许是深圳最后的夏日\"],\"type\":[\"image\",\"image\",\"image\",\"image\",\"image\",\"image\",\"image\",\"image\"]}},{\"date\":\"2016-11\",\"arr\":{\"year\":2016,\"month\":11,\"src\":[\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\"],\"link\":[\"BNUaqEagioX\",\"BNTHIbUgigX\",\"BNRr9zBg0fu\",\"BNQHWSwA1Gy\",\"BNPbdVIg6gT\",\"BNOpXsKgU53\",\"BNBrozHAAV7\",\"BM8hsf-grvj\",\"BM8WO8xglvC\",\"BMy1VT3grFk\",\"BMrSxSNgpIN\",\"BMedxcZA0_g\",\"BMQLQvogqn7\"],\"text\":[\"“我是谁我爱谁我要谁我去哪”\",\"天都峰顶转一圈，站的地方巴掌大其实很慌…\",\"下了一夜雨，晚上没睡好，脑子里老想着天都峰关闭的事情。但风云变幻就在一瞬间，冥冥中必有回响，突如其来的晴天太过惊喜。峰顶走起\",\"上年没见着的雾凇突然出现，愿望兑现的感觉\",\"“不看岳”\",\"黄山行\",\"宿舍楼\",\"华科的秋天好像一条安静河流，慢慢扩散，了无声息，异常缓慢，又很具体。反正，时间还有很多，请随意\",\"又回我科，我科这个季节怎么拍都好看\",\"今夜月亮\",\"想过去改变，想过要离开，想过拍拍裤管就去远方。然后又想是不是先做出点事情，后来又突然有了点责任，再后来发现自己可以影响一些人… 它没有扼杀选择，反而让更多条路铺在我面前。所以，生日快乐，18岁。\",\"街拍 | 面对面\",\"一叶知秋\"],\"type\":[\"image\",\"video\",\"image\",\"image\",\"image\",\"image\",\"image\",\"image\",\"image\",\"image\",\"image\",\"image\",\"image\"]}},{\"date\":\"2016-10\",\"arr\":{\"year\":2016,\"month\":10,\"src\":[\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\"],\"link\":[\"BL_WXdxAM1Y\",\"BL6dTmIgecl\",\"BLv6COag1M6\",\"BLlf8WWgHcJ\",\"BLfzJ7gjj-8\",\"BLbaFJDAJ1i\",\"BLVHTFJgfg-\",\"BLTvxMWgKUn\",\"BLTd_nVAFQi\",\"BLP2UMKAGcn\",\"BLJIJCegCT3\",\"BLDZyq2g7Zr\",\"BLDSZ6pAsAZ\"],\"text\":[\"这年头不做作的民谣已经很少了……\",\"很久没去看那群留守的孩子了。他们还是很容易对每个人卸下心防，情绪会很强烈，所以开心时笑得特别大声，这让我想到悲伤会不会也成正比。不敢想。这世上，不一定所有问题都要去思考去直面，因为时间能帮你们解决很多问题。起码，在一起玩的时间。\",\"深圳雨，台风。小时候问大人，为什么我的风筝飞不起来？他们说要等大风。所以我期待着台风天。等了半年，台风来了，我却只能呆在窗户里往外看，也开始理解这场空欢喜。后来发现台风不单是种天气，还可以是一件事或一个人\",\"鸽子再也看不到无名山的高，你也不再是安和桥下清澈的水\",\"降低了预期，觉得滕王阁还不错。路遇一位玩摄影的大爷，教了许多东西，也听他说了许多往事。其实人得不得意都要尽欢，白不白头都要有那么一点青云之志\",\"东四变成了超市\\n东三变成了清真\\n神剪阁还在\\n绝望坡的小吃多到绝望\\n球场都翻修了\\n计科有钱了(辅导员说的)\\nofo小黄车已占领校园\\n学弟学妹主要玩lol和王者荣耀\\n光谷门对面依旧有鸡蛋灌饼和麻辣烫\\n韵苑食堂还是不怎么好吃\\n沁苑的猫又生了许多娃…\\n\\n来去匆匆，一些照片在：http://120.24.181.238/gallery/\",\"要是一个地方能称作图书馆，不单单是因为图书，还因为它收藏了太多的心事。\\n一语一念，虽不可借阅，愿永不过期。\",\"《深夜食堂》\",\"《返校日》\",\"旧时作\",\"和奶奶在一起。把轮椅推到广场下面玩，突然问我：你们厂生产什么？我：很难说，网络你知道吗… 奶奶：哦，卖绳子的啊\",\"19年前的我，就已经学会了爱恨分明……\",\"回老家，今天正好是“圩日”。村民一家老小，从竹林深处的罗江村出发，走过这条小桥，赶往市集。买到中意的衣服，或者零食，这就是完美的一天\"],\"type\":[\"video\",\"image\",\"image\",\"image\",\"image\",\"image\",\"image\",\"image\",\"image\",\"image\",\"image\",\"image\",\"image\"]}},{\"date\":\"2016-09\",\"arr\":{\"year\":2016,\"month\":9,\"src\":[\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\"],\"link\":[\"BK-l0eHgWep\",\"BK3W05HgBqP\",\"BK0nQcSARek\",\"BKx6pvkg5HE\",\"BKfNILQgNAO\",\"BKdn7vEAJJW\",\"BKcdEbPAWzk\",\"BKcCulagAx1\",\"BKazUfGAFlb\",\"BKayutggosw\",\"BKTJUOdgkLm\",\"BKIiijpAvmT\"],\"text\":[\"街拍 | 回望\",\"街拍 | 深拷贝…\",\"街拍 | 拷贝\",\"街拍 | 擦肩而过\",\"苗族妹子上来敬酒。以为只是普通米酒，一饮而尽，后来才跟我说有70度。那还怎样办？不走了。\",\"满城星星点点的灯火，当作你心心念念的生日蜡烛吧。生日快乐，永远单纯。\",\"以大为美的苗族银饰，近看却有许多复杂的细节\",\"迷了路找不见甲秀楼位置。干脆坐下来吃一碗哨脆面，听到对面歌舞升平，寻路过去果然找到了。道理就是，有地标的地方就有广场，有广场的地方就有广场舞。感谢大妈，感谢广场舞。\",\"眼中仿佛藏了一个宇宙\",\"曾经想仗剑走天涯\",\"…\",\"hello，好久不见\"],\"type\":[\"image\",\"image\",\"image\",\"image\",\"image\",\"image\",\"image\",\"image\",\"image\",\"image\"]}},{\"date\":\"2015-12\",\"arr\":{\"year\":2015,\"month\":12,\"src\":[\"https://scontent.cdninstagram.com/hphotos-xfa1/t51.2885-15/e15/12317949_812027942276002_800384968_n.jpg\"],\"link\":[\"-wSMLcI7sl\"],\"text\":[\"秦教练教学得很好，三小时已可征服中级场。滑雪真是项迷人的活动，还没回去就约好了下次再来\"],\"type\":[\"video\"]}},{\"date\":\"2015-11\",\"arr\":{\"year\":2015,\"month\":11,\"src\":[\"https://scontent.cdninstagram.com/hphotos-xft1/t51.2885-15/s640x640/sh0.08/e35/12269862_894338194013437_1805169379_n.jpg\",\"https://scontent.cdninstagram.com/hphotos-xpf1/t51.2885-15/s640x640/sh0.08/e35/12276891_172191463131445_911534090_n.jpg\",\"https://scontent.cdninstagram.com/hphotos-xtp1/t51.2885-15/s640x640/sh0.08/e35/12237527_913338585386151_2037194016_n.jpg\",\"https://scontent.cdninstagram.com/hphotos-xap1/t51.2885-15/e15/11934646_1088170014540783_209449183_n.jpg\"],\"link\":[\"-tqoLXo7v-\",\"-qKfKxo7nw\",\"-nE5BQo7uP\",\"9qjBpWI7lk\"],\"text\":[\"雪上鸦飞\",\"行走于结了冰的松花江上，遇到一群放生的人。佛经飘扬，鱼虾入河，河面转瞬又恢复了平静。而后在饭店，服务员说我们的鱼，就来自这松花江里。\\n\\n佛的安排奇妙又令人啼笑，鱼让俩群不同的人都收获了快乐？那么我想，鱼就是佛\",\"月上枝头\",\"在天黑后的日光岩顶呆了很久，一个人看一座岛，孤单也自由。后来遇到一位姑娘，我们一同下山。带着她逛遍整条龙头路找吃的，但她什么也不愿吃，问她，她说，想吃酸辣土豆丝。\\n\\n只有笑着承认，真是意料之外的答案。我出来玩，就是为了吃平时吃不到的东西，她则是觉得家乡的菜最熟悉，在哪都是愿意吃的。\\n\\n好吧，陪你吃。因为，离开武汉这么久，我也挺想念这道菜。\"],\"type\":[\"image\",\"image\",\"image\",\"video\"]}},{\"date\":\"2015-10\",\"arr\":{\"year\":2015,\"month\":10,\"src\":[\"https://scontent.cdninstagram.com/hphotos-xpt1/t51.2885-15/s640x640/sh0.08/e35/12145229_1722399741326075_2063247708_n.jpg\",\"https://scontent.cdninstagram.com/hphotos-xpt1/t51.2885-15/s640x640/sh0.08/e35/12080493_892409564169375_1626542651_n.jpg\",\"https://scontent.cdninstagram.com/hphotos-xtp1/t51.2885-15/s640x640/sh0.08/e35/11849199_203248513340142_1615092499_n.jpg\",\"https://scontent.cdninstagram.com/hphotos-xpt1/t51.2885-15/e15/12132912_162625974083441_1400003063_n.jpg\",\"https://scontent.cdninstagram.com/hphotos-xpt1/t51.2885-15/s640x640/sh0.08/e35/12135478_1700175696879683_933151519_n.jpg\"],\"link\":[\"9VYE8YI7sk\",\"9BkX3xo7od\",\"8-Ba4MI7lt\",\"88Neujo7r2\",\"8uKqhDo7vp\"],\"text\":[\"在路上\",\"11点的时候，不想睡，借一只手电，一人夜游古村。这事情很刺激，转角遇到的神像，榕树的垂枝，摇曳的灯笼，自己投射到土楼的巨大影子，莫名的恐惧自心底升起。然而后来又不怕了，却总是想起以前去的思溪源村…with my friends\",\"古城的砖瓦年代久了，就很容易长出猫来\",\"以前吉他老师说，对于一首天空之城，听过与弹过是完全不一样的。弹过后才知道，从开始的吉他2品就一直在递增，仿佛自身也在飞翔，云层渐开，空城显现，情绪是那么容易被调动。然而我的水平只够感动自己，要抓紧时间努力学习了。不说了，玩游戏去了\",\"海上日出\"],\"type\":[\"image\",\"image\",\"image\",\"video\",\"image\"]}},{\"date\":\"2015-9\",\"arr\":{\"year\":2015,\"month\":9,\"src\":[\"https://scontent.cdninstagram.com/hphotos-xtf1/t51.2885-15/s640x640/sh0.08/e35/11875445_885316994870904_706284789_n.jpg\",\"https://scontent.cdninstagram.com/hphotos-xpa1/t51.2885-15/s640x640/sh0.08/e35/11352715_138879086461968_2066668148_n.jpg\"],\"link\":[\"8NKC9RI7oZ\",\"8DOh_to7p0\"],\"text\":[\"沙滩总有数不完的沙子，数不完的故事。在这突然想起那本还没看完的《岛上书店》，是时候继续做些什么了\",\"陌上花开\"],\"type\":[\"image\",\"image\"]}},{\"date\":\"2015-6\",\"arr\":{\"year\":2015,\"month\":6,\"src\":[\"https://scontent.cdninstagram.com/hphotos-xft1/t51.2885-15/e15/11429225_720390118073037_768409912_n.jpg\",\"https://scontent.cdninstagram.com/hphotos-xap1/t51.2885-15/e15/11420780_1012574008772885_1569805305_n.jpg\",\"https://scontent.cdninstagram.com/hphotos-xtf1/t51.2885-15/e15/11252784_879698105429690_2109453469_n.jpg\",\"https://scontent.cdninstagram.com/hphotos-xfa1/t51.2885-15/e15/11267410_925161560884785_371811288_n.jpg\",\"https://scontent.cdninstagram.com/hphotos-xaf1/t51.2885-15/e15/11375982_491190547696110_2013240096_n.jpg\"],\"link\":[\"4T1Lfgo7gX\",\"3-mmN3o7mn\",\"3uts9do7jI\",\"3iK7kwI7j1\",\"3glBKbI7jm\"],\"text\":[\"大雨之后\",\"一脸无辜的王尼玛大哥，从肚腩来看，果然是正品？\",\"感觉迷上风筝了。有次做梦，想到一根根拉伸向上的线，像是在钓空中的鱼。而一个技术娴熟的“渔夫”，收杆时是这么干净利落。\",\"起飞\",\"小萝莉不愿回家，跟奶奶说：“再让我玩会，明天要学钢琴，后天要学跳舞，就来不了这儿玩了。”\"],\"type\":[\"image\",\"image\",\"video\",\"video\",\"image\"]}},{\"date\":\"2015-5\",\"arr\":{\"year\":2015,\"month\":5,\"src\":[\"https://scontent.cdninstagram.com/hphotos-xtp1/t51.2885-15/e15/11252751_1444216632541093_1558227860_n.jpg\",\"https://scontent.cdninstagram.com/hphotos-xfa1/t51.2885-15/e15/11226595_701075516681953_1354085958_n.jpg\"],\"link\":[\"24-dd6o7uB\",\"2uQeuaI7nv\"],\"text\":[\"风雨欲来\",\"野生海带\"],\"type\":[\"image\",\"video\"]}},{\"date\":\"2015-4\",\"arr\":{\"year\":2015,\"month\":4,\"src\":[\"https://scontent.cdninstagram.com/hphotos-xap1/t51.2885-15/e15/11142212_609961145801361_1913577076_n.jpg\",\"https://scontent.cdninstagram.com/hphotos-xfa1/t51.2885-15/e15/11049421_1375007652828983_401355534_n.jpg\",\"https://scontent.cdninstagram.com/hphotos-xaf1/t51.2885-15/e15/11137852_1649834698581861_1050691792_n.jpg\",\"https://scontent.cdninstagram.com/hphotos-xfa1/t51.2885-15/e15/11055751_1573536912901494_1683773508_n.jpg\",\"https://scontent.cdninstagram.com/hphotos-xtf1/t51.2885-15/e15/11055897_1407191599597961_1763496348_n.jpg\"],\"link\":[\"1IUZByo7vP\",\"1ISKRxo7r8\",\"1GPBzpo7qW\",\"1FtGO3I7kN\",\"1C03iPI7hZ\"],\"text\":[\"要回去啦，再见北流河\",\"灵芝get√\",\"这里的清明是个很重要的节日，子孙们都会回来，跋山涉水，竹排渡江，荒山寻路，凭集体的记忆寻找列祖列宗的宝地，寄哀思，也求福德。一路上可以听他们唠叨旧事，也有超级靠谱的风水科普\",\"为了部落\",\"在清明的山路遇到了天然松香\"],\"type\":[\"video\",\"image\",\"image\",\"image\",\"image\"]}},{\"date\":\"2015-3\",\"arr\":{\"year\":2015,\"month\":3,\"src\":[\"https://scontent.cdninstagram.com/hphotos-xft1/t51.2885-15/e15/11123665_1542600796003839_1576473443_n.jpg\",\"https://scontent.cdninstagram.com/hphotos-xfa1/t51.2885-15/e15/11008101_1593505510894691_369067449_n.jpg\"],\"link\":[\"04_8fwo7gL\",\"zzfe7Oo7uc\"],\"text\":[\"如果你飞得像月亮这么高，就不会搁浅在树上\",\"喜欢这个季节的天空，你找个草坪一躺，飞机，风筝，鸟儿就都在上边，天气好时还能看到白天的月亮\"],\"type\":[\"image\",\"image\"]}},{\"date\":\"2015-2\",\"arr\":{\"year\":2015,\"month\":2,\"src\":[\"https://scontent.cdninstagram.com/hphotos-xaf1/t51.2885-15/e15/10958252_1405701033068537_2023890854_n.jpg\",\"https://scontent.cdninstagram.com/hphotos-xtp1/t51.2885-15/e15/10832246_413065338853260_183697882_n.jpg\",\"https://scontent.cdninstagram.com/hphotos-xaf1/t51.2885-15/e15/10268927_436139166536328_1377561628_n.jpg\",\"https://scontent.cdninstagram.com/hphotos-xfa1/t51.2885-15/e15/11008343_410508022446936_713236389_n.jpg\"],\"link\":[\"zcWez6I7uo\",\"zRPazvI7ol\",\"zPN2LtI7sT\",\"zKrDWlo7gZ\"],\"text\":[\"很多东西随着慢慢长大，变得不像小时候那样盼望热切，比如巧克力麦当劳薯片雪糕。只有对担子粉的爱永远不变的说…\",\"据说是一年一度考验演技的时候…\",\"锈迹斑斑的香炉\",\"回老家了，小时候跟我打过玻璃珠的小伙伴们呢？你们一个在北京，一个在安徽，一个在澳洲，一个我都不知道了…但你们看到玻璃珠的时候，要想起我来啊\"],\"type\":[\"image\",\"image\",\"image\",\"image\"]}},{\"date\":\"2015-1\",\"arr\":{\"year\":2015,\"month\":1,\"src\":[\"https://scontent.cdninstagram.com/hphotos-xtf1/t51.2885-15/e15/10932550_620643038062978_1729442807_n.jpg\",\"https://scontent.cdninstagram.com/hphotos-xtp1/t51.2885-15/e15/891532_1563899373855738_1180535181_n.jpg\",\"https://scontent.cdninstagram.com/hphotos-prn/t51.2885-15/e15/10005439_338105566394046_854247264_n.jpg\",\"https://scontent.cdninstagram.com/hphotos-xap1/t51.2885-15/e15/10903312_693622147425934_1766884651_n.jpg\",\"https://scontent.cdninstagram.com/hphotos-xpt1/t51.2885-15/e15/10914460_1546003772305181_1301162053_n.jpg\",\"https://scontent.cdninstagram.com/hphotos-xaf1/t51.2885-15/e15/10903277_832760670116494_255352239_n.jpg\",\"https://scontent.cdninstagram.com/hphotos-xpa1/t51.2885-15/e15/924083_1539057536347062_2062767438_n.jpg\",\"https://scontent.cdninstagram.com/hphotos-xfa1/t51.2885-15/e15/10890944_765121966897759_2039585477_n.jpg\"],\"link\":[\"yb8uaCI7tt\",\"yKBopho7mX\",\"yAOcawI7pA\",\"x5U25kI7sN\",\"x1TTZUo7gW\",\"xeGbWuo7if\",\"xXr70fI7iD\",\"xUB4dOI7g1\"],\"text\":[\"草地上遗落的鞋子\",\"有位很久没联系的朋友寄来明信片，说：我很少看到海，正如你没见过几次雪\",\"深夜总是灵感乍现的最佳时期，只是几个设计方案都没法使自己满意。累了打开窗看到天上有个大月亮，只想用图章工具把它干掉。\",\"面朝大海冬暖花开\",\"分享日常不正常生活照一张\",\"其实我想，那些古老的渔民们，每天看着海岸线的日落日出，肯定是有人想过地球是圆的。而“想法”与“证明”之间，却跨越了一整条麦哲伦航道\",\"鱼山鱼海中，只有你，肯安静的趴在65厘米厚的亚克力板子上与我合影，大丑鱼\",\"新年单人旅行走起。其实从九洲港码头开始，珠海并没有给人很惊喜的感觉，包括盛名之下的沿海风光与渔女雕塑。倒是交通不通畅，从轮渡到公交都给我带来了许多麻烦。直到，晚上吃烤生蚝的第一口，我又觉得什么事情都是可以原谅的……\"],\"type\":[\"image\",\"image\",\"image\",\"image\",\"image\",\"image\",\"image\",\"image\"]}},{\"date\":\"2014-12\",\"arr\":{\"year\":2014,\"month\":12,\"src\":[\"https://scontent.cdninstagram.com/hphotos-prn/t51.2885-15/e15/10899183_999582293404177_745539859_n.jpg\",\"https://scontent.cdninstagram.com/hphotos-xaf1/t51.2885-15/e15/10894909_702627706517406_1277557620_n.jpg\",\"https://scontent.cdninstagram.com/hphotos-xtp1/t51.2885-15/e15/10831989_483313928477468_40906631_n.jpg\"],\"link\":[\"xRWN47I7pW\",\"xO3qREI7iW\",\"wEQykeo7tU\"],\"text\":[\"2014年最后的阳光\",\"最后一节吉他课结束后，马路上那风一直吹，才感觉南方的冬天终于是来了。其实吉他在冬天会有许多神奇的事情。比如琴弦如肌肉一样因冷而紧绷，发出比以往沉闷的低语；而空旷的大教室里，如有其他同伴拨响和弦，手中本已按灭的琴弦又会因共鸣微微颤动。像有生命一样。\",\"有棵丑树，我经常去看，又胖又歪，秃得可笑。在变冷的一天，它突然就开花了。冬天的花我知道得很少，南方没有梅花，那就是异木棉了\"],\"type\":[\"image\",\"image\",\"image\"]}},{\"date\":\"2014-11\",\"arr\":{\"year\":2014,\"month\":11,\"src\":[\"https://scontent.cdninstagram.com/hphotos-prn/t51.2885-15/e15/10784965_1518537748403855_176956695_n.jpg\",\"https://scontent.cdninstagram.com/hphotos-prn/t51.2885-15/e15/10735195_1505939246340704_1984926778_n.jpg\",\"https://scontent.cdninstagram.com/hphotos-prn/t51.2885-15/e15/10747711_429336373885590_422028037_n.jpg\"],\"link\":[\"vP2ywuo7pq\",\"vA68BLo7tN\",\"u7zEVxo7vw\"],\"text\":[\"通灵之术！\",\"现场气氛果然不一样，马上就可以看到小伞在大哥胯下疯狂输出…是时候来首选一记薇恩了\",\"有朋友跟我说，挪威的森林根本看不下去；又有朋友说，看这书一发不可收拾。差别好大呀！我倒觉得有个简单的方法：翻到开篇的这几个字，如果心中一紧，那就说明这本书适合你，否则请弃之\"],\"type\":[\"image\",\"image\",\"image\"]}},{\"date\":\"2014-10\",\"arr\":{\"year\":2014,\"month\":10,\"src\":[\"https://scontent.cdninstagram.com/hphotos-frc/t51.2885-15/e15/10735112_730529873702428_413107753_n.jpg\",\"https://scontent.cdninstagram.com/hphotos-prn/t51.2885-15/e15/10725177_573652486072155_1401604216_n.jpg\",\"https://scontent.cdninstagram.com/hphotos-xfp1/t51.2885-15/e15/10724868_302191016652312_2097904817_n.jpg\",\"https://scontent.cdninstagram.com/hphotos-xft1/t51.2885-15/e15/10731727_461314204008708_386749273_n.jpg\"],\"link\":[\"uu70zJo7qb\",\"uQnvluo7sK\",\"uLi56Wo7oO\",\"uEv-tCo7rJ\"],\"text\":[\"天下的小饼干遇到我，貌似就只有一种下场！！\",\"一个人，一支口琴，一片海，一瓶酒\",\"《论夜归，打的，以及发票的正确用法》\",\"童年真好。我以后一定不要跟孩子说：希望你快高长大这种傻话…\"],\"type\":[\"image\",\"image\",\"image\",\"image\"]}},{\"date\":\"2014-9\",\"arr\":{\"year\":2014,\"month\":9,\"src\":[\"https://scontent.cdninstagram.com/hphotos-frc/t51.2885-15/e15/10616983_1382591478697855_2107473552_n.jpg\",\"https://scontent.cdninstagram.com/hphotos-xpa1/t51.2885-15/e15/925287_1464119273867077_427071626_n.jpg\",\"https://scontent.cdninstagram.com/hphotos-xap1/t51.2885-15/e15/925284_1534308033454310_855505111_n.jpg\",\"https://scontent.cdninstagram.com/hphotos-xfp1/t51.2885-15/e15/10666267_1550871771803214_2074300649_n.jpg\",\"https://scontent.cdninstagram.com/hphotos-prn/t51.2885-15/e15/10693244_734401199942901_1572709880_n.jpg\",\"https://scontent.cdninstagram.com/hphotos-prn/t51.2885-15/e15/10693771_1517437541834868_665867908_n.jpg\",\"https://scontent.cdninstagram.com/hphotos-prn/t51.2885-15/e15/10693822_497709657032441_1125408654_n.jpg\",\"https://scontent.cdninstagram.com/hphotos-prn/t51.2885-15/e15/10683941_796597910390683_12441123_n.jpg\",\"https://scontent.cdninstagram.com/hphotos-ash/t51.2885-15/e15/10661142_164227523747936_1526737465_n.jpg\",\"https://scontent.cdninstagram.com/hphotos-xfa1/t51.2885-15/e15/10661182_550889531706942_2043749716_n.jpg\",\"https://scontent.cdninstagram.com/hphotos-ash/t51.2885-15/e15/10520334_1523531751215211_1344090061_n.jpg\",\"https://scontent.cdninstagram.com/hphotos-prn/t51.2885-15/e15/10693390_547748238660649_761529890_n.jpg\",\"https://scontent.cdninstagram.com/hphotos-prn/t51.2885-15/e15/10693650_837768039589771_1793184733_n.jpg\",\"https://scontent.cdninstagram.com/hphotos-xft1/t51.2885-15/e15/914812_1529561143923493_1662159287_n.jpg\",\"https://scontent.cdninstagram.com/hphotos-xfp1/t51.2885-15/e15/10644019_368509079979549_2085033896_n.jpg\",\"https://scontent.cdninstagram.com/hphotos-xta1/t51.2885-15/e15/10684161_918887498139099_2081383304_n.jpg\",\"https://scontent.cdninstagram.com/hphotos-ash/t51.2885-15/e15/10683828_327931784041264_894089329_n.jpg\",\"https://scontent.cdninstagram.com/hphotos-prn/t51.2885-15/e15/10666028_872988212713750_1345360858_n.jpg\",\"https://scontent.cdninstagram.com/hphotos-xpf1/t51.2885-15/e15/10665501_1452353738387652_2075798065_n.jpg\"],\"link\":[\"tXuIHso7qK\",\"tJjQlAo7kH\",\"tDYyUeo7oX\",\"tCBULHo7sW\",\"tB_Xmao7qG\",\"s8cKzLI7pM\",\"s6-lOFo7ip\",\"s5GifkI7q7\",\"s3uZcmo7uj\",\"s2bb5io7p-\",\"s2P72tI7o6\",\"s2FPpGI7o_\",\"s1LPQPo7v8\",\"szZP5Io7lY\",\"sr9rtNo7lM\",\"sr7gXKI7h_\",\"srG7fjo7sV\",\"spAnrio7oh\",\"sj4BGgI7t_\"],\"text\":[\"我的好朋友——超级高冷超级磨人的丝瓜\",\"沉眠的店主失眠的狗。想起大学的最后时光，宿舍24小时都有人醒着，自由的人生，自由的酒和曲终人散，大家通常没有另一半，没有钱，没有忧愁，爽成狗\",\"如果他是程序员…\\nvar date = lifetime;\\rif(rotate(mountain, water, stupa)){ /*return nextLifetime;*/ return meetyou(journey);\\r}\",\"听着山寨的民谣电子乐，看着美好的姑娘。功德无量。\",\"弥里塘太宁静。在这我一直想起每一个被深圳车水马龙声吵醒的早晨，真是光辉的岁月\",\"进藏。天空挂满着云，黑的白的都有。云朵转眼飘散，它却依然是蓝色。\",\"“音浪太强不晃会被撞到地上…”\",\"陌生的朋友，愿下次再能与你们相聚在丽江love wine & half。我无法融解你悲观现实的想法，你也无法说服我旅行并不是逃避。但这都很有意思。只是想起以前有个人叫我不能喝太多的酒，一想到这个呀我就越喝越多\",\"玉龙雪山\",\"以前想去丽江，但去过的人都灌输着你也许会失望的观念，因而甚至不敢动身。这是一种“怕”。有时候真得自己去看看才会了然。第一天在丽江，民谣吉他缓缓流过商业化的街道，原来没有惊喜，也没有失望，一切刚刚好。\",\"我注定要回到老路上\",\"彩云之南\",\"云南，向往已久的地方\",\"QQ同时在线人数破2亿纪念，作为一颗小小螺丝钉，名字正好镶到企鹅的大嘴巴上。这时觉得有一丝光荣，一种努力被实化的错觉；然后又有点不舒服，感觉此时的自己，和名字身边的人一样。可我想要的就是不一样。\",\"陪伴一定得是件漫长的事呵。和奶奶在一起的中秋节。\",\"中秋和家人一起去看孔明灯，热闹而安逸，这是小城市的美好。\",\"老家的葡萄藤，从我初中时就挂在这，再见已是十一年\",\"家里橄榄熟了，盐渍，暴晒，蘸蜜，简直人间美味!\",\"在一场太阳雨里回到家中\"],\"type\":[\"image\",\"image\",\"image\",\"image\",\"image\",\"image\",\"video\",\"image\",\"video\",\"image\",\"video\",\"image\",\"image\",\"image\",\"image\",\"video\",\"image\",\"image\",\"image\"]}},{\"date\":\"2014-8\",\"arr\":{\"year\":2014,\"month\":8,\"src\":[\"https://scontent.cdninstagram.com/hphotos-ash/t51.2885-15/e15/10654876_610857929023752_364709543_n.jpg\",\"https://scontent.cdninstagram.com/hphotos-xfa1/t51.2885-15/e15/10644013_777642448965989_544517718_n.jpg\",\"https://scontent.cdninstagram.com/hphotos-xap1/t51.2885-15/e15/924456_1471485796442896_1699836323_n.jpg\",\"https://scontent.cdninstagram.com/hphotos-xtp1/t51.2885-15/e15/10607913_692632367472666_1829853902_n.jpg\",\"https://scontent.cdninstagram.com/hphotos-xtf1/t51.2885-15/e15/10611052_1466241683635233_830264506_n.jpg\",\"https://scontent.cdninstagram.com/hphotos-frc/t51.2885-15/e15/10617144_829548960388746_1611410337_n.jpg\",\"https://scontent.cdninstagram.com/hphotos-xft1/t51.2885-15/e15/10453953_542161702576881_1621059386_n.jpg\"],\"link\":[\"sXa9g6I7jB\",\"sPt4u4I7kA\",\"sC18G0o7qb\",\"sAMmEWI7oC\",\"rzSow4o7lH\",\"ro28LPI7oc\",\"rR37wLo7iu\"],\"text\":[\"在书店的晚上终于把新专反复听完。太柔了…打一星两星的人肯定是真爱粉，这点有人敢怀疑？我不是，打四星！停不下来，直到书店响起:深圳即将入眠。但22点还是深圳的早晨呀\",\"慢三的华尔兹，大篇幅的爵士即兴。感觉生活得太浮躁。也太安逸。\",\"好久没看话剧，这部果然没让人失望。导演太会讲故事了，1024个赞\",\"纵有一万种悲伤的美丽，也比不过这段。\",\"在书城里看到的《后会无期》分镜图。电影那么美，分镜是这样，这就是现实~\",\"如果你从北京来看我，我会很感动;如果你像光，从太阳那头过来，我不以为然。因为光到地球只要8.3分钟。我们经常错用代价来衡量情感\",\"相聚总有时:)\"],\"type\":[\"image\",\"video\",\"image\",\"image\",\"image\",\"image\",\"image\"]}},{\"date\":\"2014-7\",\"arr\":{\"year\":2014,\"month\":7,\"src\":[\"https://scontent.cdninstagram.com/hphotos-xpa1/t51.2885-15/e15/925559_1482425071996009_1940959046_n.jpg\",\"https://scontent.cdninstagram.com/hphotos-frc/t51.2885-15/e15/10554006_501929086608023_917623457_n.jpg\",\"https://scontent.cdninstagram.com/hphotos-frc/t51.2885-15/e15/10576105_624878090953161_638111947_n.jpg\",\"https://scontent.cdninstagram.com/hphotos-xpf1/t51.2885-15/e15/10570119_332808380211109_125412512_n.jpg\",\"https://scontent.cdninstagram.com/hphotos-xpa1/t51.2885-15/e15/926536_828142997203682_1319760676_n.jpg\",\"https://scontent.cdninstagram.com/hphotos-xap1/t51.2885-15/e15/923702_252705761596555_721784545_n.jpg\",\"https://scontent.cdninstagram.com/hphotos-ash/t51.2885-15/e15/10549755_708603639175850_2095584541_n.jpg\",\"https://scontent.cdninstagram.com/hphotos-xtf1/t51.2885-15/e15/928307_1442957109299429_297849354_n.jpg\",\"https://scontent.cdninstagram.com/hphotos-ash/t51.2885-15/e15/10488451_303926969784787_1278259348_n.jpg\"],\"link\":[\"q5e2KpI7qn\",\"qyXXpNI7q5\",\"qxfUe0I7lp\",\"qq9usdo7hr\",\"qn4WCIo7hi\",\"ql0brho7vN\",\"qkiaYDo7t9\",\"qURC9fI7r-\",\"p4A8IuI7py\"],\"text\":[\"随便走走，发现世界还是很美好的。当拥有美好事物时，经常习惯性的熟视无睹;当努力抓住你想要的东西时，它又可能瞬间破碎。但依旧需要不妥协。\",\"荔枝——我心目中的水果之王（有之一）\",\"高中时代最新款的mp4，现已成了老古董\",\"台风来临时，刚好会是暑假。但我已没有暑假。\",\"看着一场雨由远及近的淋湿院子，太漂亮\",\"归来却空空的行囊 那故乡的云 那故乡的风 啦啦啦啦啦 啦啦啦。\",\"在今年第一个狂风大作的早上，回家去\",\"98年，世界杯第一次在我脑中留下记忆，和爸，围着那台很小的tcl。今天，爸还打电话给我，让我别看太晚影响到明天工作，但我知道他自己也会去看的。是的，我们爱足球，今生今世\",\"这几天深圳的天空很美，无论晴雨\"],\"type\":[\"image\",\"image\",\"image\",\"image\",\"image\",\"image\",\"image\",\"image\",\"image\"]}},{\"date\":\"2014-6\",\"arr\":{\"year\":2014,\"month\":6,\"src\":[\"https://scontent.cdninstagram.com/hphotos-xfa1/t51.2885-15/e15/10362316_1434933843444633_1187384207_n.jpg\",\"https://scontent.cdninstagram.com/hphotos-prn/t51.2885-15/e15/10471930_507725875994902_393186392_n.jpg\",\"https://scontent.cdninstagram.com/hphotos-xaf1/t51.2885-15/e15/10454011_484872768311603_738380027_n.jpg\",\"https://scontent.cdninstagram.com/hphotos-xaf1/t51.2885-15/e15/923661_248502122024084_2086692261_n.jpg\",\"https://scontent.cdninstagram.com/hphotos-xtp1/t51.2885-15/e15/10424605_774238262594769_78480252_n.jpg\"],\"link\":[\"p06uEZI7tG\",\"pytFNpo7sD\",\"poMFteI7q0\",\"pMt5tgI7vj\",\"o3eroFo7gK\"],\"text\":[\"“往事依稀浑似梦，都随风雨到心头”——梅表姐\",\"navy blue\",\"今天我遇到一朵枯玫瑰。她只是枯萎，从未凋零。\",\"上届卫冕冠军被打成筛子的…是热火…\",\"我和大神的差距——web工程师的自我修养\"],\"type\":[\"image\",\"image\",\"image\",\"image\",\"image\"]}},{\"date\":\"2014-5\",\"arr\":{\"year\":2014,\"month\":5,\"src\":[\"https://scontent.cdninstagram.com/hphotos-xat1/t51.2885-15/e15/10387796_255697041300477_753213015_n.jpg\",\"https://scontent.cdninstagram.com/hphotos-frc/t51.2885-15/e15/10005623_779769878723970_627922376_n.jpg\",\"https://scontent.cdninstagram.com/hphotos-xpf1/t51.2885-15/e15/10358172_1495900567292387_640174442_n.jpg\",\"https://scontent.cdninstagram.com/hphotos-xta1/t51.2885-15/e15/10369281_674379822637848_233362820_n.jpg\",\"https://scontent.cdninstagram.com/hphotos-xfa1/t51.2885-15/e15/928251_430572373746575_786910314_n.jpg\",\"https://scontent.cdninstagram.com/hphotos-frc/t51.2885-15/e15/10358301_256481271142988_1088114034_n.jpg\",\"https://scontent.cdninstagram.com/hphotos-xap1/t51.2885-15/e15/10296597_1413560715589179_392570057_n.jpg\",\"https://scontent.cdninstagram.com/hphotos-xtf1/t51.2885-15/e15/10299642_561366610636165_721929935_n.jpg\",\"https://scontent.cdninstagram.com/hphotos-xfa1/t51.2885-15/e15/10268965_1446530205590326_114108738_n.jpg\"],\"link\":[\"op03boo7lW\",\"ops-ZUI7t-\",\"ofqhBpI7mQ\",\"odP0cno7ue\",\"oLX-4GI7ne\",\"oBl6WtI7qC\",\"nvPChzI7vU\",\"ngAyz8o7qj\",\"ndTggdI7jn\"],\"text\":[\"突然发现我还是挺喜欢大晴天的\",\"单人旅行走起！开心\",\"不久就可以吃了\",\"黄昏时分\",\"大雨倾城\",\"今天路过公园，一朵玉兰掉在身边。想起小时候陪伴我的三棵树，两棵木棉，一棵玉兰。当然玉兰这名字是后来才知道的，记忆里的那朵永远叫做香花。三年级的某天放学，这三棵树一并倒下了。\",\"雨中深大。雨季再来不再来。\",\"say hey to may\",\"故事中的小黄花\"],\"type\":[\"image\",\"image\",\"image\",\"image\",\"image\",\"image\",\"image\",\"image\",\"image\"]}},{\"date\":\"2014-4\",\"arr\":{\"year\":2014,\"month\":4,\"src\":[\"https://scontent.cdninstagram.com/hphotos-ash/t51.2885-15/e15/10261258_711820055527911_220271949_n.jpg\",\"https://scontent.cdninstagram.com/hphotos-xpt1/t51.2885-15/e15/10249356_695726313802446_881680057_n.jpg\",\"https://scontent.cdninstagram.com/hphotos-ash/t51.2885-15/e15/10268929_597082527053970_1060360934_n.jpg\",\"https://scontent.cdninstagram.com/hphotos-ash/t51.2885-15/e15/10268941_490697914386538_1148834228_n.jpg\",\"https://scontent.cdninstagram.com/hphotos-xtf1/t51.2885-15/e15/10254195_545488182236276_1930978882_n.jpg\",\"https://scontent.cdninstagram.com/hphotos-xtp1/t51.2885-15/e15/917572_539124756205696_1549712749_n.jpg\",\"https://scontent.cdninstagram.com/hphotos-xaf1/t51.2885-15/e15/927273_657564254280429_578859844_n.jpg\",\"https://scontent.cdninstagram.com/hphotos-frc/t51.2885-15/e15/10175316_650834874981595_1358429831_n.jpg\",\"https://scontent.cdninstagram.com/hphotos-xaf1/t51.2885-15/e15/926422_245144379006241_1254093305_n.jpg\",\"https://scontent.cdninstagram.com/hphotos-xaf1/t51.2885-15/e15/891289_302574849898688_205313988_n.jpg\",\"https://scontent.cdninstagram.com/hphotos-frc/t51.2885-15/e15/10175309_510867459023322_1700312549_n.jpg\"],\"link\":[\"nOGNjUI7op\",\"nGJfYAo7lW\",\"nATIxlI7tR\",\"mxsNwto7pQ\",\"mm7JTUI7p0\",\"mhER0lo7oe\",\"mfvVUYI7hu\",\"mdF-nNo7pE\",\"mcVLQzo7nl\",\"mb5cFho7sd\",\"maqYInI7if\"],\"text\":[\"谢谢亲们的蛋糕和礼物;谢谢我们始终用“同学”来称呼彼此。\",\"处女座老榕树\",\"放风筝的人们\",\"现在我的状态，像极了一只被推上战场僵尸\",\"这几天我耳边是都是这样的话语:1、“就是敲敲键盘，挺清闲的哈！”2、“别太挑剔，给个一两千就先做着”3、“什么？你那一碗粉要十二块钱？！”我回深圳了，几天的清静生活，谢谢乡亲们的招待。\",\"good luck\",\"瓦上花开\",\"好吧，这是一艘船\",\"石表山，思罗河，四年后的清明我又来到了这儿\",\"清明，一路向西\",\"清明一回到家，老妈就开始炫耀她试验种的豆芽。愿君多采撷，此物最好吃？\"],\"type\":[\"image\",\"image\",\"image\",\"image\",\"image\",\"image\",\"image\",\"image\",\"image\",\"image\",\"image\"]}},{\"date\":\"2014-3\",\"arr\":{\"year\":2014,\"month\":3,\"src\":[\"https://scontent.cdninstagram.com/hphotos-xft1/t51.2885-15/e15/10012487_604746702952671_676907736_n.jpg\",\"https://scontent.cdninstagram.com/hphotos-xfa1/t51.2885-15/e15/1171265_389602547845527_1588547561_n.jpg\",\"https://scontent.cdninstagram.com/hphotos-xfa1/t51.2885-15/e15/11376491_1614984048759908_413209146_n.jpg\",\"https://scontent.cdninstagram.com/hphotos-xft1/t51.2885-15/e15/11251074_365441270314698_1015057085_n.jpg\",\"https://scontent.cdninstagram.com/hphotos-xft1/t51.2885-15/e15/11380079_1581430378786145_504181803_n.jpg\",\"https://scontent.cdninstagram.com/hphotos-xtf1/t51.2885-15/e15/11330604_837683999618217_506172540_n.jpg\",\"https://scontent.cdninstagram.com/hphotos-xpa1/t51.2885-15/e15/11273047_110162449318540_1639646034_n.jpg\",\"https://scontent.cdninstagram.com/hphotos-xap1/t51.2885-15/e15/11375356_908792249164254_112740693_n.jpg\",\"https://scontent.cdninstagram.com/hphotos-xfa1/t51.2885-15/e15/11357539_388432694679963_1281450994_n.jpg\",\"https://scontent.cdninstagram.com/hphotos-xpa1/t51.2885-15/e15/11311124_1611430865770700_1482115931_n.jpg\"],\"link\":[\"mIgOdio7jT\",\"mIAS5lo7hb\",\"lrhVmio7lF\",\"lmADv6I7rU\",\"lhPFVeI7g6\",\"lcyrKSI7h_\",\"lSda6Ko7nG\",\"lSSxd8I7kB\",\"lK0xswI7s6\",\"lA4KaBI7go\"],\"text\":[\"转角遇到戏台，耳熟却不知道是哪一出了。想起爷爷以前的二胡与杨琴，自己精削细磨的琴竹，还有他组织的“菊山楼”粤剧队，真是一晃好些年。今年清明，一定回去。\",\"这本书超赞！好书好书好书\",\"四五点写程序太累，就不写了。不告诉任何人，跑到这个立交桥底，我已来过好几回。这里有一棵白色的紫荆花，满墙爬山虎，和刚放学的小朋友，出去，右拐，再右拐，转角可以遇到你，我的肉夹馍…\",\"越来越认生了，到步行街买衣服，找到比较适合的，却因为店员太过热情…跑了出来。闹市中居然藏有一古庙，还是这里自在，漫天神佛只是笑笑，不理物我，无论喜悲。对了我来这干嘛\",\"爬山的好处:强身健体，磨砺意志，开阔胸怀…坏处是:没有wifi。\",\"又见回南天\",\"老妈说，今天要我送个礼物！离家万里，只好迅速开发出这个app，摇后就会播放我唱的真的爱你。可惜她说摇后没反应，后来才知道，她拿的ipad在摇…但我是真的爱你\",\"今天下雨，的士司机都不肯理我。头上路灯光芒遥不可及，脚下路面棱角冰冷鲜明\",\"起风吧，明天。喜欢偏冷的日子，假如是春天，假如是风大，太完美了\",\"腾讯的凌晨四点半。第一次在此过夜，听着耳熟不能详的歌，看着平静不微笑的人。然后记起，家里打来被我按掉的电话，忘了回\"],\"type\":[\"image\",\"image\",\"image\",\"image\",\"image\",\"image\",\"image\",\"image\",\"image\",\"image\"]}},{\"date\":\"2014-2\",\"arr\":{\"year\":2014,\"month\":2,\"src\":[\"https://scontent.cdninstagram.com/hphotos-ash/t51.2885-15/e15/1737225_591794970889160_1849235580_n.jpg\",\"https://scontent.cdninstagram.com/hphotos-prn/t51.2885-15/e15/1741200_451260698337036_577792061_n.jpg\"],\"link\":[\"kv3jNgI7sw\",\"kr8sW8I7nR\"],\"text\":[\"“不能吃太胖喔，会被杀掉的！”\",\"今晚，已经看到两个小女生在问，这里有《九云梦》吗？\"],\"type\":[\"image\",\"image\"]}}]}"},{"title":"","date":"2022-03-02T09:31:31.268Z","updated":"2017-07-01T04:45:00.396Z","comments":true,"path":"assets/demo/border1px.html","permalink":"https://vlwq.github.io/assets/demo/border1px.html","excerpt":"","text":"日语50音 /*main*/ html{color:#000;background:#FFF}body,div,dl,dt,dd,ul,ol,li,h1,h2,h3,h4,h5,h6,pre,code,form,fieldset,legend,input,textarea,p,blockquote,th,td,menu{margin:0;padding:0}table{border-collapse:collapse;border-spacing:0}fieldset,img{border:0}address,caption,cite,code,dfn,em,strong,th,var{font-style:normal;font-weight:400}ol,ul{list-style:none}caption,th{text-align:left}h1,h2,h3,h4,h5,h6{font-size:100%;font-weight:400}q:before,q:after{content:''}abbr,acronym{border:0;font-variant:normal}sup{vertical-align:text-top}sub{vertical-align:text-bottom}input,textarea,select{font-family:inherit;font-size:inherit;font-weight:inherit}input,textarea,select{*font-size:100%}legend{color:#000}html,body{-webkit-text-size-adjust:none;-webkit-touch-callout:none;vertical-align:middle;font-size:16px;background:#e6e6e6;position:relative;height:100%;font-family:Tahoma,Arial,\"Microsoft Yahei\",sans-serif}.clearfix:after{content:\" \";display:block;clear:both;visibility:hidden;line-height:0;height:0}input::-webkit-input-placeholder{color:#aaa}a,div{-webkit-tap-highlight-color:rgba(0,0,0,0)}a,a:active,a:hover{color:#0057af;text-decoration:none}header,.header{width:215px;height:58px;background:url(http://3.url.cn/qun/create_iphone/img/sprite.png) no-repeat transparent 0 0;color:#fff;line-height:58px;padding-left:64px;font-size:24px;-webkit-transform:scale(0.82) scale(0.82);-webkit-transform-origin:0 50%}.input-group{overflow:hidden;vertical-align:middle;line-height:16px;background-color:#fff;}#main-section{position:relative;height:100%;min-height:370px;overflow:hidden;}.input-group label{width:100px;padding:10px 0 10px 12px;display:inline-block;border-right:0;float:left;color:gray;-webkit-appearance:none;height:24px;line-height:24px;}.input-group .ui-select{margin-left:115px;padding:10px 24px 10px 15px;position:relative;}.input-group .select-btn{width:100%;height:24px;line-height:24px;color:#aaa;}.input-group .select-btn span.ui-text{text-align:right;display:inline-block;width:100%;white-space:nowrap;overflow:inherit;text-overflow:ellipsis;pointer-events:none;}.input-group .select-btn span.ui-icon{display:inline-block;position:absolute;top:50%;margin:-10px 0 0 -3px;width:18px;height:20px;right:7px;}.input-group .select-btn span.ui-icon .arrow{width:18px;height:18px;position:relative;display:inline-block;float:right;background:transparent;margin-right:-5px;margin-top:1px;}.input-group .select-btn span.ui-icon .arrow div{background:#ccc;position:absolute;width:3px;height:12px;}.input-group .select-btn span.ui-icon .arrow div.arrow1{left:19px;top:12px;-webkit-transform:rotate(-45deg) translate(0,-142%);}.input-group .select-btn span.ui-icon .arrow div.arrow2{left:-5px;top:19px;-webkit-transform:rotate(45deg) translate(0,-142%);}.seg-words{color:#6d6d72;height:20px;font-size:1em;text-shadow:0 1px #fff;padding:3px 0 6px 14px;} /*border-1px 部分*/ .border-1px{ position: relative; } .border-1px:before, .border-1px:after{ border-top: 1px solid #c8c7cc; content: ' '; display: block; width: 100%; position: absolute; left: 0; } .border-1px:before{ top: 0; display: none; } .border-1px:after{ bottom: 0; } @media (-webkit-min-device-pixel-ratio:1.5), (min-device-pixel-ratio: 1.5){ .border-1px:after,.border-1px:before{ -webkit-transform: scaleY(.7); -webkit-transform-origin: 0 0; transform: scaleY(.7); } .border-1px:after{ -webkit-transform-origin: left bottom; } } @media (-webkit-min-device-pixel-ratio:2), (min-device-pixel-ratio: 2){ .border-1px:after,.border-1px:before{ -webkit-transform: scaleY(.5); transform: scaleY(.5); } } あ行 あ ア (a) い イ (i) う ウ (u) え エ (e) お オ (o) か行 か カ (ka) き キ (ki) く ク (ku) け ケ (ke) こ コ (ko) さ行 さ サ (sa) し シ (shi) す ス (su) せ セ (se) そ ソ (so) た行 た タ (ta) ち チ (chi) つ ツ (tsu) て テ (te) と ト (to) な行 な ナ (na) に ニ (ni) ぬ ヌ (nu) ね ネ (ne) の ノ (no) は行 は ハ (ha) ひ ヒ (hi) ふ フ (fu) へ ヘ (he) ほ ホ (ho) ま行 ま マ (ma) み ミ (mi) む ム (mu) め メ (me) も モ (mo) や行 や ヤ (ya) い イ (i) ゆ ユ (yu) え エ (e) よ ヨ (yo) ら行 ら ラ (ra) り リ (ri) る ル (ru) れ レ (re) ろ ロ (ro) わ行 わ ワ (wa) い イ (i) う ウ (u) え エ (e) を ヲ (wo) ん ん ン (n)"},{"title":"","date":"2022-03-02T09:31:31.255Z","updated":"2017-07-01T04:45:00.412Z","comments":true,"path":"assets/demo/gift/index.html","permalink":"https://vlwq.github.io/assets/demo/gift/index.html","excerpt":"","text":"礼物 - 3.8 3.8节礼物，来了… 首先，你要输入我的生日 接着，摇一摇… 最后，这就是见证奇迹的时刻… 3.8节快乐！ 祝身体健康,平安长乐 请打开音量收听… var Main = (function() { function playAudio(src) { if (typeof Audio != \"undefined\") { new Audio(src).play() ; } else if (typeof device != \"undefined\") { if (device.platform == 'Android') { console.log(src); } var mediaRes = new Media(src, function onSuccess() { mediaRes.release(); }, function onError(e){ console.log(\"error playing sound: \" + JSON.stringify(e)); }); mediaRes.play(); } else { alert(\"no sound API to play: \" + src); } } window.addEventListener('shake', autoRun, false); function autoRun(){ if($(\"#myBir\").val() == \"0425\"){ $(\"#se1\").hide(); $(\"#se2\").show(); playAudio(\"media/gift.ogg\"); }else{ alert(\"生日错误\"); } } var init = function() { } return { init: init } })(); $(Main.init());"},{"title":"","date":"2022-03-02T09:31:31.280Z","updated":"2017-07-01T04:45:00.412Z","comments":true,"path":"assets/demo/jiugongge_demo2.html","permalink":"https://vlwq.github.io/assets/demo/jiugongge_demo2.html","excerpt":"","text":"九宫格（二）demo #main{ width: 170px; height:170px; background: blue; margin: 0 auto; } #main div{ width: 50px; line-height: 50px; text-align:center; background: #AAA; margin:5px 5px 0 0; } #main a{ width: 55px; line-height: 55px; float: left; padding: 0 0 5px 5px; margin: 0 -5px -5px 0; text-decoration: none; } #main a:hover{ background: red; } 1 2 3 4 5 6 7 8 9"},{"title":"","date":"2022-03-02T09:31:31.271Z","updated":"2017-07-01T04:45:00.396Z","comments":true,"path":"assets/demo/coffee_pc_demo/pro-con.html","permalink":"https://vlwq.github.io/assets/demo/coffee_pc_demo/pro-con.html","excerpt":"","text":"body{ background: #fff; } .bufBox{ float: left; width: 50px; height: 50px; background: #ddd; border-radius: 5px; text-align: center; line-height: 50px; margin: 0 5px; position:relative; overflow: hidden; } .bufCover{ width: 100%; height: 0; background: #f0f; border-radius: 5px; position: absolute; } #buf{ height: 60px; } #des p{ padding: 4px 0; margin: 0; font-size: 14px; } #des .desPro{ color: #333; background: #EEE; } #des .desCon{ color: #EEE; background: #333; } #des .desSpe{ background: #BBB; } 生产 消费"},{"title":"","date":"2022-03-02T09:31:31.259Z","updated":"2017-07-01T04:45:00.427Z","comments":true,"path":"assets/demo/mediator/mediator.js","permalink":"https://vlwq.github.io/assets/demo/mediator/mediator.js","excerpt":"","text":"// Generated by CoffeeScript 1.4.0 (function() { var Player, mediator, scoreboard; Player = function(name) { this.points = 0; return this.name = name; }; Player.prototype.play = function() { this.points++; return mediator.played(); }; scoreboard = { element: document.getElementById(\"results\"), update: function(score) { var diff, key, msg, value; msg = ''; for (key in score) { value = score[key]; if (score.hasOwnProperty(key)) { msg = msg + (\"\" + key + \":\" + value + \"\"); } } this.element.innerHTML = msg; diff = score.Home - score.Guest; if (diff > 15) { alert(\"Home Win!\"); return location.reload(); } else if (diff < -15) { alert(\"Guest Win!\"); return location.reload(); } else { return document.getElementById('barGuest').style.width = 150 + (diff * 10) + 'px'; } } }; mediator = { players: {}, setup: function() { var players; players = this.players; players.home = new Player('Home'); return players.guest = new Player('Guest'); }, played: function() { var players, score; players = this.players; score = { Home: players.home.points, Guest: players.guest.points }; return scoreboard.update(score); }, keypress: function(e) { var keycode; e = e || window.event; keycode = e.which; if (keycode === 102) { mediator.players.home.play(); return; } if (keycode === 106) { mediator.players.guest.play(); } } }; mediator.setup(); window.onkeypress = mediator.keypress; }).call(this);"},{"title":"","date":"2022-03-02T09:31:31.278Z","updated":"2017-07-01T04:45:00.427Z","comments":true,"path":"assets/demo/my_news_reader/index.html","permalink":"https://vlwq.github.io/assets/demo/my_news_reader/index.html","excerpt":"","text":"myReader *{ margin: 0; padding: 0; } body{ background: #eee; overflow-x : hidden; overflow-y : hidden; } #container{ width: 600px; height: 400px; background: #eee; position: relative; } .tag{ position: absolute; } 点击变化布局"},{"title":"","date":"2022-03-02T09:31:31.258Z","updated":"2017-07-01T04:45:00.427Z","comments":true,"path":"assets/demo/mediator/demo.html","permalink":"https://vlwq.github.io/assets/demo/mediator/demo.html","excerpt":"","text":"*{ margin:0; padding:0; } #textBox{ position: absolute; left: 0; top: 0; z-index: -999; } #bg{ background: url(sgws.jpg) -50px; width:500px; height: 314px; text-align: center; position: relative; -webkit-animation:roll 3s infinite ease ; -moz-animation:roll 3s infinite ease ; -ms-animation:roll 3s infinite ease ; -o-animation:roll 3s infinite ease ; animation:roll 3s infinite ease ; } #barHome{ width: 300px; height: 10px; background: #f00; overflow: hidden; position: absolute; bottom: 45px; left: 50%; margin-left: -150px; } #barGuest{ width: 150px; height: 10px; background: #00f; } #results{ width: 300px; position: absolute; bottom: 65px; left: 50%; margin-left: -150px; color: #fff; } #results span{ margin: 50px; } @-webkit-keyframes roll {0%{background-position: -90px;}50%{background-position: -10px;}100%{background-position: -90px;}} @-moz-keyframes roll {0%{background-position: -90px;}50%{background-position: -10px;}100%{background-position: -90px;}} @-ms-keyframes roll {0%{background-position: -90px;}50%{background-position: -10px;}100%{background-position: -90px;}} @-o-keyframes roll {0%{background-position: -90px;}50%{background-position: -10px;}100%{background-position: -90px;}} @keyframes roll {0%{background-position: -90px;}50%{background-position: -10px;}100%{background-position: -90px;}} mediator 请按F键与J键"},{"title":"","date":"2022-03-02T09:31:31.267Z","updated":"2017-07-01T04:45:00.427Z","comments":true,"path":"assets/demo/pre_css3_demo/demo.html","permalink":"https://vlwq.github.io/assets/demo/pre_css3_demo/demo.html","excerpt":"","text":"*{ margin:0; padding: 0; } body{ overflow: hidden; } #textBox{ position: absolute; left: 0; top: 0; z-index: -999; } .showRoll #frame { border-color: hsl(0,0%,70%); position: absolute; } #box{ width: 641px; height: 483px; background: url(bg.jpg); border: 1px solid #ddd; position: relative; color: #fff; overflow: hidden; } #frame { width: 70px; height: 92px; left:370px; top:240px; position: absolute; border: 1px solid transparent; background: url(mhxy.png) no-repeat left top; -webkit-animation: anm-down 1s steps(8) infinite; -moz-animation: anm-down 1s steps(8) infinite; -ms-animation: anm-down 1s steps(8) infinite; -o-animation: anm-down 1s steps(8) infinite; animation: anm-down 1s steps(8) infinite; } @-webkit-keyframes anm-down { 0% { background-position: 0px 0; } 100% { background-position: -560px 0; } } @-moz-keyframes anm-down { 0% { background-position: 0px 0; } 100% { background-position: -560px 0; } } @-ms-keyframes anm-down { 0% { background-position: 0px 0; } 100% { background-position: -560px 0; } } @-o-keyframes anm-down { 0% { background-position: 0px 0; } 100% { background-position: -560px 0; } } @keyframes anm-down { 0% { background-position: 0px 0; } 100% { background-position: -560px 0; } } @-webkit-keyframes anm-left { 0% { background-position: 0px -92px; } 100% { background-position: -560px -92px; } } @-moz-keyframes anm-left { 0% { background-position: 0px -92px; } 100% { background-position: -560px -92px; } } @-ms-keyframes anm-left { 0% { background-position: 0px -92px; } 100% { background-position: -560px -92px; } } @-o-keyframes anm-left { 0% { background-position: 0px -92px; } 100% { background-position: -560px -92px; } } @keyframes anm-left { 0% { background-position: 0px -92px; } 100% { background-position: -560px -92px; } } @-webkit-keyframes anm-right { 0% { background-position: 0px -184px; } 100% { background-position: -560px -184px; } } @-moz-keyframes anm-right { 0% { background-position: 0px -184px; } 100% { background-position: -560px -184px; } } @-ms-keyframes anm-right { 0% { background-position: 0px -184px; } 100% { background-position: -560px -184px; } } @-o-keyframes anm-right { 0% { background-position: 0px -184px; } 100% { background-position: -560px -184px; } } @keyframes anm-right { 0% { background-position: 0px -184px; } 100% { background-position: -560px -184px; } } @-webkit-keyframes anm-up { 0% { background-position: 0px -276px; } 100% { background-position: -560px -276px; } } @-moz-keyframes anm-up { 0% { background-position: 0px -276px; } 100% { background-position: -560px -276px; } } @-ms-keyframes anm-up { 0% { background-position: 0px -276px; } 100% { background-position: -560px -276px; } } @-o-keyframes anm-up { 0% { background-position: 0px -276px; } 100% { background-position: -560px -276px; } } @keyframes anm-up { 0% { background-position: 0px -276px; } 100% { background-position: -560px -276px; } } @-webkit-keyframes anm-ld { 0% { background-position: 0px -368px; } 100% { background-position: -560px -368px; } } @-moz-keyframes anm-ld { 0% { background-position: 0px -368px; } 100% { background-position: -560px -368px; } } @-ms-keyframes anm-ld { 0% { background-position: 0px -368px; } 100% { background-position: -560px -368px; } } @-o-keyframes anm-ld { 0% { background-position: 0px -368px; } 100% { background-position: -560px -368px; } } @keyframes anm-ld { 0% { background-position: 0px -368px; } 100% { background-position: -560px -368px; } } @-webkit-keyframes anm-rd { 0% { background-position: 0px -460px; } 100% { background-position: -560px -460px; } } @-moz-keyframes anm-rd { 0% { background-position: 0px -460px; } 100% { background-position: -560px -460px; } } @-ms-keyframes anm-rd { 0% { background-position: 0px -460px; } 100% { background-position: -560px -460px; } } @-o-keyframes anm-rd { 0% { background-position: 0px -460px; } 100% { background-position: -560px -460px; } } @keyframes anm-rd { 0% { background-position: 0px -460px; } 100% { background-position: -560px -460px; } } @-webkit-keyframes anm-lu { 0% { background-position: 0px -552px; } 100% { background-position: -560px -552px; } } @-moz-keyframes anm-lu { 0% { background-position: 0px -552px; } 100% { background-position: -560px -552px; } } @-ms-keyframes anm-lu { 0% { background-position: 0px -552px; } 100% { background-position: -560px -552px; } } @-o-keyframes anm-lu { 0% { background-position: 0px -552px; } 100% { background-position: -560px -552px; } } @keyframes anm-lu { 0% { background-position: 0px -552px; } 100% { background-position: -560px -552px; } } @-webkit-keyframes anm-ru { 0% { background-position: 0px -644px; } 100% { background-position: -560px -644px; } } @-moz-keyframes anm-ru { 0% { background-position: 0px -644px; } 100% { background-position: -560px -644px; } } @-ms-keyframes anm-ru { 0% { background-position: 0px -644px; } 100% { background-position: -560px -644px; } } @-o-keyframes anm-ru { 0% { background-position: 0px -644px; } 100% { background-position: -560px -644px; } } @keyframes anm-ru { 0% { background-position: 0px -644px; } 100% { background-position: -560px -644px; } } test function setAnm (str){ switch (str){ case 'left':{ $(\"#frame\").css({\"animation\":\"anm-left 1s steps(8) infinite\"}); break; } case 'right':{ $(\"#frame\").css({\"animation\":\"anm-right 1s steps(8) infinite\"}); break; } case 'up':{ $(\"#frame\").css({\"animation\":\"anm-up 1s steps(8) infinite\"}); break; } case 'down':{ $(\"#frame\").css({\"animation\":\"anm-down 1s steps(8) infinite\"}); break; } case 'lu':{ $(\"#frame\").css({\"animation\":\"anm-lu 1s steps(8) infinite\"}); break; } case 'ld':{ $(\"#frame\").css({\"animation\":\"anm-ld 1s steps(8) infinite\"}); break; } case 'ru':{ $(\"#frame\").css({\"animation\":\"anm-ru 1s steps(8) infinite\"}); break; } case 'rd':{ $(\"#frame\").css({\"animation\":\"anm-rd 1s steps(8) infinite\"}); break; } } } var data = { x:0, y:0, l:false, r:false, u:false, d:false, time:null } function move(){ trans = \"translate(\"+data.x*50+\"px,\"+data.y*50+\"px)\"; $('#frame').css({\"transform\":trans,\"transition\":\"all 0.3s linear\"}); } function diff(){ var newTime = +new Date; if(!data.time){ data.time = newTime; } var diff = newTime-data.time; return diff; } $(window).keydown(function(event){ var keycode = event.which; if(keycode==37){ if(data.l) return; var isRun = diff(); console.log(isRun); data.l=true; if(data.u){ setAnm(\"lu\"); data.x--; if(isRun>480) data.y--; }else if(data.d){ setAnm(\"ld\"); data.x--; if(isRun>480) data.y++; }else{ setAnm(\"left\"); data.x--; } }else if(keycode==38){ if(data.u) return; var isRun = diff(); console.log(isRun); data.u=true; if(data.l){ setAnm(\"lu\"); if(isRun>480) data.x--; data.y--; }else if(data.r){ setAnm(\"ru\"); if(isRun>480) data.x++; data.y--; }else{ setAnm(\"up\"); data.y--; } }else if(keycode==39){ if(data.r) return; var isRun = diff(); console.log(isRun); data.r=true; if(data.u){ setAnm(\"ru\"); data.x++; if(isRun>480) data.y--; }else if(data.d){ setAnm(\"rd\"); data.x++; if(isRun>480) data.y++; }else{ setAnm(\"right\"); data.x++; } }else if(keycode==40){ if(data.d) return; var isRun = diff(); console.log(isRun); data.d=true; if(data.l){ setAnm(\"ld\"); if(isRun>480) data.x--; data.y++; }else if(data.r){ setAnm(\"rd\"); if(isRun>480) data.x++; data.y++; }else{ setAnm(\"down\"); data.y++; } } move(); }).keyup(function(){ data.l = data.r = data.u = data.d = false; data.time = null; });"},{"title":"","date":"2022-03-02T09:31:31.270Z","updated":"2017-07-01T04:45:00.412Z","comments":true,"path":"assets/demo/coffee_pc_demo/pro-con.js","permalink":"https://vlwq.github.io/assets/demo/coffee_pc_demo/pro-con.js","excerpt":"","text":"// Generated by CoffeeScript 1.4.0 (function() { var N, ProCon, func, procon; N = 10; func = function(a, b) { if (a == null) { a = 4; } if (b == null) { b = 6; } return a + b; }; ProCon = (function() { function ProCon() {} ProCon.prototype.data = { mutex: 1, empty: N, full: 0, front: 0, rear: 0, buf: [] }; ProCon.prototype.init = function() { var i, newDom, _this = this; i = 0; while (i < N) { newDom = $('' + i + '' + i + ''); $('#buf').append(newDom); this.data.buf.push('e'); i++; } $('#produce').click(function() { return _this.producer(); }); return $('#consume').click(function() { return _this.consumer(); }); }; ProCon.prototype.p = function(num) { return --num; }; ProCon.prototype.v = function(num) { return ++num; }; ProCon.prototype.produceItem = function() { $('生产了产品').insertBefore($(\"#des p:first\")); return 'm'; }; ProCon.prototype.consumeItem = function() { return $('消费了产品').insertBefore($(\"#des p:first\")); }; ProCon.prototype.enterItem = function(item) { var str; this.data.front = (this.data.front + 1) % N; this.data.buf[this.data.front] = item; str = \"存入产品\" + this.data.buf[this.data.front] + \"到缓冲区\" + this.data.front; $(\"\" + str + \"\").insertBefore($(\"#des p:first\")); return $($('.bufCover')[this.data.front]).animate({ \"height\": \"50px\" }); }; ProCon.prototype.removeItem = function() { var str; this.data.rear = (this.data.rear + 1) % N; this.data.buf[this.data.rear] = 'e'; str = \"取出产品\" + this.data.buf[this.data.rear] + \"从缓冲区\" + this.data.rear; $(\"\" + str + \"\").insertBefore($(\"#des p:first\")); return $($('.bufCover')[this.data.rear]).animate({ \"height\": \"0px\" }); }; ProCon.prototype.producer = function() { var item; if (this.data.full === N) { $(\"缓冲区已全满\").insertBefore($(\"#des p:first\")); return; } item = this.produceItem(); this.data.empty = this.p(this.data.empty); this.data.mutex = this.p(this.data.mutex); this.enterItem(item); this.data.mutex = this.v(this.data.mutex); return this.data.full = this.v(this.data.full); }; ProCon.prototype.consumer = function() { if (this.data.empty === N) { $(\"缓冲区已空\").insertBefore($(\"#des p:first\")); return; } this.data.full = this.p(this.data.full); this.data.mutex = this.p(this.data.mutex); this.removeItem(); this.data.mutex = this.v(this.data.mutex); this.data.empty = this.v(this.data.empty); return this.consumeItem(); }; return ProCon; })(); procon = new ProCon; procon.init(); }).call(this);"},{"title":"","date":"2022-03-02T09:31:31.246Z","updated":"2017-07-01T04:45:00.412Z","comments":true,"path":"assets/demo/gift/css/index.css","permalink":"https://vlwq.github.io/assets/demo/gift/css/index.css","excerpt":"","text":"body{background:#f7f7f5;font-family:\"Helvetica Neue\",Helvetica,STHeiTi,sans-serif}header{height:44px;border-bottom:1px solid #000;background:#272c2f}header p{color:#fff;text-align:center;font-size:20px;line-height:40px}.hide{display:none}.paper-t{display:block;height:16px;width:100%;background:url(../img/paper.jpg) repeat-x;background-size:320px 15px}.paper-b{display:block;height:19px;width:100%;background:url(../img/paper-b.jpg) repeat-x;background-size:100% 19px;position:absolute;bottom:0px}.main{color:#2495e1;margin:-61px 8px 0px;height:100%;position:relative}.main .main-top{padding-top:61px;font-weight:500}.main .main-top .main-top-l{float:left}.main .main-top .main-top-r{float:right}.main .main-top:after{content:\"\";display:block;clear:both}.main .main-middle{font-size:98px;font-weight:500;text-align:center;line-height:141px}.main .main-bottom{width:100%;position:absolute;bottom:8px}.main .main-bottom nav{border:1px solid #2495e1;border-radius:3px;height:25px}.main .main-bottom nav span{float:left;display:inline-block;border-right:1px solid #2495e1;height:100%;width:33.1%;text-align:center;font-size:14px;line-height:26px}.main .main-bottom nav span:last-child{border-right:none}.main .main-bottom nav span.cur{background:#2495e1;color:#fff}.main .main-bottom .good-bad{height:140px;padding:20px 10px 10px}.main .main-bottom .good-bad em{display:inline-block;width:30px;height:30px;border-radius:15px;color:#fff;background:#2495e1;text-align:center;line-height:30px;float:left}.main .main-bottom .good-bad ul{padding-left:45px}.main .main-bottom .good-bad ul li{margin-bottom:13px}.main .main-bottom .good-bad ul p{font-size:18px;font-weight:500}.main .main-bottom .good-bad ul h3{font-size:30px;margin:23px 0px}.main .main-bottom .good-bad ul span{font-size:13px;color:#808080;margin-left:12px;display:block}.main .main-bottom .good-bad ul span:before{width:13px;height:11px;font-size:20px;font-weight:400;font-family:Georgia;content:\"\\201C\";position:absolute;color:#808080;left:56px}.main .main-bottom .good{border-bottom:1px solid #dfdfdf}.main .main-bottom .nav-chose .good{border-bottom:1px solid rgba(0,0,0,0)}.nav-chose .good-bad{text-align:center}.nav-chose .good-bad img{width:130px;margin-top:28px}.nav-chose .good-bad h2{margin:4px}.nav-chose .good-bad span{color:#666;margin:0 5px}.nav-chose .good-bad section{display:none}.nav-chose .good-bad section h3{display:none}.nav-chose .good-bad section.active{display:block} .top2{ text-align: center; margin-top: 40px; } .top2 p{ margin: 10px 0px; color:#2495e1; } .top2 input{ height: 30px; padding: 5px; border-radius: 3px; border: 2px solid #2495e1; outline: none; } .top2 img{ width: 43%; }"},{"title":"","date":"2022-03-02T09:31:31.275Z","updated":"2017-07-01T04:45:00.427Z","comments":true,"path":"assets/demo/my_news_reader/js/main.js","permalink":"https://vlwq.github.io/assets/demo/my_news_reader/js/main.js","excerpt":"","text":"function H$(i){return document.getElementById(i);} function H$$(c,p){ if(p) return p.getElementsByTagName(c); else return document.getElementsByTagName(c); } var tagElems = []; (function() { function ranOrNot(e, t) { var n = []; typeof t == \"undefined\" && (t = e, e = 0); for (; e < t; e++) n.push(e); return n } Array.prototype.randomEach = function(t) { if (typeof t != \"function\") throw new TypeError; var n = this.length, r = ranOrNot(n); while (n) { var i = Math.floor(Math.random() * n--); if (t(this[r[i]]) === !1) break; r[i] = r[n] } }, Array.prototype.forEach || (Array.prototype.forEach = function(e) { var t = this.length; if (typeof e != \"function\") throw new TypeError; var n = arguments[1]; for (var r = 0; r < t; r++) r in this && e.call(n, this[r], r, this) }) } )(); function _shadowClone(e) { var t = {}; for (var n in e) e.hasOwnProperty(n) && (t[n] = e[n]); return t; } function attrStyle(elem,attr){ if(elem.style[attr]){ return elem.style[attr]; }else if(elem.currentStyle){ return elem.currentStyle[attr]; }else if(document.defaultView && document.defaultView.getComputedStyle){ attr=attr.replace(/([A-Z])/g,'-$1').toLowerCase(); return document.defaultView.getComputedStyle(elem,null).getPropertyValue(attr); }else{ return null; } } /////////////////////////// function AutoLoader(fun, timeout) { if (typeof fun != \"function\") throw new TypeError; this._generator = fun; this._timeout = timeout; this._context = arguments[2]; this._pool = []; } AutoLoader.prototype._load = function() { var e = this; clearTimeout(this._loading); this._loading = setTimeout(function() { e._pool.push(e._generator.apply(e._context)) }, this._timeout); } AutoLoader.prototype.get = function() { var e; clearTimeout(this._loading); this._pool.length > 0 ? e = this._pool.pop() : e = this._generator.apply(this._context); return e; } function _cutGrid(tag, funcJudge) { function a(a) { function h(cutLength) { var u, a = _shadowClone(cutLength); c++, u = c === l ? tag[cutType2.measure] - s: Math.floor(cutLength[cutType2.measure] * tag[cutType2.measure] / 100), a[cutType1.offset] = i + tag[cutType1.offset], a[cutType2.offset] = s + tag[cutType2.offset], a[cutType1.measure] = f, a[cutType2.measure] = u, a.colorPattern = tag.colorPattern, funcJudge(a), s += u } var f, l = a[cutType2.name].length, c = 0; u++, f = u === cutLength ? tag[cutType1.measure] - i: Math.floor(a[cutType1.measure] * tag[cutType1.measure] / 100), a.random === !1 ? a[cutType2.name].forEach(h) : a[cutType2.name].randomEach(h), s = 0, i += f } /*根据大块是否有rows属性，定义两种切割方式*/ var cutType1, cutType2; tag.rows ? (cutType1 = { name: \"rows\", measure: \"height\", offset: \"top\" }, cutType2 = { name: \"cols\", measure: \"width\", offset: \"left\" }) : (cutType1 = { name: \"cols\", measure: \"width\", offset: \"left\" }, cutType2 = { name: \"rows\", measure: \"height\", offset: \"top\" }); var i = 0, s = 0, cutLength = tag[cutType1.name].length, u = 0; tag.random === !1 ? tag[cutType1.name].forEach(a) : tag[cutType1.name].randomEach(a) } function _getGrids(tag) { var t = [], colorCount = 0, fontScale = .18, colorArr = tag.colorPatterns[0]; _cutGrid(tag.pageLayout, function(tag) { /*如果是新的大块，则colorPattern不存在，使用新的颜色。*/ tag.colorPattern || (tag.colorPattern = colorArr[colorCount++]); /*tagConfig本来没有rows或cols，是大块。执行else部分*/ if (tag.rows || tag.cols) { _cutGrid(tag, arguments.callee); } else { var s = tag.colorPattern, o = s.backgrounds, u = o.length, a = s.fontColor; tag.fontSize = Math.floor(Math.sqrt(tag.width * tag.height) * fontScale); tag.backgroundColor = o[Math.floor(Math.random() * u)]; tag.fontColor = a; t.push(tag); } } ); return t; } var myReader = function(){ function inits(o){ this.dom = H$(o.domId); this.len = o.len; this.block = o.block; this.fillStage(H$(\"container\")); this.clickEve(); } inits.prototype={ clickEve:function(){ var _this=this; var dom = H$$(\"button\"); dom[0].onclick=function(){ H$(\"container\").innerHTML=\"\"; _this.fillStage(H$(\"container\")); } }, reflowTagElem:function(dom, t,sw,sh) { dom.style.top = t.top*sh + \"px\"; dom.style.left = t.left*sw + \"px\"; dom.style.width = t.width*sw - 2 + \"px\"; dom.style.height = t.height*sh - 2 + \"px\"; dom.style.fontSize = t.fontSize*sw + \"px\"; dom.style.color = t.fontColor; dom.style.backgroundColor = t.backgroundColor; dom.order = t.width*sw * t.height*sh; }, fillStage:function(dom) { var _this=this; var data = _getGrids(window.tagConfig); data.forEach(function(data) { var div = document.createElement(\"div\"); div.className = \"tag\"; _this.reflowTagElem(div, data,6,4); dom.appendChild(div); tagElems.push(div); }); } } return inits; }(); var myData = { domId:\"container\" } new myReader(myData);"},{"title":"","date":"2022-03-02T09:31:31.244Z","updated":"2017-07-01T04:45:00.412Z","comments":true,"path":"assets/demo/gift/js/index.main.js","permalink":"https://vlwq.github.io/assets/demo/gift/js/index.main.js","excerpt":"","text":""},{"title":"","date":"2022-03-02T09:31:31.247Z","updated":"2017-07-01T04:45:00.412Z","comments":true,"path":"assets/demo/gift/css/reset.css","permalink":"https://vlwq.github.io/assets/demo/gift/css/reset.css","excerpt":"","text":"html{color:#000}blockquote,body,code,dd,div,dl,dt,fieldset,form,h1,h2,h3,h4,h5,h6,input,legend,li,menu,ol,p,pre,td,textarea,th,ul{margin:0;padding:0}table{border-collapse:collapse;border-spacing:0}fieldset,img{border:0}address,caption,cite,code,dfn,em,strong,th,var{font-style:normal;font-weight:400}ol,ul{list-style:none}caption,th{text-align:left}h1,h2,h3,h4,h5,h6{font-size:100%;font-weight:400}q:after,q:before{content:''}abbr,acronym{border:0;font-variant:normal}sup{vertical-align:text-top}sub{vertical-align:text-bottom}input,select,textarea{font-family:inherit;font-size:inherit;font-weight:inherit;*font-size:100%}legend{color:#000}body,html{-webkit-text-size-adjust:none;-webkit-touch-callout:none;vertical-align:middle;font-size:16px;background:#e6e6e6;position:relative;height:100%;font-family:Tahoma,Arial,\"Microsoft Yahei\",sans-serif}.clearfix:after{content:\" \";display:block;clear:both;visibility:hidden;line-height:0;height:0}input::-webkit-input-placeholder{color:#aaa}a,div{-webkit-tap-highlight-color:rgba(0,0,0,0)}a,a:active,a:hover{color:#0057af;text-decoration:none}"},{"title":"","date":"2022-03-02T09:31:31.277Z","updated":"2017-07-01T04:45:00.427Z","comments":true,"path":"assets/demo/my_news_reader/js/tagConfig.js","permalink":"https://vlwq.github.io/assets/demo/my_news_reader/js/tagConfig.js","excerpt":"","text":"window.tagConfig = { areas: { cols_40_60: [{ width: 40, rows: [{ height: 100 }] }, { width: 60, rows: [{ height: 100 }] }], cols_50_50: [{ width: 50, rows: [{ height: 100 }] }, { width: 50, rows: [{ height: 100 }] }], cols_32_32_36: [{ width: 32, rows: [{ height: 100 }] }, { width: 32, rows: [{ height: 100 }] }, { width: 36, rows: [{ height: 100 }] }] } }, window.tagConfig.pageLayout = { top: 0, left: 0, width: 100, height: 100, random: !1, cols: [{ width: 45, rows: [{ random: !1, height: 100, rows: [{ height: 45, cols: [{ width: 100 }] }, { height: 30, cols: [{ width: 100 }] }, { height: 25, cols: [{ width: 100, cols: [{ width: 35, rows: [{ height: 100 }] }, { width: 25, rows: [{ height: 30 }, { height: 40 }, { height: 30 }] }, { width: 15, rows: [{ height: 40 }, { height: 60 }] }, { width: 25, rows: [{ height: 35 }, { height: 25 }, { height: 40 }] }] }] }] }] }, { width: 55, random: !1, rows: [{ height: 50, cols: [{ width: 45, rows: [{ height: 35, cols: window.tagConfig.areas.cols_50_50 }, { height: 35, cols: window.tagConfig.areas.cols_40_60 }, { height: 30 }] }, { width: 55, rows: [{ height: 50 }, { height: 50 }] }] }, { height: 28, cols: [{ width: 30, rows: [{ height: 100 }] }, { width: 30, rows: [{ height: 40 }, { height: 60, cols: window.tagConfig.areas.cols_40_60 }] }, { width: 40, rows: [{ height: 50, cols: window.tagConfig.areas.cols_50_50 }, { height: 50, cols: window.tagConfig.areas.cols_32_32_36 }] }] }, { height: 22, cols: [{ width: 35, rows: [{ height: 100 }] }, { width: 15, rows: [{ height: 50 }, { height: 50 }] }, { width: 15, rows: [{ height: 50 }, { height: 50 }] }, { width: 20, rows: [{ height: 32 }, { height: 32 }, { height: 36 }] }, { width: 15, rows: [{ height: 50 }, { height: 50 }] }] }] }] }, window.tagConfig.colorPatterns = [[{ backgrounds: [\"#ce5f52\", \"#e37063\"], fontColor: \"#FFF\", borderColor: \"#5c666f\" }, { backgrounds: [\"#6c5d56\", \"#746760\"], fontColor: \"#FFF\", borderColor: \"#5c666f\" }, { backgrounds: [\"#c8b66a\", \"#dbc877\"], fontColor: \"#FFF\", borderColor: \"#5c666f\" }, { backgrounds: [\"#6e96b1\", \"#82a8bf\"], fontColor: \"#FFF\", borderColor: \"#5c666f\" }]];"},{"title":"","date":"2022-03-02T09:31:31.261Z","updated":"2017-07-01T04:45:00.427Z","comments":true,"path":"assets/demo/jquery.js","permalink":"https://vlwq.github.io/assets/demo/jquery.js","excerpt":"","text":"/*! jQuery v@1.8.0 jquery.com | jquery.org/license */ (function(a,b){function G(a){var b=F[a]={};return p.each(a.split(s),function(a,c){b[c]=!0}),b}function J(a,c,d){if(d===b&&a.nodeType===1){var e=\"data-\"+c.replace(I,\"-$1\").toLowerCase();d=a.getAttribute(e);if(typeof d==\"string\"){try{d=d===\"true\"?!0:d===\"false\"?!1:d===\"null\"?null:+d+\"\"===d?+d:H.test(d)?p.parseJSON(d):d}catch(f){}p.data(a,c,d)}else d=b}return d}function K(a){var b;for(b in a){if(b===\"data\"&&p.isEmptyObject(a[b]))continue;if(b!==\"toJSON\")return!1}return!0}function ba(){return!1}function bb(){return!0}function bh(a){return!a||!a.parentNode||a.parentNode.nodeType===11}function bi(a,b){do a=a[b];while(a&&a.nodeType!==1);return a}function bj(a,b,c){b=b||0;if(p.isFunction(b))return p.grep(a,function(a,d){var e=!!b.call(a,d,a);return e===c});if(b.nodeType)return p.grep(a,function(a,d){return a===b===c});if(typeof b==\"string\"){var d=p.grep(a,function(a){return a.nodeType===1});if(be.test(b))return p.filter(b,d,!c);b=p.filter(b,d)}return p.grep(a,function(a,d){return p.inArray(a,b)>=0===c})}function bk(a){var b=bl.split(\"|\"),c=a.createDocumentFragment();if(c.createElement)while(b.length)c.createElement(b.pop());return c}function bC(a,b){return a.getElementsByTagName(b)[0]||a.appendChild(a.ownerDocument.createElement(b))}function bD(a,b){if(b.nodeType!==1||!p.hasData(a))return;var c,d,e,f=p._data(a),g=p._data(b,f),h=f.events;if(h){delete g.handle,g.events={};for(c in h)for(d=0,e=h[c].length;d"},{"title":"","date":"2022-03-02T09:31:31.242Z","updated":"2017-07-01T04:45:00.412Z","comments":true,"path":"assets/demo/gift/js/shake.js","permalink":"https://vlwq.github.io/assets/demo/gift/js/shake.js","excerpt":"","text":"/* * * Find more about this plugin by visiting * http://alxgbsn.co.uk/ * * Copyright (c) 2010-2012 Alex Gibson * Released under MIT license * */ (function (window, document) { function Shake() { //feature detect this.hasDeviceMotion = 'ondevicemotion' in window; //default velocity threshold for shake to register this.threshold = 15; //use date to prevent multiple shakes firing this.lastTime = new Date(); //accelerometer values this.lastX = null; this.lastY = null; this.lastZ = null; //create custom event if (typeof document.CustomEvent === \"function\") { this.event = new document.CustomEvent('shake', { bubbles: true, cancelable: true }); } else if (typeof document.createEvent === \"function\") { this.event = document.createEvent('Event'); this.event.initEvent('shake', true, true); } else { return false; } } //reset timer values Shake.prototype.reset = function () { this.lastTime = new Date(); this.lastX = null; this.lastY = null; this.lastZ = null; }; //start listening for devicemotion Shake.prototype.start = function () { this.reset(); if (this.hasDeviceMotion) { window.addEventListener('devicemotion', this, false); } }; //stop listening for devicemotion Shake.prototype.stop = function () { if (this.hasDeviceMotion) { window.removeEventListener('devicemotion', this, false); } this.reset(); }; //calculates if shake did occur Shake.prototype.devicemotion = function (e) { var current = e.accelerationIncludingGravity, currentTime, timeDifference, deltaX = 0, deltaY = 0, deltaZ = 0; if ((this.lastX === null) && (this.lastY === null) && (this.lastZ === null)) { this.lastX = current.x; this.lastY = current.y; this.lastZ = current.z; return; } deltaX = Math.abs(this.lastX - current.x); deltaY = Math.abs(this.lastY - current.y); deltaZ = Math.abs(this.lastZ - current.z); if (((deltaX > this.threshold) && (deltaY > this.threshold)) || ((deltaX > this.threshold) && (deltaZ > this.threshold)) || ((deltaY > this.threshold) && (deltaZ > this.threshold))) { //calculate time in milliseconds since last shake registered currentTime = new Date(); timeDifference = currentTime.getTime() - this.lastTime.getTime(); if (timeDifference > 1000) { window.dispatchEvent(this.event); this.lastTime = new Date(); } } this.lastX = current.x; this.lastY = current.y; this.lastZ = current.z; }; //event handler Shake.prototype.handleEvent = function (e) { if (typeof (this[e.type]) === 'function') { return this[e.type](e); } }; //create a new instance of shake.js. var myShakeEvent = new Shake(); myShakeEvent && myShakeEvent.start(); }(window, document));"},{"title":"","date":"2022-03-02T09:31:31.243Z","updated":"2017-07-01T04:45:00.412Z","comments":true,"path":"assets/demo/gift/js/zepto.min.js","permalink":"https://vlwq.github.io/assets/demo/gift/js/zepto.min.js","excerpt":"","text":"/* Zepto v1.1.3 - zepto event ajax form ie - zeptojs.com/license */ var Zepto=function(){function L(t){return null==t?String(t):j[T.call(t)]||\"object\"}function Z(t){return\"function\"==L(t)}function $(t){return null!=t&&t==t.window}function _(t){return null!=t&&t.nodeType==t.DOCUMENT_NODE}function D(t){return\"object\"==L(t)}function R(t){return D(t)&&!$(t)&&Object.getPrototypeOf(t)==Object.prototype}function M(t){return\"number\"==typeof t.length}function k(t){return s.call(t,function(t){return null!=t})}function z(t){return t.length>0?n.fn.concat.apply([],t):t}function F(t){return t.replace(/::/g,\"/\").replace(/([A-Z]+)([A-Z][a-z])/g,\"$1_$2\").replace(/([a-z\\d])([A-Z])/g,\"$1_$2\").replace(/_/g,\"-\").toLowerCase()}function q(t){return t in f?f[t]:f[t]=new RegExp(\"(^|\\\\s)\"+t+\"(\\\\s|$)\")}function H(t,e){return\"number\"!=typeof e||c[F(t)]?e:e+\"px\"}function I(t){var e,n;return u[t]||(e=a.createElement(t),a.body.appendChild(e),n=getComputedStyle(e,\"\").getPropertyValue(\"display\"),e.parentNode.removeChild(e),\"none\"==n&&(n=\"block\"),u[t]=n),u[t]}function V(t){return\"children\"in t?o.call(t.children):n.map(t.childNodes,function(t){return 1==t.nodeType?t:void 0})}function U(n,i,r){for(e in i)r&&(R(i[e])||A(i[e]))?(R(i[e])&&!R(n[e])&&(n[e]={}),A(i[e])&&!A(n[e])&&(n[e]=[]),U(n[e],i[e],r)):i[e]!==t&&(n[e]=i[e])}function B(t,e){return null==e?n(t):n(t).filter(e)}function J(t,e,n,i){return Z(e)?e.call(t,n,i):e}function X(t,e,n){null==n?t.removeAttribute(e):t.setAttribute(e,n)}function W(e,n){var i=e.className,r=i&&i.baseVal!==t;return n===t?r?i.baseVal:i:void(r?i.baseVal=n:e.className=n)}function Y(t){var e;try{return t?\"true\"==t||(\"false\"==t?!1:\"null\"==t?null:/^0/.test(t)||isNaN(e=Number(t))?/^[\\[\\{]/.test(t)?n.parseJSON(t):t:e):t}catch(i){return t}}function G(t,e){e(t);for(var n in t.childNodes)G(t.childNodes[n],e)}var t,e,n,i,C,N,r=[],o=r.slice,s=r.filter,a=window.document,u={},f={},c={\"column-count\":1,columns:1,\"font-weight\":1,\"line-height\":1,opacity:1,\"z-index\":1,zoom:1},l=/^\\s*]*>/,h=/^(?:|)$/,p=/]*)\\/>/gi,d=/^(?:body|html)$/i,m=/([A-Z])/g,g=[\"val\",\"css\",\"html\",\"text\",\"data\",\"width\",\"height\",\"offset\"],v=[\"after\",\"prepend\",\"before\",\"append\"],y=a.createElement(\"table\"),x=a.createElement(\"tr\"),b={tr:a.createElement(\"tbody\"),tbody:y,thead:y,tfoot:y,td:x,th:x,\"*\":a.createElement(\"div\")},w=/complete|loaded|interactive/,E=/^[\\w-]*$/,j={},T=j.toString,S={},O=a.createElement(\"div\"),P={tabindex:\"tabIndex\",readonly:\"readOnly\",\"for\":\"htmlFor\",\"class\":\"className\",maxlength:\"maxLength\",cellspacing:\"cellSpacing\",cellpadding:\"cellPadding\",rowspan:\"rowSpan\",colspan:\"colSpan\",usemap:\"useMap\",frameborder:\"frameBorder\",contenteditable:\"contentEditable\"},A=Array.isArray||function(t){return t instanceof Array};return S.matches=function(t,e){if(!e||!t||1!==t.nodeType)return!1;var n=t.webkitMatchesSelector||t.mozMatchesSelector||t.oMatchesSelector||t.matchesSelector;if(n)return n.call(t,e);var i,r=t.parentNode,o=!r;return o&&(r=O).appendChild(t),i=~S.qsa(r,e).indexOf(t),o&&O.removeChild(t),i},C=function(t){return t.replace(/-+(.)?/g,function(t,e){return e?e.toUpperCase():\"\"})},N=function(t){return s.call(t,function(e,n){return t.indexOf(e)==n})},S.fragment=function(e,i,r){var s,u,f;return h.test(e)&&(s=n(a.createElement(RegExp.$1))),s||(e.replace&&(e=e.replace(p,\"\")),i===t&&(i=l.test(e)&&RegExp.$1),i in b||(i=\"*\"),f=b[i],f.innerHTML=\"\"+e,s=n.each(o.call(f.childNodes),function(){f.removeChild(this)})),R(r)&&(u=n(s),n.each(r,function(t,e){g.indexOf(t)>-1?u[t](e):u.attr(t,e)})),s},S.Z=function(t,e){return t=t||[],t.__proto__=n.fn,t.selector=e||\"\",t},S.isZ=function(t){return t instanceof S.Z},S.init=function(e,i){var r;if(!e)return S.Z();if(\"string\"==typeof e)if(e=e.trim(),\""}],"posts":[{"title":"Nodejs 识别图片类型","slug":"2021/20200403","date":"2021-04-02T16:00:00.000Z","updated":"2022-03-02T10:19:40.534Z","comments":true,"path":"2021/04/03/2021/20200403/","link":"","permalink":"https://vlwq.github.io/2021/04/03/2021/20200403/","excerpt":"通过切文件名称后缀来获得图片格式的方式是不准确的，因为文件后缀是可以被强行更改的，这样一个.gif 图片也可以被保存成.jpg, 那么在 Node 上我们如何做文件类型的校验呢 ##通过文件头标识判断图片格式其实很简单，每个图片文件都有文件头标识，各种格式的图片的文件头标识都是不一样，所以可以通过判断文件头的标识来识别图片格式。 通过在网上找资料，汇总了如下的 图片文件头标识: 1234567891011121.JPEG/JPG - 文件头标识 (2 bytes): ff, d8 文件结束标识 (2 bytes): ff, d92.TGA - 未压缩的前 5 字节 00 00 02 00 00 - RLE 压缩的前 5 字节 00 00 10 00 003.PNG - 文件头标识 (8 bytes) 89 50 4E 47 0D 0A 1A 0A4.GIF - 文件头标识 (6 bytes) 47 49 46 38 39(37) 615.BMP - 文件头标识 (2 bytes) 42 4D B M6.PCX - 文件头标识 (1 bytes) 0A7.TIFF - 文件头标识 (2 bytes) 4D 4D 或 49 498.ICO - 文件头标识 (8 bytes) 00 00 01 00 01 00 20 209.CUR - 文件头标识 (8 bytes) 00 00 02 00 01 00 20 2010.IFF - 文件头标识 (4 bytes) 46 4F 52 4D11.ANI - 文件头标识 (4 bytes) 52 49 46 46知识点: 1 字节(bytes) = 8 bits,上面的数字均为 16 进制也就占 4bits 空间,每两个 16 进制数字占一字节","text":"通过切文件名称后缀来获得图片格式的方式是不准确的，因为文件后缀是可以被强行更改的，这样一个.gif 图片也可以被保存成.jpg, 那么在 Node 上我们如何做文件类型的校验呢 ##通过文件头标识判断图片格式其实很简单，每个图片文件都有文件头标识，各种格式的图片的文件头标识都是不一样，所以可以通过判断文件头的标识来识别图片格式。 通过在网上找资料，汇总了如下的 图片文件头标识: 1234567891011121.JPEG/JPG - 文件头标识 (2 bytes): ff, d8 文件结束标识 (2 bytes): ff, d92.TGA - 未压缩的前 5 字节 00 00 02 00 00 - RLE 压缩的前 5 字节 00 00 10 00 003.PNG - 文件头标识 (8 bytes) 89 50 4E 47 0D 0A 1A 0A4.GIF - 文件头标识 (6 bytes) 47 49 46 38 39(37) 615.BMP - 文件头标识 (2 bytes) 42 4D B M6.PCX - 文件头标识 (1 bytes) 0A7.TIFF - 文件头标识 (2 bytes) 4D 4D 或 49 498.ICO - 文件头标识 (8 bytes) 00 00 01 00 01 00 20 209.CUR - 文件头标识 (8 bytes) 00 00 02 00 01 00 20 2010.IFF - 文件头标识 (4 bytes) 46 4F 52 4D11.ANI - 文件头标识 (4 bytes) 52 49 46 46知识点: 1 字节(bytes) = 8 bits,上面的数字均为 16 进制也就占 4bits 空间,每两个 16 进制数字占一字节 ##如何判断通过将图片资源的二进制流与该标识做比对，即可判断图片格式。 因为实现逻辑非常简单，具体的实现逻辑看代码和注释就就好，在这里贡献出来给大家参考，方便大家开发使用。 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950function getImageSuffix(fileBuffer) &#123; // 将上文提到的 文件标识头 按 字节 整理到数组中 const imageBufferHeaders = [ &#123; bufBegin: [0xff, 0xd8], bufEnd: [0xff, 0xd9], suffix: &#x27;.jpg&#x27; &#125;, &#123; bufBegin: [0x00, 0x00, 0x02, 0x00, 0x00], suffix: &#x27;.tga&#x27; &#125;, &#123; bufBegin: [0x00, 0x00, 0x10, 0x00, 0x00], suffix: &#x27;.rle&#x27; &#125;, &#123; bufBegin: [0x89, 0x50, 0x4e, 0x47, 0x0d, 0x0a, 0x1a, 0x0a], suffix: &#x27;.png&#x27; &#125;, &#123; bufBegin: [0x47, 0x49, 0x46, 0x38, 0x39, 0x61], suffix: &#x27;.gif&#x27; &#125;, &#123; bufBegin: [0x47, 0x49, 0x46, 0x38, 0x37, 0x61], suffix: &#x27;.gif&#x27; &#125;, &#123; bufBegin: [0x42, 0x4d], suffix: &#x27;.bmp&#x27; &#125;, &#123; bufBegin: [0x0a], suffix: &#x27;.pcx&#x27; &#125;, &#123; bufBegin: [0x49, 0x49], suffix: &#x27;.tif&#x27; &#125;, &#123; bufBegin: [0x4d, 0x4d], suffix: &#x27;.tif&#x27; &#125;, &#123; bufBegin: [0x00, 0x00, 0x01, 0x00, 0x01, 0x00, 0x20, 0x20], suffix: &#x27;.ico&#x27; &#125;, &#123; bufBegin: [0x00, 0x00, 0x02, 0x00, 0x01, 0x00, 0x20, 0x20], suffix: &#x27;.cur&#x27; &#125;, &#123; bufBegin: [0x46, 0x4f, 0x52, 0x4d], suffix: &#x27;.iff&#x27; &#125;, &#123; bufBegin: [0x52, 0x49, 0x46, 0x46], suffix: &#x27;.ani&#x27; &#125; ] for (const imageBufferHeader of imageBufferHeaders) &#123; let isEqual // 判断标识头前缀 if (imageBufferHeader.bufBegin) &#123; const buf = Buffer.from(imageBufferHeader.bufBegin) isEqual = buf.equals( //使用 buffer.slice 方法 对 buffer 以字节为单位切割 fileBuffer.slice(0, imageBufferHeader.bufBegin.length) ) &#125; // 判断标识头后缀 if (isEqual &amp;&amp; imageBufferHeader.bufEnd) &#123; const buf = Buffer.from(imageBufferHeader.bufEnd) isEqual = buf.equals(fileBuffer.slice(-imageBufferHeader.bufEnd.length)) &#125; if (isEqual) &#123; return imageBufferHeader.suffix &#125; &#125; // 未能识别到该文件类型 return &#x27;&#x27;&#125;","categories":[],"tags":[{"name":"node","slug":"node","permalink":"https://vlwq.github.io/tags/node/"}]},{"title":"Random alpha-numeric string in JavaScript","slug":"2020/20200606","date":"2020-06-05T16:00:00.000Z","updated":"2022-03-02T09:59:01.238Z","comments":true,"path":"2020/06/06/2020/20200606/","link":"","permalink":"https://vlwq.github.io/2020/06/06/2020/20200606/","excerpt":"I just came across this as a really nice and elegant solution: 1Math.random().toString(36).slice(2) Notes on this implementation:","text":"I just came across this as a really nice and elegant solution: 1Math.random().toString(36).slice(2) Notes on this implementation: This will produce a string anywhere between zero and 12 characters long, usually 11 characters, due to the fact that floating point stringification removes trailing zeros.It won’t generate capital letters, only lower-case and numbers.Because the randomness comes from Math.random(), the output may be predictable and therefore not necessarily unique.Even assuming an ideal implementation, the output has at most 52 bits of entropy, which means you can expect a duplicate after around 70M strings generated.","categories":[],"tags":[{"name":"node","slug":"node","permalink":"https://vlwq.github.io/tags/node/"}]},{"title":"Docker: 上传镜像至私有仓库","slug":"2020/20200512","date":"2020-05-11T16:00:00.000Z","updated":"2022-03-02T10:09:15.388Z","comments":true,"path":"2020/05/12/2020/20200512/","link":"","permalink":"https://vlwq.github.io/2020/05/12/2020/20200512/","excerpt":"上传镜像要上传镜像到私有仓库，需要在镜像的 tag 上加入仓库地址： 1docker tag express-app 111.111.111.111:5000/sunhengzhe/express-app:v1 为了不与其他镜像冲突，可以加入命名空间如 sunhengzhe，另外最好给镜像打上 tag 如 v1。 注意仓库地址没有加协议部分，docker 默认的安全策略需要仓库是支持 https 的，如果服务器只能使用 http 传输，那么直接上传会失败，需要在 docker 客户端的配置文件中进行声明。","text":"上传镜像要上传镜像到私有仓库，需要在镜像的 tag 上加入仓库地址： 1docker tag express-app 111.111.111.111:5000/sunhengzhe/express-app:v1 为了不与其他镜像冲突，可以加入命名空间如 sunhengzhe，另外最好给镜像打上 tag 如 v1。 注意仓库地址没有加协议部分，docker 默认的安全策略需要仓库是支持 https 的，如果服务器只能使用 http 传输，那么直接上传会失败，需要在 docker 客户端的配置文件中进行声明。 推送镜像打完 tag 后使用 push 命令推送即可： 1docker push 111.111.111.111:5000/sunhengzhe/express-app:v1","categories":[],"tags":[{"name":"docker","slug":"docker","permalink":"https://vlwq.github.io/tags/docker/"}]},{"title":"删除 Docker 镜像","slug":"2020/20200511","date":"2020-05-10T16:00:00.000Z","updated":"2022-03-02T10:09:09.410Z","comments":true,"path":"2020/05/11/2020/20200511/","link":"","permalink":"https://vlwq.github.io/2020/05/11/2020/20200511/","excerpt":"Docker rmidocker rmi 通过镜像的 ID 删除镜像。 要删除镜像，首先需要列出所有镜像以获取镜像的 ID，镜像的名称和其他详细信息。 运行简单的命令 docker images -a 或 docker images。之后，明确要删除哪个镜像，然后执行简单命令 docker rmi 。然后，列出所有镜像并检查，可以确认镜像是否已删除。 一次删除多张镜像当你要一次删除多张镜像时，可以使用一种方法。首先只需列出镜像即可获取镜像的 ID，然后执行简单的命令： docker rmi … 列出镜像的 ID，每个 ID 之间留一个空格。 一次删除所有镜像要删除所有镜像，有一个简单的命令可以做到： docker rmi $(docker images -q)。 在上面的命令中，有两个命令，第一个在 $() 中执行的命令是 shell 语法，返回以该执行的结果。然后，-q- 是一个选项，用于返回唯一的 ID。$() 返回镜像 ID 的结果，然后 docker rmi 删除所有这些镜像。","text":"Docker rmidocker rmi 通过镜像的 ID 删除镜像。 要删除镜像，首先需要列出所有镜像以获取镜像的 ID，镜像的名称和其他详细信息。 运行简单的命令 docker images -a 或 docker images。之后，明确要删除哪个镜像，然后执行简单命令 docker rmi 。然后，列出所有镜像并检查，可以确认镜像是否已删除。 一次删除多张镜像当你要一次删除多张镜像时，可以使用一种方法。首先只需列出镜像即可获取镜像的 ID，然后执行简单的命令： docker rmi … 列出镜像的 ID，每个 ID 之间留一个空格。 一次删除所有镜像要删除所有镜像，有一个简单的命令可以做到： docker rmi $(docker images -q)。 在上面的命令中，有两个命令，第一个在 $() 中执行的命令是 shell 语法，返回以该执行的结果。然后，-q- 是一个选项，用于返回唯一的 ID。$() 返回镜像 ID 的结果，然后 docker rmi 删除所有这些镜像。 Docker rmdocker rm 根据容器的名称或者 ID 来删除容器。 如果 Docker 容器正在运行，你在删除它们之前需要先停止运行。 停止所有容器运行： docker stop $(docker ps -a -q) 删除所有停止运行的容器： docker rm $(docker ps -a -q) 删除多个容器你可以通过向命令传递要删除的容器列表来停止和删除多个容器。shell 语法 $() 返回括号中执行的任何结果。因此，你可以在其中创建容器列表，以传递给 stop 和 rm 命令。 docker ps -a -q 分解docker ps 列出容器。-a 这个选项用于列出所有容器，包括停止运行的。如果没有这个选项，则默认只列出在运行的容器。-q 这个选项列出容器的数字 ID，而不是容器的所有信息。","categories":[],"tags":[{"name":"docker","slug":"docker","permalink":"https://vlwq.github.io/tags/docker/"}]},{"title":"How to squash all commits on branch","slug":"2020/20200510","date":"2020-05-09T16:00:00.000Z","updated":"2022-03-02T10:18:45.583Z","comments":true,"path":"2020/05/10/2020/20200510/","link":"","permalink":"https://vlwq.github.io/2020/05/10/2020/20200510/","excerpt":"Another way to squash all your commits is to reset the index to master: 1234git checkout yourBranchgit reset $(git merge-base master $(git branch --show-current))git add -Agit commit -m &quot;one commit on yourBranch&quot; This isn’t perfect as it implies you know from which branch “yourBranch” is coming from.Note: finding that origin branch isn’t easy/possible with Git (the visual way is often the easiest, as seen here). Note: git branch --show-current has been introduced with Git 2.22 (Q1 20219). EDIT: you will need to use git push --force Karlotcha Hoa adds in the comments: For the reset, you can do 1git reset $(git merge-base master $(git rev-parse --abbrev-ref HEAD)) [That] automatically uses the branch you are currently on.And if you use that, you can also use an alias, as the command doesn’t rely on the branch name. sschoof adds in the comments: Since my default branch is called main and my search had multi times brought me here:To copy it for my next time 1git reset $(git merge-base main $(git rev-parse --abbrev-ref HEAD))","text":"Another way to squash all your commits is to reset the index to master: 1234git checkout yourBranchgit reset $(git merge-base master $(git branch --show-current))git add -Agit commit -m &quot;one commit on yourBranch&quot; This isn’t perfect as it implies you know from which branch “yourBranch” is coming from.Note: finding that origin branch isn’t easy/possible with Git (the visual way is often the easiest, as seen here). Note: git branch --show-current has been introduced with Git 2.22 (Q1 20219). EDIT: you will need to use git push --force Karlotcha Hoa adds in the comments: For the reset, you can do 1git reset $(git merge-base master $(git rev-parse --abbrev-ref HEAD)) [That] automatically uses the branch you are currently on.And if you use that, you can also use an alias, as the command doesn’t rely on the branch name. sschoof adds in the comments: Since my default branch is called main and my search had multi times brought me here:To copy it for my next time 1git reset $(git merge-base main $(git rev-parse --abbrev-ref HEAD))","categories":[],"tags":[{"name":"node","slug":"node","permalink":"https://vlwq.github.io/tags/node/"}]},{"title":"lodash array to object","slug":"2018/20180301","date":"2018-02-28T16:00:00.000Z","updated":"2022-03-02T06:53:06.996Z","comments":true,"path":"2018/03/01/2018/20180301/","link":"","permalink":"https://vlwq.github.io/2018/03/01/2018/20180301/","excerpt":"","text":"123456789101112131415const mergeUnionByKey = function(data,key,templete=&#123;&#125;) &#123; const datasets = data const datasetsIndex = _.mapValues(datasets, dataset =&gt; _.keyBy(dataset, key)) const uniqKeys = _.chain(datasets).flatten().map(key).uniq().value() const c = _.chain(uniqKeys).map(val =&gt; &#123; const data = JSON.parse(JSON.stringify(templete)) _.each(datasetsIndex, dataset =&gt;&#123; _.merge(data, dataset[val]) &#125;) return data &#125;).filter(key).value() return c&#125;","categories":[],"tags":[{"name":"node","slug":"node","permalink":"https://vlwq.github.io/tags/node/"}]},{"title":"docker install","slug":"2018/20180120","date":"2018-01-19T16:00:00.000Z","updated":"2018-03-03T04:56:51.215Z","comments":true,"path":"2018/01/20/2018/20180120/","link":"","permalink":"https://vlwq.github.io/2018/01/20/2018/20180120/","excerpt":"参照官方https://docs.docker.com/install/linux/docker-ce/ubuntu/ ce是社区版 先切换ubuntu内镜像https://mirrors.ustc.edu.cn/repogen/","text":"参照官方https://docs.docker.com/install/linux/docker-ce/ubuntu/ ce是社区版 先切换ubuntu内镜像https://mirrors.ustc.edu.cn/repogen/ 1、移除 1$ sudo apt-get remove docker docker-engine docker.io 2、(可选)安装linux-image-extra-*包，以便docker使用aufs存储驱动 12345$ sudo apt-get update$ sudo apt-get install \\ linux-image-extra-$(uname -r) \\ linux-image-extra-virtual 3、支持https? 12345$ sudo apt-get install \\ apt-transport-https \\ ca-certificates \\ curl \\ software-properties-common 4、add Docker的官方GPG key 12$ curl -fsSL https://download.docker.com/linux/ubuntu/gpg | sudo apt-key add -$ sudo apt-key fingerprint 0EBFCD88 5、配置库 1234$ sudo add-apt-repository \\ &quot;deb [arch=amd64] https://download.docker.com/linux/ubuntu \\ $(lsb_release -cs) \\ stable&quot; 6、install 12$ sudo apt-get update$ sudo apt-get install docker-ce 7、test 1$ sudo docker run hello-world 如果运行成功则网络无问题，若有，则需要配置docker代理,配置完重新运行“$ sudo docker run hello-world”进行验证 123456789101112131.默认情况下这个配置文件夹并不存在，我们要创建它$ mkdir -p /etc/systemd/system/docker.service.d2.创建一个文件 /etc/systemd/system/docker.service.d/http-proxy.conf 文件内容如下：[Service]Environment=&quot;HTTP_PROXY=http://proxy_ip:proxy_port/&quot;Environment=&quot;HTTPS_PROXY=http://proxy_ip:proxy_port/&quot;Environment=&quot;NO_PROXY=localhost,127.0.0.1,localaddress,.localdomain.com&quot;3.刷新systemd配置:$ sudo systemctl daemon-reload4.用系统命令验证环境变量加上去没:$ systemctl show --property=Environment docker5.重启docker$ sudo systemctl restart docker 8.安装docker-compose 1$ sudo apt-get install docker-compose","categories":[],"tags":[{"name":"node","slug":"node","permalink":"https://vlwq.github.io/tags/node/"}]},{"title":"tcp3次握手协议理解","slug":"2018/20180101","date":"2017-12-31T16:00:00.000Z","updated":"2018-03-03T04:47:27.037Z","comments":true,"path":"2018/01/01/2018/20180101/","link":"","permalink":"https://vlwq.github.io/2018/01/01/2018/20180101/","excerpt":"","text":"简单说，让双方都证实对方能发收。知道对方能收是因为收到对方的因为收到而发的回应。具体：1：A发，B收， B知道A能发2：B发，A收， A知道B能发收3：A发，B收， B知道A能收","categories":[],"tags":[{"name":"node","slug":"node","permalink":"https://vlwq.github.io/tags/node/"}]},{"title":"lodash合并对象数组","slug":"2017/20171226","date":"2017-12-25T16:00:00.000Z","updated":"2017-12-26T15:08:48.492Z","comments":true,"path":"2017/12/26/2017/20171226/","link":"","permalink":"https://vlwq.github.io/2017/12/26/2017/20171226/","excerpt":"因pmo查询做得辣鸡，需要多次查询合成结果集，查询经常遇到对象数组合并问题(key不存在也要赋值)如 123456789101112131415const test1 = [ &#123; name: &#x27;zhanghong&#x27;, age: 32, &#125;, &#123; name: &#x27;wanghong&#x27;, age: 20, size: 6 &#125;,]const test2 = [ &#123; name: &#x27;zhanghong&#x27;, gender: &#x27;male&#x27;&#125;, &#123; name: &#x27;wanghong&#x27;, gender: &#x27;female&#x27;&#125;,]期望最后结果集合const test3 = [ &#123; name: &#x27;zhanghong&#x27;,gender: &#x27;male&#x27;, age: 32, size: 6, &#125;, &#123; name: &#x27;wanghong&#x27;, gender: &#x27;female&#x27; ,age: 20, size: 0 &#125;,]","text":"因pmo查询做得辣鸡，需要多次查询合成结果集，查询经常遇到对象数组合并问题(key不存在也要赋值)如 123456789101112131415const test1 = [ &#123; name: &#x27;zhanghong&#x27;, age: 32, &#125;, &#123; name: &#x27;wanghong&#x27;, age: 20, size: 6 &#125;,]const test2 = [ &#123; name: &#x27;zhanghong&#x27;, gender: &#x27;male&#x27;&#125;, &#123; name: &#x27;wanghong&#x27;, gender: &#x27;female&#x27;&#125;,]期望最后结果集合const test3 = [ &#123; name: &#x27;zhanghong&#x27;,gender: &#x27;male&#x27;, age: 32, size: 6, &#125;, &#123; name: &#x27;wanghong&#x27;, gender: &#x27;female&#x27; ,age: 20, size: 0 &#125;,] 参照 https://stackoverflow.com/questions/29320817/lodash-union-of-arrays-of-objects 暂时解决，待优化代码 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566const test1 = [ &#123; name: &#x27;zhanghong&#x27;, age: 32, money: 0, size: 12, &#125;, &#123; name: &#x27;wanghong&#x27;, age: 20, size: 6 &#125;, &#123; name: &#x27;jinhong&#x27;, age: 16, height: 172 &#125;,]const test2 = [ &#123; name: &#x27;zhanghong&#x27;, gender: &#x27;male&#x27;, age: 14 &#125;, &#123; name: &#x27;wanghong&#x27;, gender: &#x27;female&#x27;, age: 33 &#125;, &#123; name: &#x27;lihong&#x27;, gender: &#x27;female&#x27;, age: 33 &#125;,]const test3 = [ &#123; name: &#x27;meinv&#x27; &#125;,]const test4 = [ &#123; name: &#x27;aaa&#x27; &#125;,]const test5 = [ &#123; name: &#x27;zhanghong&#x27;, age: &#x27;wtf&#x27; &#125;,]const result = mergeUnionByKey(test1, test2, test3, test4, [], test5, &#x27;name&#x27;, &#x27;override&#x27;)function mergeUnionByKey(...args) &#123; const config = _.chain(args) .filter(_.isString) .value() const key = _.get(config, &#x27;[0]&#x27;) const strategy = _.get(config, &#x27;[1]&#x27;) === &#x27;override&#x27; ? _.merge : _.defaultsDeep if (!_.isString(key)) throw new Error(&#x27;missing key&#x27;) const datasets = _.chain(args) .reject(_.isEmpty) .filter(_.isArray) .value() const datasetsIndex = _.mapValues(datasets, dataset =&gt; _.keyBy(dataset, key)) const uniqKeys = _.chain(datasets) .flatten() .map(key) .uniq() .value() return _.chain(uniqKeys) .map(val =&gt; &#123; const data = &#123;&#125; _.each(datasetsIndex, dataset =&gt; strategy(data, dataset[val])) return data &#125;) .filter(key) .value()&#125;console.log(JSON.stringify(result, null, 4))","categories":[],"tags":[{"name":"node","slug":"node","permalink":"https://vlwq.github.io/tags/node/"}]},{"title":"sequelize-auto对照数据库自动生成相应的models","slug":"2017/20171225","date":"2017-12-24T16:00:00.000Z","updated":"2017-12-26T14:59:57.180Z","comments":true,"path":"2017/12/25/2017/20171225/","link":"","permalink":"https://vlwq.github.io/2017/12/25/2017/20171225/","excerpt":"12345678910111213141516171819202122Installnpm install -g sequelize-autoPrerequisitesYou will need to install the correct dialect binding globally before using sequelize-auto.Example for MySQL/MariaDBnpm install -g mysqlExample for Postgresnpm install -g pg pg-hstoreExample for Sqlite3npm install -g sqliteExample for MSSQLnpm install -g mssql","text":"12345678910111213141516171819202122Installnpm install -g sequelize-autoPrerequisitesYou will need to install the correct dialect binding globally before using sequelize-auto.Example for MySQL/MariaDBnpm install -g mysqlExample for Postgresnpm install -g pg pg-hstoreExample for Sqlite3npm install -g sqliteExample for MSSQLnpm install -g mssql 参数见npm文档 https://www.npmjs.com/package/sequelize-auto","categories":[],"tags":[{"name":"node","slug":"node","permalink":"https://vlwq.github.io/tags/node/"}]},{"title":"git服务端强制覆盖本地","slug":"2017/20171101","date":"2017-10-31T16:00:00.000Z","updated":"2017-11-27T06:45:14.323Z","comments":true,"path":"2017/11/01/2017/20171101/","link":"","permalink":"https://vlwq.github.io/2017/11/01/2017/20171101/","excerpt":"12git reset --hard origin/master git pull","text":"12git reset --hard origin/master git pull 版本管理软件有时boom…. 其他常用命令备用： 1234567891011121314151617181920212223# 显示当前分支的版本历史$ git log# 下载远程仓库的所有变动$ git fetch [remote]# 取回远程仓库的变化，并与本地分支合并$ git pull [remote] [branch]# 强行推送当前分支到远程仓库，即使有冲突$ git push [remote] --force# 暂时将未提交的变化移除，稍后再移入$ git stash$ git stash pop# 新建一个commit，用来撤销指定commit# 后者的所有变化都将被前者抵消，并且应用到当前分支$ git revert [commit]","categories":[],"tags":[{"name":"node","slug":"node","permalink":"https://vlwq.github.io/tags/node/"}]},{"title":"实现promise(转自bananas)","slug":"2017/20171002","date":"2017-10-01T16:00:00.000Z","updated":"2017-11-27T06:38:30.498Z","comments":true,"path":"2017/10/02/2017/20171002/","link":"","permalink":"https://vlwq.github.io/2017/10/02/2017/20171002/","excerpt":"promise 是为了解决回调地狱的问题。主要有以下几个方法 Promise.prototype.then Promise.prototype.catch Promise.all Promise.race","text":"promise 是为了解决回调地狱的问题。主要有以下几个方法 Promise.prototype.then Promise.prototype.catch Promise.all Promise.race 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135const log = console.log.bind(console)class BananasPromise &#123; constructor(func) &#123; if(typeof func !== &#x27;function&#x27;) &#123; throw new Error(func, &#x27;is no a function&#x27;) &#125; this.func = func this.state = &#x27;init&#x27; const resolve = this.resolve.bind(this) const reject = this.reject.bind(this) const r = () =&gt; &#123; func(resolve, reject) return this &#125; return r &#125; _efunc() &#123; &#125; then(done) &#123; this.done = done || this._efunc if(this.state === &#x27;done&#x27;) &#123; done(this.args) &#125; return this &#125; catch(fail) &#123; this.fail = fail || this._efunc if(this.state === &#x27;fail&#x27;) &#123; fail(this.err) &#125; &#125; resolve(args=&#x27;&#x27;) &#123; this.state = &#x27;done&#x27; this.args = args this.done &amp;&amp; this.then(this.done) &#125; reject(args=&#x27;&#x27;) &#123; this.state = &#x27;fail&#x27; this.err = args this.catch &amp;&amp; this.catch(this.fail) &#125; static _init() &#123; const cls = this cls.state = &#x27;init&#x27; cls.done = () =&gt; &#123;&#125; cls.fail = () =&gt; &#123;&#125; cls._resule = [] cls._err = null &#125; static all(array) &#123; const cls = this let len = array.length cls._init() array.forEach((i, index) =&gt; &#123; if(cls._err !== null) &#123; return &#125; i().then((a) =&gt; &#123; if(cls._err !== null) &#123; return &#125; len-- cls._resule[index] = a if(len === 0) &#123; cls.state = &#x27;done&#x27; cls.then() &#125; &#125;).catch((err) =&gt; &#123; if(cls._err !== null) &#123; return &#125; cls.state = &#x27;fail&#x27; cls._err = err cls.catch() &#125;) &#125;) return this &#125; static then(done) &#123; const cls = this if(this.state === &#x27;done&#x27;) &#123; cls.done(cls._resule) &#125; else if(this.state === &#x27;init&#x27;) &#123; cls.done = done || cls.done &#125; return this &#125; static catch(fail) &#123; const cls = this if(cls.state === &#x27;fail&#x27;) &#123; cls.fail(cls._err) &#125; else if(cls.state === &#x27;init&#x27;) &#123; cls.fail = fail || cls.fail &#125; &#125; static race(array) &#123; const cls = this cls._init() array.forEach((item) =&gt; &#123; if(cls.state === &#x27;done&#x27; || cls.state === &#x27;fail&#x27;) &#123; return &#125; item().then((data) =&gt; &#123; if(cls.state === &#x27;done&#x27; || cls.state === &#x27;fail&#x27;) &#123; return &#125; cls.state = &#x27;done&#x27; cls._resule = data cls.then() &#125;).catch((err) =&gt; &#123; if(cls.state === &#x27;done&#x27; || cls.state === &#x27;fail&#x27;) &#123; return &#125; cls.state = &#x27;fail&#x27; cls._err = err cls.catch() &#125;) &#125;) return cls &#125;&#125;","categories":[],"tags":[{"name":"node","slug":"node","permalink":"https://vlwq.github.io/tags/node/"}]},{"title":"Andrew Parse 2","slug":"2017/20170808","date":"2017-08-07T16:00:00.000Z","updated":"2017-08-27T05:57:56.304Z","comments":true,"path":"2017/08/08/2017/20170808/","link":"","permalink":"https://vlwq.github.io/2017/08/08/2017/20170808/","excerpt":"Andrew Parse 2","text":"Andrew Parse 2 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172173174175176177178179180/** * Created by Andrew on 2017/7/30 0030. */const log = console.log.bind(console)//处理key,value,去掉&quot;&quot;const parsedElement = (e) =&gt; &#123; if(e[0] === &#x27;\\&quot;&#x27; || e[0] === &quot;\\&#x27;&quot;) &#123; return e.slice(1, e.length - 1) &#125;else &#123; return Number(e) &#125;&#125;//解析name: &#x27;gua&#x27;, 一个字符值的情况const parsedOne = (s) =&gt; &#123; log(&#x27;debug parsedOne&#x27;,s) const obj = &#123;&#125; const arr = s.split(&#x27;,&#x27;) arr.forEach(e=&gt;&#123; const t = e.split(&quot;:&quot;) const k = parsedElement(t[0]) const v = parsedElement(t[1]) obj[k] = v &#125;) return obj&#125;/** * [[[[[]]]]]]] * 处理&#123;&#123;&#123;&#123;&#125;&#125;&#125;&#125;,取到最后一个&#125; */const findElementEnd = (str, start ,isObj = true) =&gt; &#123; let a = &#x27;&#x27; let b= &#x27;&#x27; if(isObj)&#123; a = &#x27;&#123;&#x27; b = &#x27;&#125;&#x27; &#125;else&#123; a = &#x27;[&#x27; b = &#x27;]&#x27; &#125; const stack = [a] let i = start + 1 while(i &lt; str.length &amp;&amp; stack.length &gt; 0) &#123; if(str[i] === a) &#123; stack.push(a) &#125;else if(str[i] === b) &#123; let index = stack.length - 1 stack.splice(index, 1) &#125;else &#123; // &#125; i++ &#125; return i&#125;const dealWithArray = (s ,arr=[])=&gt;&#123; //50,&quot;20&quot;,[1,[3,4],2],[55,66] const index = s.indexOf(&#x27;[&#x27;) log(&#x27;debug 6666----: &#x27;, s ,index) if( index === -1)&#123; const a = s.split(&#x27;,&#x27;).map(e =&gt;parsedElement(e)) arr.push.apply(arr,a) &#125;else &#123; //处理前面半段,不能为0 if(index !== 0)&#123; let newStr = s.slice(0,index - 1) let a = newStr.split(&#x27;,&#x27;).map(e =&gt;parsedElement(e)) arr.push.apply(arr,a) &#125; //递归(中间) const last = findElementEnd(s , index , false) let newS = s.slice(index + 1 ,last - 1) let temp = [] let b = dealWithArray(newS ,[]) //log(&#x27;77???---&#x27;,newS, b) //if(newS.indexOf(&#x27;[&#x27;) === -1 &amp;&amp; newS.indexOf(&#x27;]&#x27;) === -1)&#123; // arr.push.apply(arr,b) //&#125;else &#123; arr.push(b) // &#125; //arr.push(b) //处理后面半段 log(&#x27;==============================&#x27;,arr) log(&#x27;===============================\\n&#x27;) //继续递归 let newStr = s.slice(last + 1) if(newStr.length &gt; 0)&#123; log(&#x27;test------&#x27;,newStr) let c = dealWithArray(newStr ,[]) arr.push.apply(arr ,c) &#125; &#125; return arr&#125;const myParse =(s ,obj=&#123;&#125;)=&gt;&#123; if(s[0] === &#x27;&#123;&#x27;)&#123; s = s.slice(1, s.length - 1) &#125; //复杂情形 // &quot;name&quot;:&quot;gua&quot;,&quot;todo&quot;:&#123;&quot;play&quot;:&quot;0/1&quot;&#125; let index = s.indexOf(&#x27;:&#x27;) const str = s[index + 1] log(&#x27;debug digui &#x27;,s, &#x27;\\n&#x27;) if(str === &#x27;&#123;&#x27;)&#123; log(&#x27;-----enter object parse-----------&#x27;) let key = s.split(&#x27;:&#123;&#x27;)[0] //截取s key = parsedElement(key) // 找到最后一个&#125; const last = findElementEnd(s , index) const newStr = s.slice(index +1 , last) let o = &#123;&#125; o = myParse(newStr , o) obj[`$&#123;key&#125;`] = o log(&#x27;debug newStr : &#x27;,newStr) log(&#x27;debug o : &#x27;,o) &#125;else if(str === &#x27;[&#x27;)&#123; log(&#x27;-----enter array parse-----------&#x27;) //&quot;age&quot;:[50,20,30] let key = s.split(&#x27;:[&#x27;)[0] //截取s key = parsedElement(key) // 找到最后一个] const last = findElementEnd(s , index + 1 ,false) const newStr = s.slice(index + 1 , last) const r = dealWithArray(newStr) log(&#x27;final:&#x27;, r[0]) log(&#x27;str: &#x27;, s.slice(last + 1)) obj[`$&#123;key&#125;`] = r[0] //继续递归 const l = s.slice(last + 1) if(l.length &gt; 0)&#123; //截取不为空串就继续 myParse(l,obj) &#125; //log(&#x27;test: &#x27;,test) &#125;else if (str !== &#x27;&#123;&#x27; &amp;&amp; str !== &#x27;[&#x27;)&#123; log(`----enter str parse--------$&#123;s&#125; \\n`) //取到&quot;name&quot;:&quot;gua&quot; const cell = s.split(&#x27;,&#x27;)[0] log(&#x27;cell &#x27;,s,&#x27;----&#x27;, cell) const o = parsedOne(cell) const k = Object.keys(o)[0] obj[`$&#123;k&#125;`] = o[k] //log(&#x27;obj: &#x27;,obj) //下一个元素 index = s.indexOf(&#x27;,&#x27;) if (index !== -1) &#123; s = s.slice(index + 1) obj = myParse(s, obj) &#125; &#125; return obj&#125;const testParser = () =&gt; &#123; const o = &#123; age: [50,&#x27;20&#x27;,[1,[3,4],[22,33],2] ,[55,66]], age3: [50,[77,88]], todo: &#123; &#x27;play&#x27;: &#x27;0/1&#x27;, &#x27;sports&#x27;: &#123; &#x27;gua&#x27;:&#123; &#x27;test&#x27;:222 &#125; &#125; &#125; &#125; const s = JSON.stringify(o) const obj = myParse(s) // log(&#x27;\\n\\nfinal result : &#x27;) log(&#x27;\\nJSON.parse result:&#x27;, s) log(`\\nAndrew&#x27;s JSON Parse : `, obj) log(`\\nAndrew&#x27;s JSON Parse TODO detail: \\n`, obj[&#x27;todo&#x27;])&#125;testParser()","categories":[],"tags":[{"name":"base","slug":"base","permalink":"https://vlwq.github.io/tags/base/"}]},{"title":"Andrew的Json.parse解析器","slug":"2017/20170729","date":"2017-07-29T02:36:00.000Z","updated":"2017-08-27T05:58:10.407Z","comments":true,"path":"2017/07/29/2017/20170729/","link":"","permalink":"https://vlwq.github.io/2017/07/29/2017/20170729/","excerpt":"//令人窒息的操作 Andrew的Json.parse解析器","text":"//令人窒息的操作 Andrew的Json.parse解析器 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169/** * Created by Andrew on 2017/7/30 0030. */const log = console.log.bind(console)//处理key,value,去掉&quot;&quot;const parsedElement = (e) =&gt; &#123; if (e[0] === &#x27;\\&quot;&#x27; || e[0] === &quot;\\&#x27;&quot;) &#123; return e.slice(1, e.length - 1) &#125; else &#123; return Number(e) &#125;&#125;//解析name: &#x27;gua&#x27;, 一个字符值的情况const parsedOne = (s) =&gt; &#123; log(&#x27;debug parsedOne&#x27;, s) const obj = &#123;&#125; const arr = s.split(&#x27;,&#x27;) arr.forEach(e =&gt; &#123; const t = e.split(&quot;:&quot;) const k = parsedElement(t[0]) const v = parsedElement(t[1]) obj[k] = v &#125;) return obj&#125;/** * [[[[[]]]]]]] * 处理&#123;&#123;&#123;&#123;&#125;&#125;&#125;&#125;,取到最后一个&#125;，默认i处理object ,数组需要传false */const findElementEnd = (str, start, isObj = true) =&gt; &#123; let a = &#x27;&#x27; let b = &#x27;&#x27; if (isObj) &#123; a = &#x27;&#123;&#x27; b = &#x27;&#125;&#x27; &#125; else &#123; a = &#x27;[&#x27; b = &#x27;]&#x27; &#125; const stack = [a] let i = start + 1 while (i &lt; str.length &amp;&amp; stack.length &gt; 0) &#123; if (str[i] === a) &#123; stack.push(a) &#125; else if (str[i] === b) &#123; let index = stack.length - 1 stack.splice(index, 1) &#125; else &#123; // &#125; i++ &#125; return i&#125;const dealWithArray = (s, arr = []) =&gt; &#123; //50,&quot;20&quot;,[1,[3,4],2],[55,66] const index = s.indexOf(&#x27;[&#x27;) log(&#x27;debug diguiguigi----: &#x27;, s) if (index === -1) &#123; const a = s.split(&#x27;,&#x27;).map(e =&gt; parsedElement(e)) arr.push.apply(arr, a) &#125; else &#123; //处理前面半段,不能为0 if (index !== 0) &#123; let newStr = s.slice(0, index - 1) let a = newStr.split(&#x27;,&#x27;).map(e =&gt; parsedElement(e)) arr.push.apply(arr, a) &#125; //递归(中间) const last = findElementEnd(s, index, false) let newS = s.slice(index + 1, last - 1) let temp = [] let b = dealWithArray(newS, []) arr.push(b) //处理后面半段 log(&#x27;===============================\\n&#x27;) //继续递归 let newStr = s.slice(last + 1) if (newStr.length &gt; 0) &#123; log(&#x27;test------&#x27;, newStr) let c = dealWithArray(newStr, []) arr.push.apply(arr, c) &#125; &#125; return arr&#125;const myParse = (s, obj = &#123;&#125;) =&gt; &#123; if (s[0] === &#x27;&#123;&#x27;) &#123; s = s.slice(1, s.length - 1) &#125; //复杂情形 // &quot;name&quot;:&quot;gua&quot;,&quot;todo&quot;:&#123;&quot;play&quot;:&quot;0/1&quot;&#125; let index = s.indexOf(&#x27;:&#x27;) const str = s[index + 1] log(&#x27;debug digui &#x27;, s, &#x27;\\n&#x27;) if (str === &#x27;&#123;&#x27;) &#123; log(&#x27;-----enter object parse-----------&#x27;) let key = s.split(&#x27;:&#123;&#x27;)[0] //截取s key = parsedElement(key) // 找到最后一个&#125; const last = findElementEnd(s, index) const newStr = s.slice(index + 2, last - 1) let o = &#123;&#125; o = myParse(newStr, o) obj[`$&#123;key&#125;`] = o log(&#x27;debug newStr : &#x27;, newStr) log(&#x27;debug o : &#x27;, o) &#125; else if (str !== &#x27;&#123;&#x27; &amp;&amp; str !== &#x27;[&#x27;) &#123; log(`----enter str parse--------$&#123;s&#125; \\n`) //取到&quot;name&quot;:&quot;gua&quot; const cell = s.split(&#x27;,&#x27;)[0] log(&#x27;cell &#x27;, s, &#x27;----&#x27;, cell) const o = parsedOne(cell) const k = Object.keys(o)[0] obj[`$&#123;k&#125;`] = o[k] //log(&#x27;obj: &#x27;,obj) //下一个元素 index = s.indexOf(&#x27;,&#x27;) if (index !== -1) &#123; s = s.slice(index + 1) obj = myParse(s, obj) &#125; &#125; else if (str === &#x27;[&#x27;) &#123; log(&#x27;-----enter array parse-----------&#x27;) //&quot;age&quot;:[50,20,30] let key = s.split(&#x27;:[&#x27;)[0] //截取s key = parsedElement(key) // 找到最后一个] const last = findElementEnd(s, index, false) const newStr = s.slice(index + 2, last - 1) // const r = dealWithArray(newStr) log(&#x27;final:&#x27;, r) //log(&#x27;debug arr: &#x27;,newStr) //Todo 有bug需要考虑后续字符s.slice(last + 1) obj[`$&#123;key&#125;`] = r &#125; return obj&#125;const testParser = () =&gt; &#123; const o = &#123; todo: &#123; &#x27;play&#x27;: &#x27;0/1&#x27;, &#x27;sports&#x27;: &#123; &#x27;gua&#x27;:&#123; &#x27;test&#x27;:222 &#125; &#125; &#125;, //name: &#x27;test&#x27;, //todo: 没完成：array单独运行没问题，和obj搭配有bug,需要update //age: [50,&#x27;20&#x27;,[1,[3,4],[22,33],2] ,[55,66]], &#125; const s = JSON.stringify(o) const obj = myParse(s) log(&#x27;\\n\\nfinal result : &#x27;) log(&#x27;\\nJSON.parse result:&#x27;, s) log(`\\nAndrew&#x27;s JSON Parse : `, obj) log(`\\nAndrew&#x27;s JSON Parse TODO 子类obj : `, obj[&#x27;todo&#x27;])&#125;testParser()","categories":[],"tags":[{"name":"base","slug":"base","permalink":"https://vlwq.github.io/tags/base/"}]},{"title":"同步/异步新认识","slug":"2017/20170720","date":"2017-07-20T02:36:00.000Z","updated":"2017-07-23T02:55:01.036Z","comments":true,"path":"2017/07/20/2017/20170720/","link":"","permalink":"https://vlwq.github.io/2017/07/20/2017/20170720/","excerpt":"//令人窒息的操作","text":"//令人窒息的操作 1234567891011121314151617181920212223242526272829303132333435var doExe = function (a, callback) &#123; setTimeout(function () &#123; console.log(a) if (callback) &#123; callback() &#125; &#125;, 100 * Math.random())&#125;;//async(async () =&gt; &#123; for (let i = 0; i &lt; 10; i++) &#123; await new Promise(resolve =&gt; doExe(i, resolve)); &#125;&#125;)();//不让用asynclet p = new Promise(res =&gt; doExe(0,res));for (let i = 1; i &lt; 10; i++) &#123; p = p.then(() =&gt; new Promise(res =&gt; doExe(i, res)));&#125;//es5var i = 0;var aTest = function()&#123; i &lt; 10 &amp;&amp; doExe(i++, aTest);&#125;aTest();//令人窒息的操作for(let t = 0; t &lt; 10; t++)&#123; Math.random = () =&gt; t; doExe(t);&#125;","categories":[],"tags":[{"name":"js","slug":"js","permalink":"https://vlwq.github.io/tags/js/"}]},{"title":"less命令","slug":"2017/20170718","date":"2017-07-18T02:36:00.000Z","updated":"2017-07-18T12:23:39.095Z","comments":true,"path":"2017/07/18/2017/20170718/","link":"","permalink":"https://vlwq.github.io/2017/07/18/2017/20170718/","excerpt":"less命令 与 more命令 非常类似，但less命令 可以更加随意地浏览文件，而且 less 在查看之前不会加载整个文件。相比较于more命令，很多人更喜欢使用 less命令。","text":"less命令 与 more命令 非常类似，但less命令 可以更加随意地浏览文件，而且 less 在查看之前不会加载整个文件。相比较于more命令，很多人更喜欢使用 less命令。 一、Linux less命令语法 less [参数] 文件less命令非常强大，在此只介绍几个常用的参数，更多参数使用man less来查看Linux帮助手册。-b &lt;缓冲区大小&gt; 设置缓冲区的大小-e 当文件显示结束后，自动离开-f 强迫打开特殊文件，例如外围设备代号、目录和二进制文件-g 只标志最后搜索的关键词-i 忽略搜索时的大小写-m 显示类似more命令的百分比-N 显示每行的行号-o &lt;文件名&gt; 将less 输出的内容在指定文件中保存起来-Q 不使用警告音-s 显示连续空行为一行-S 行过长时间将超出部分舍弃-x &lt;数字&gt; 将”tab”键显示为规定的数字空格/字符串：向下搜索”字符串”的功能?字符串：向上搜索”字符串”的功能n：重复前一个搜索（与 / 或 ? 有关）N：反向重复前一个搜索（与 / 或 ? 有关）b 向后翻一页d 向后翻半页h 显示帮助界面Q 退出less 命令u 向前滚动半页y 向前滚动一行空格键 滚动一行回车键 滚动一页[pagedown]： 向下翻动一页[pageup]： 向上翻动一页 二、Linux less命令使用实例 1）查看文件$less linuxdaxue.com-access_log120.26.216.168 - - [12/Jun/2016:03:09:16 +0800] “HEAD / HTTP/1.1” 200 -42.96.189.63 - - [12/Jun/2016:03:09:41 +0800] “HEAD / HTTP/1.1” 200 -123.56.138.37 - - [12/Jun/2016:03:12:52 +0800] “HEAD / HTTP/1.1” 200 -120.26.216.168 - - [12/Jun/2016:03:14:16 +0800] “HEAD / HTTP/1.1” 200 -42.96.189.63 - - [12/Jun/2016:03:14:41 +0800] “HEAD / HTTP/1.1” 200 -linuxdaxue.com-access_log2）一次查看多个文件#less linuxdaxue.com-access_log linuxdaxue.com-error_log120.26.216.168 - - [12/Jun/2016:03:09:16 +0800] “HEAD / HTTP/1.1” 200 -42.96.189.63 - - [12/Jun/2016:03:09:41 +0800] “HEAD / HTTP/1.1” 200 -123.56.138.37 - - [12/Jun/2016:03:12:52 +0800] “HEAD / HTTP/1.1” 200 -120.26.216.168 - - [12/Jun/2016:03:14:16 +0800] “HEAD / HTTP/1.1” 200 -42.96.189.63 - - [12/Jun/2016:03:14:41 +0800] “HEAD / HTTP/1.1” 200 -123.56.138.37 - - [12/Jun/2016:03:17:52 +0800] “HEAD / HTTP/1.1” 200 -linuxdaxue.com-access_log (file 1 of 2)说明：输入 ：n后，切换到linuxdaxue.com-error_log输入 ：p 后，切换到linuxdaxue.com-access_log 三、Linux less命令常用操作命令接下来给大家介绍一些在less命令比较常用的操作命令，希望大家能够熟练掌握。1）分屏导航 1234ctrl + F - 向前移动一屏ctrl + B - 向后移动一屏ctrl + D - 向前移动半屏ctrl + U - 向后移动半屏 2）单行导航 12j - 向前移动一行k - 向后移动一行 3）其它导航 12G - 移动到最后一行g - 移动到第一行 4）其它命令 1234v - 使用配置的编辑器编辑当前文件h - 显示 less 的帮助文档&amp;pattern - 仅显示匹配模式的行，而不是整个文件q / ZZ - 退出 less 命令 5）标记导航当使用 less 查看内容比较多的文件时，可以作一个标记，然后就能通过命令导航到标有特定标记的文本位置，方式如下所示：ma - 使用 a 标记文本的当前位置。‘a - 导航到标记 a 处好了有关Linux less命令的相关内容就先为大家介绍到这里，less命令非常强大，在此只是为大家做一个简单的介绍，更熟练的掌握还需要大家的多多练习才行。","categories":[],"tags":[{"name":"linux","slug":"linux","permalink":"https://vlwq.github.io/tags/linux/"}]},{"title":"mongodb查询","slug":"2017/20170715","date":"2017-07-15T02:36:00.000Z","updated":"2017-08-27T05:56:17.458Z","comments":true,"path":"2017/07/15/2017/20170715/","link":"","permalink":"https://vlwq.github.io/2017/07/15/2017/20170715/","excerpt":"分页当查询时同时使用sort,skip,limit，无论位置先后，最先执行顺序 sort再skip再limit。","text":"分页当查询时同时使用sort,skip,limit，无论位置先后，最先执行顺序 sort再skip再limit。 想要读取从 10 条记录后 100 条记录，相当于 sql 中limit (10,100)。 1db.getCollection(&#x27;user&#x27;).find.skip(10).limit(100) 以上实例在集合中跳过前面 10 条返回 100 条数据。skip 和 limit 结合就能实现分页。 补充说明：第一个 {} 放 where 条件，为空表示返回集合中所有文档。第二个 {} 指定那些列显示和不显示 （0表示不显示 1表示显示)。 1db.col.find(&#123;&#125;,&#123;&quot;title&quot;:1,_id:0&#125;).limit(2) 条件操作符|操作 |格式 |范例 |RDBMS中的类似语句|—-|——|—-|等于 |&#123;&lt;key&gt;:&lt;value&gt;&#125; |db.col.find({“by”:”guagua”}).pretty() |where by = ‘guagua’|小于 |&#123;&lt;key&gt;:&#123;$lt:&lt;value&gt;&#125;&#125; |db.col.find({“likes”:{$lt:50}}).pretty() |where likes &lt; 50|小于或等于 |&#123;&lt;key&gt;:&#123;$lte:&lt;value&gt;&#125;&#125; |db.col.find({“likes”:{$lte:50}}).pretty() |where likes &lt;= 50|大于 |&#123;&lt;key&gt;:&#123;$gt:&lt;value&gt;&#125;&#125; |db.col.find({“likes”:{$gt:50}}).pretty() |where likes &gt; 50|大于或等于 |&#123;&lt;key&gt;:&#123;$gte:&lt;value&gt;&#125;&#125; |db.col.find({“likes”:{$gte:50}}).pretty() |where likes &gt;= 50|不等于 |&#123;&lt;key&gt;:&#123;$ne:&lt;value&gt;&#125;&#125; |db.col.find({“likes”:{$ne:50}}).pretty() |where likes != 50 and12db.col.find(&#123;&quot;by&quot;:&quot;菜鸟教程&quot;, &quot;title&quot;:&quot;MongoDB 教程&quot;&#125;).pretty()以上实例中类似于 WHERE 语句：WHERE by=&#x27;菜鸟教程&#x27; AND title=&#x27;MongoDB 教程&#x27; or1234567db.col.find( &#123; $or: [ &#123;key1: value1&#125;, &#123;key2:value2&#125; ] &#125;).pretty() AND 和 OR 联合使用123以下实例演示了 AND 和 OR 联合使用，类似常规 SQL 语句为： &#x27;where likes&gt;50 AND (by = &#x27;菜鸟教程&#x27; OR title = &#x27;MongoDB 教程&#x27;)&#x27;db.col.find(&#123;&quot;likes&quot;: &#123;$gt:50&#125;, $or: [&#123;&quot;by&quot;: &quot;菜鸟教程&quot;&#125;,&#123;&quot;title&quot;: &quot;MongoDB 教程&quot;&#125;]&#125;).pretty() 大于等于小于12345678910MongoDB 使用 (&lt;) 和 (&gt;) 查询 - $lt 和 $gtdb.col.find(&#123;likes : &#123;$lt :200, $gt : 100&#125;&#125;)备注：$gt -------- greater than &gt;$gte --------- gt equal &gt;=$lt -------- less than &lt;$lte --------- lt equal &lt;=$ne ----------- not equal !=$eq -------- equal = MongoDB 排序sort()方法可以通过参数指定排序的字段，并使用 1 和 -1 来指定排序的方式，其中 1 为升序排列，而-1是用于降序排列。 12以下实例演示了 col 集合中的数据按字段 likes 的降序排列：db.col.find(&#123;&#125;,&#123;&quot;title&quot;:1,_id:0&#125;).sort(&#123;&quot;likes&quot;:-1&#125;) MongoDB中聚合(aggregate)主要用于处理数据(诸如统计平均值,求和等)，并返回计算后的数据结果。有点类似sql语句中的 count(*)。 123456789101112131415现在我们通过以上集合计算每个作者所写的文章数，使用aggregate()计算结果如下：&gt; db.mycol.aggregate([&#123;$group : &#123;_id : &quot;$by_user&quot;, num_tutorial : &#123;$sum : 1&#125;&#125;&#125;])&#123; &quot;result&quot; : [ &#123; &quot;_id&quot; : &quot;runoob.com&quot;, &quot;num_tutorial&quot; : 2 &#125;, &#123; &quot;_id&quot; : &quot;Neo4j&quot;, &quot;num_tutorial&quot; : 1 &#125; ], &quot;ok&quot; : 1&#125; |表达式 |描述 |实例|—-|——|$sum |计算总和。 |db.mycol.aggregate([{$group : {_id : “$by_user”, num_tutorial : {$sum : “$likes”}}}])|$avg |计算平均值 |db.mycol.aggregate([{$group : {_id : “$by_user”, num_tutorial : {$avg : “$likes”}}}])|$min |获取集合中所有文档对应值得最小值。|db.mycol.aggregate([{$group : {_id : “$by_user”, num_tutorial : {$min : “$likes”}}}])|$max |获取集合中所有文档对应值得最大值。|db.mycol.aggregate([{$group : {_id : “$by_user”, num_tutorial : {$max : “$likes”}}}])|$push |在结果文档中插入值到一个数组中。|db.mycol.aggregate([{$group : {_id : “$by_user”, url : {$push: “$url”}}}])|$addToSet |在结果文档中插入值到一个数组中，但不创建副本。| db.mycol.aggregate([{$group : {_id : “$by_user”, url : {$addToSet : “$url”}}}])|$first |根据资源文档的排序获取第一个文档数据。| db.mycol.aggregate([{$group : {_id : “$by_user”, first_url : {$first : “$url”}}}])|$last |根据资源文档的排序获取最后一个文档数据 |db.mycol.aggregate([{$group : {_id : “$by_user”, last_url : {$last : “$url”}}}]) 管道-聚合框架中常用的几个操作 $project：修改输入文档的结构。可以用来重命名、增加或删除域，也可以用于创建计算结果以及嵌套文档。 $match：用于过滤数据，只输出符合条件的文档。$match使用MongoDB的标准查询操作。 $limit：用来限制MongoDB聚合管道返回的文档数。 $skip：在聚合管道中跳过指定数量的文档，并返回余下的文档。 $unwind：将文档中的某一个数组类型字段拆分成多条，每条包含数组中的一个值。 $group：将集合中的文档分组，可用于统计结果。 $sort：将输入文档排序后输出。 $geoNear：输出接近某一地理位置的有序文档。 $project1234567这样的话结果中就只还有_id,tilte和author三个字段了，默认情况下_id字段是被包含的，填0。。1是显示，0是隐藏 db.getCollection(&#x27;user&#x27;).aggregate( &#123; $project : &#123; id : 1 , deleted : 1 , &#125;&#125; ); $match实例 $match用于获取id=0,username不等于guagua记录，然后将符合条件的记录送到下一阶段$group管道操作符进行处理。 1234db.getCollection(&#x27;user&#x27;).aggregate( [ &#123; $match : &#123; id : &#123; $eq : 0&#125; , username:&#123; $ne : &#x27;guagua&#x27; &#125; &#125; &#125;, &#123;$group : &#123;_id : &quot;$username&quot;, gua : &#123;$sum : &#x27;$updated_time&#x27;&#125;&#125;&#125; ] ); $skip实例12db.getCollection(&#x27;user&#x27;).aggregate(&#123;$skip : 2&#125;)经过$skip管道操作符处理后，前2个文档被&quot;过滤&quot;掉 在后台创建索引：1db.values.ensureIndex(&#123;open: 1, close: 1&#125;, &#123;background: true&#125;) MongoDB 自动增长创建 Javascript 函数db.counters.insert(&#123;_id:&quot;gua&quot;,sequence_value:0&#125;) 1234567891011121314function getNextSequenceValue(sequenceName)&#123; var sequenceDocument = db.counters.findAndModify( &#123; query:&#123;_id: sequenceName &#125;, update: &#123;$inc:&#123;sequence_value:1&#125;&#125;, new:true &#125;); return sequenceDocument.sequence_value;&#125;db.counters.insert(&#123; &quot;_id&quot;:getNextSequenceValue(&quot;gua&quot;), &quot;product_name&quot;:&quot;Apple iPhone&quot;, &#x27;test&#x27;:&#x27;guaguagua&#x27;&#125;) $type 操作符 类型 数字 备注 Double 1 String 2 Object 3 Array 4 Binary data 5 Undefined 6 已废弃。 Object id 7 Boolean 8 Date 9 Null 10 Regular Expression 11 JavaScript 13 Symbol 14 JavaScript (with scope) 15 32-bit integer 16 Timestamp 17 64-bit integer 18 Min key 255 Query with -1. Max key 127 12如果想获取 &quot;col&quot; 集合中 title 为 String 的数据，你可以使用以下命令：db.col.find(&#123;&quot;title&quot; : &#123;$type : 2&#125;&#125;) 时间戳 1234db.getCollection(&#x27;counters&#x27;).find(&#123;gua:&#123; $gte:new Date(2017,7,01).getTime(), $lte:new Date(2017,7,18).getTime() &#125;&#125;)","categories":[],"tags":[{"name":"mongoose","slug":"mongoose","permalink":"https://vlwq.github.io/tags/mongoose/"}]},{"title":"ES6特性","slug":"2017/20170711","date":"2017-07-11T02:36:00.000Z","updated":"2017-07-20T13:12:44.931Z","comments":true,"path":"2017/07/11/2017/20170711/","link":"","permalink":"https://vlwq.github.io/2017/07/11/2017/20170711/","excerpt":"ES6特性如下： 1.块级作用域 关键字let, 常量const 2.对象字面量的属性赋值简写（property value shorthand）","text":"ES6特性如下： 1.块级作用域 关键字let, 常量const 2.对象字面量的属性赋值简写（property value shorthand） 12345678910111213var obj = &#123; // __proto__ __proto__: theProtoObj, // Shorthand for ‘handler: handler’ handler, // Method definitions toString() &#123; // Super calls return &quot;d &quot; + super.toString(); &#125;, // Computed (dynamic) property names [ &#x27;prop_&#x27; + (() =&gt; 42)() ]: 42&#125;; 3.赋值解构 1234let singer = &#123; first: &quot;Bob&quot;, last: &quot;Dylan&quot; &#125;;let &#123; first: f, last: l &#125; = singer; // 相当于 f = &quot;Bob&quot;, l = &quot;Dylan&quot;let [all, year, month, day] = /^(\\d\\d\\d\\d)-(\\d\\d)-(\\d\\d)$/.exec(&quot;2015-10-25&quot;);let [x, y] = [1, 2, 3]; // x = 1, y = 2 4.函数参数 - 默认值、参数打包、 数组展开（Default 、Rest 、Spread） 1234567891011121314151617//Defaultfunction findArtist(name=&#x27;lu&#x27;, age=&#x27;26&#x27;) &#123; ...&#125;//Restfunction f(x, ...y) &#123; // y is an Array return x * y.length;&#125;f(3, &quot;hello&quot;, true) == 6//Spreadfunction f(x, y, z) &#123; return x + y + z;&#125;// Pass each elem of array as argumentf(...[1,2,3]) == 6 5.箭头函数 Arrow functions (1).简化了代码形式，默认return表达式结果。 (2).自动绑定语义this，即定义函数时的this。如上面例子中，forEach的匿名函数参数中用到的this。 6.字符串模板 Template strings 123var name = &quot;Bob&quot;, time = &quot;today&quot;;`Hello $&#123;name&#125;, how are you $&#123;time&#125;?`// return &quot;Hello Bob, how are you today?&quot; Iterators（迭代器）+ for..of 迭代器有个next方法，调用会返回： 12345678(1).返回迭代对象的一个元素：&#123; done: false, value: elem &#125;(2).如果已到迭代对象的末端：&#123; done: true, value: retVal &#125;for (var n of [&#x27;a&#x27;,&#x27;b&#x27;,&#x27;c&#x27;]) &#123; console.log(n);&#125;// 打印a、b、c 8.生成器 （Generators） 9.Class Class，有constructor、extends、super，但本质上是语法糖（对语言的功能并没有影响，但是更方便程序员使用）。 123456789101112131415161718192021222324252627class Artist &#123; constructor(name) &#123; this.name = name; &#125; perform() &#123; return this.name + &quot; performs &quot;; &#125;&#125;class Singer extends Artist &#123; constructor(name, song) &#123; super.constructor(name); this.song = song; &#125; perform() &#123; return super.perform() + &quot;[&quot; + this.song + &quot;]&quot;; &#125;&#125;let james = new Singer(&quot;Etta James&quot;, &quot;At last&quot;);james instanceof Artist; // truejames instanceof Singer; // truejames.perform(); // &quot;Etta James performs [At last]&quot; 10.Modules ES6的内置模块功能借鉴了CommonJS和AMD各自的优点： (1).具有CommonJS的精简语法、唯一导出出口(single exports)和循环依赖(cyclic dependencies)的特点。 (2).类似AMD，支持异步加载和可配置的模块加载。 1234567891011121314151617181920212223// lib/math.jsexport function sum(x, y) &#123; return x + y;&#125;export var pi = 3.141593;// app.jsimport * as math from &quot;lib/math&quot;;alert(&quot;2π = &quot; + math.sum(math.pi, math.pi));// otherApp.jsimport &#123;sum, pi&#125; from &quot;lib/math&quot;;alert(&quot;2π = &quot; + sum(pi, pi));Module Loaders:// Dynamic loading – ‘System’ is default loaderSystem.import(&#x27;lib/math&#x27;).then(function(m) &#123; alert(&quot;2π = &quot; + m.sum(m.pi, m.pi));&#125;);// Directly manipulate module cacheSystem.get(&#x27;jquery&#x27;);System.set(&#x27;jquery&#x27;, Module(&#123;$: $&#125;)); // WARNING: not yet finalized 11.Map + Set + WeakMap + WeakSet 四种集合类型，WeakMap、WeakSet作为属性键的对象如果没有别的变量在引用它们，则会被回收释放掉。 123456789101112131415161718192021// Setsvar s = new Set();s.add(&quot;hello&quot;).add(&quot;goodbye&quot;).add(&quot;hello&quot;);s.size === 2;s.has(&quot;hello&quot;) === true;// Mapsvar m = new Map();m.set(&quot;hello&quot;, 42);m.set(s, 34);m.get(s) == 34;//WeakMapvar wm = new WeakMap();wm.set(s, &#123; extra: 42 &#125;);wm.size === undefined// Weak Setsvar ws = new WeakSet();ws.add(&#123; data: 42 &#125;);//Because the added object has no other references, it will not be held in the set 12.Math + Number + String + Array + Object APIs 一些新的API 123456789101112131415161718192021222324Number.EPSILONNumber.isInteger(Infinity) // falseNumber.isNaN(&quot;NaN&quot;) // falseMath.acosh(3) // 1.762747174039086Math.hypot(3, 4) // 5Math.imul(Math.pow(2, 32) - 1, Math.pow(2, 32) - 2) // 2&quot;abcde&quot;.includes(&quot;cd&quot;) // true&quot;abc&quot;.repeat(3) // &quot;abcabcabc&quot;Array.from(document.querySelectorAll(&#x27;*&#x27;)) // Returns a real ArrayArray.of(1, 2, 3) // Similar to new Array(...), but without special one-arg behavior[0, 0, 0].fill(7, 1) // [0,7,7][1, 2, 3].find(x =&gt; x == 3) // 3[1, 2, 3].findIndex(x =&gt; x == 2) // 1[1, 2, 3, 4, 5].copyWithin(3, 0) // [1, 2, 3, 1, 2][&quot;a&quot;, &quot;b&quot;, &quot;c&quot;].entries() // iterator [0, &quot;a&quot;], [1,&quot;b&quot;], [2,&quot;c&quot;][&quot;a&quot;, &quot;b&quot;, &quot;c&quot;].keys() // iterator 0, 1, 2[&quot;a&quot;, &quot;b&quot;, &quot;c&quot;].values() // iterator &quot;a&quot;, &quot;b&quot;, &quot;c&quot;Object.assign(Point, &#123; origin: new Point(0,0) &#125;) Proxies 使用代理（Proxy）监听对象的操作，然后可以做一些相应事情。 1234567891011var target = &#123;&#125;;var handler = &#123; get: function (receiver, name) &#123; return `Hello, $&#123;name&#125;!`; &#125;&#125;;var p = new Proxy(target, handler);p.world === &#x27;Hello, world!&#x27;;可监听的操作： get、set、has、deleteProperty、apply、construct、getOwnPropertyDescriptor、defineProperty、getPrototypeOf、setPrototypeOf、enumerate、ownKeys、preventExtensions、isExtensible。 14.Symbols Symbol是一种基本类型。Symbol 通过调用symbol函数产生，它接收一个可选的名字参数，该函数返回的symbol是唯一的。 123var key = Symbol(&quot;key&quot;);var key2 = Symbol(&quot;key&quot;);key == key2 //false 15.Promises Promises是处理异步操作的对象，使用了 Promise 对象之后可以用一种链式调用的方式来组织代码，让代码更加直观（类似jQuery的deferred 对象）。 1234567891011121314151617function fakeAjax(url) &#123; return new Promise(function (resolve, reject) &#123; // setTimeouts are for effect, typically we would handle XHR if (!url) &#123; return setTimeout(reject, 1000); &#125; return setTimeout(resolve, 1000); &#125;);&#125;// no url, promise rejectedfakeAjax().then(function () &#123; console.log(&#x27;success&#x27;);&#125;,function () &#123; console.log(&#x27;fail&#x27;);&#125;);","categories":[],"tags":[{"name":"js","slug":"js","permalink":"https://vlwq.github.io/tags/js/"}]},{"title":"BBR加速","slug":"2017/20170710","date":"2017-07-10T02:36:00.000Z","updated":"2017-07-16T04:27:15.191Z","comments":true,"path":"2017/07/10/2017/20170710/","link":"","permalink":"https://vlwq.github.io/2017/07/10/2017/20170710/","excerpt":"Debian / Ubuntu 14.04 + CentOS用户请使用这个脚本：CentOS/Debian/Ubuntu系统 TCP-BBR 一键安装脚本 本脚本只在 Debian 7 / Debian 8 / Ubuntu 14.04 / Ubuntu 16.04 (均 x64位) 这几个系统中测试过脚本可以正常运行(Vultr)！ 强烈推荐 Debian 7 x64，这个是我一直使用的系统，我的脚本在这个系统上面出错率最低。 至于为什么不支持 CentOS 等系统，主要是我不怎么用其他的系统，就不做支持了。","text":"Debian / Ubuntu 14.04 + CentOS用户请使用这个脚本：CentOS/Debian/Ubuntu系统 TCP-BBR 一键安装脚本 本脚本只在 Debian 7 / Debian 8 / Ubuntu 14.04 / Ubuntu 16.04 (均 x64位) 这几个系统中测试过脚本可以正常运行(Vultr)！ 强烈推荐 Debian 7 x64，这个是我一直使用的系统，我的脚本在这个系统上面出错率最低。 至于为什么不支持 CentOS 等系统，主要是我不怎么用其他的系统，就不做支持了。 安装步骤更换内核需要ROOT权限，所以如果你是普通用户 的话，需要ROOT账号权限，如果你是ROOT账号，那就忽略这个步骤： 1sudo su 输入并回车后，会提示让你输入当前账号的密码，输入并回车后就可以继续下面的步骤了。 1wget -N --no-check-certificate https://softs.pw/Bash/bbr.sh &amp;&amp; chmod +x bbr.sh &amp;&amp; bash bbr.sh 备用下载地址（上面的链接无法下载，就用这个）： 1wget -N --no-check-certificate https://raw.githubusercontent.com/ToyoDAdoubi/doubi/master/bbr.sh &amp;&amp; chmod +x bbr.sh &amp;&amp; bash bbr.sh 下载并运行脚本后，会自动检测并开始安装，首先会提示你输入要下载的内核版本，可以安装自定义版本的内核，也可以直接回车安装最新版本的内核（内核版本获取）！ 1234请输入 要下载安装的Linux内核版本(BBR) [ 格式: x.xx.xx ，例如: 4.10.12 ] [注意]内核版本列表请去这里获取：[ http://kernel.ubuntu.com/~kernel-ppa/mainline/ ](默认回车，自动获取最新版本):4.10.10 如果没有出错，内核更换完毕后，会提示是否立即重启VPS，直接回车或者输入 Y 。需要重启VPS后，才能开启BBR，是否现在重启 ? [Y/n] : y[注意] 重启VPS后，请重新运行脚本开启BBR: bash bbr.sh start [信息] VPS 重启中… 等待十几秒，VPS启动后，重新通过SSH连接VPS，进入 bbr.sh 脚本的目录，然后执行下面这个命令开启BBR。 1bash bbr.sh start 然后就会自动开启BBR。如果重启VPS后，无法连接，说明内核安装或与系统存在兼容性问题，无法正常启动，代表你的VPS当前系统无法使用BBR，请更换其他系统！ 使用方法 123456789101112# 启动BBR，更换/升级内核并重启后，需要执行这个开启BBR！bash bbr.sh start# 关闭BBRbash bbr.sh stop# 查看BBR状态bash bbr.sh status# 升级BBRbash bbr.sh# 因为BBR是集成于内核中的，只是内核中的一部分，所以不一定要更新最新的内核，因为内核升级不一定是BBR升级。 卸载BBR BBR集成于内核中，所以卸载BBR=更换内核，教程： 其他说明 注意：TCP-BBR必须是 2016-12-05 21:00 更新的 4.9.0-rc8 内核及以后的版本 才能开启，而锐速并不支持这个最新的内核版本，所以TCP-BBR和锐速是不可能共存的。裸SS / 锐速+SS / BBR+SS简单速度对比，仅供参考，看这里。 更换内核后重启服务器无法启动 的问题 如果重启VPS后，无法连接，说明内核安装有问题 或 内核与系统存在兼容性问题，无法正常启动。 这代表你的VPS当前系统不支持最新的内核版本，无法开启BBR，请更换其他系统尝试！ 1提示 wget: unknown host “softs.pw” 之类的错误 这是无法解析我的域名，多半是DNS的问题，请更换DNS为谷歌DNS。 123echo &quot;nameserver 8.8.8.8&quot; &gt; /etc/resolv.confecho &quot;nameserver 8.8.4.4&quot; &gt;&gt; /etc/resolv.conf提示 wget: command not found 的错误 这是你的系统精简的太干净了，wget都没有安装，所以需要安装wget。 123Debian/Ubuntu系统:apt-get install -y wget","categories":[],"tags":[{"name":"linux","slug":"linux","permalink":"https://vlwq.github.io/tags/linux/"}]},{"title":"mongoose 模型定义重复引用就报错：Cannot overwrite model once compiled 怎么解决？","slug":"2017/20170708","date":"2017-07-08T02:36:00.000Z","updated":"2017-07-16T04:20:48.070Z","comments":true,"path":"2017/07/08/2017/20170708/","link":"","permalink":"https://vlwq.github.io/2017/07/08/2017/20170708/","excerpt":"错误提示的意思是：mongoose模型被重复定义了，这是不允许的 首先，你需要搞清楚require和module.exports的运行机制，建议你看看这篇：http://www.nodeclass.com/articles/37488","text":"错误提示的意思是：mongoose模型被重复定义了，这是不允许的 首先，你需要搞清楚require和module.exports的运行机制，建议你看看这篇：http://www.nodeclass.com/articles/37488 然后，针对你这个场景，不应该把 mongoose.model()模型定义方法做为模块导出的方法，因为： 模型定义不允许重复，所以这个mongoose.model()应该只调用一次，而导出它执行后的结果require机制确保了mongoose.model()只会执行一次 所以，你的代码应该改写成这样： 123456var UserAccountSchema = mongoose.Schema(&#123; //...略去定义代码&#125;);var model = mongoose.model(&#x27;user.account&#x27;, UserAccountSchema);//导出模型module.exports =model;","categories":[],"tags":[{"name":"mongoose","slug":"mongoose","permalink":"https://vlwq.github.io/tags/mongoose/"}]},{"title":"electron打包程序","slug":"2017/20170705","date":"2017-07-05T02:36:00.000Z","updated":"2017-07-05T12:42:33.723Z","comments":true,"path":"2017/07/05/2017/20170705/","link":"","permalink":"https://vlwq.github.io/2017/07/05/2017/20170705/","excerpt":"目录结构T:/player/index.html(网页入口)T:/player/main.jsT:/player/package.json//成功打包的话，会player同级目录生成exeT:/outplayer/项目名","text":"目录结构T:/player/index.html(网页入口)T:/player/main.jsT:/player/package.json//成功打包的话，会player同级目录生成exeT:/outplayer/项目名 mian.js12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364const electron = require(&#x27;electron&#x27;)// Module to control application life.const app = electron.app// Module to create native browser window.const BrowserWindow = electron.BrowserWindowconst path = require(&#x27;path&#x27;)const url = require(&#x27;url&#x27;)// Keep a global reference of the window object, if you don&#x27;t, the window will// be closed automatically when the JavaScript object is garbage collected.let mainWindowfunction createWindow() &#123; // Create the browser window. mainWindow = new BrowserWindow(&#123; width: 1200, height: 800 &#125;) // and load the index.html of the app. mainWindow.loadURL(url.format(&#123; pathname: path.join(__dirname, &#x27;index.html&#x27;), protocol: &#x27;file:&#x27;, slashes: true &#125;)) // Open the DevTools.我默认关闭了调试模式 //mainWindow.webContents.openDevTools() // Emitted when the window is closed. mainWindow.on(&#x27;closed&#x27;, function() &#123; // Dereference the window object, usually you would store windows // in an array if your app supports multi windows, this is the time // when you should delete the corresponding element. mainWindow = null &#125;)&#125;// This method will be called when Electron has finished// initialization and is ready to create browser windows.// Some APIs can only be used after this event occurs.app.on(&#x27;ready&#x27;, createWindow)// Quit when all windows are closed.app.on(&#x27;window-all-closed&#x27;, function() &#123; // On OS X it is common for applications and their menu bar // to stay active until the user quits explicitly with Cmd + Q if (process.platform !== &#x27;darwin&#x27;) &#123; app.quit() &#125;&#125;)app.on(&#x27;activate&#x27;, function() &#123; // On OS X it&#x27;s common to re-create a window in the app when the // dock icon is clicked and there are no other windows open. if (mainWindow === null) &#123; createWindow() &#125;&#125;)// In this file you can include the rest of your app&#x27;s specific main process// code. You can also put them in separate files and require them here. package.json123456789101112131415161718&#123; &quot;name&quot;: &quot;player&quot;, &quot;version&quot;: &quot;1.0.0&quot;, &quot;description&quot;: &quot;a music player&quot;, &quot;main&quot;: &quot;main.js&quot;, &quot;scripts&quot;: &#123; &quot;start&quot;: &quot;electron .&quot;, &quot;pack&quot;: &quot;electron-packager ./ andrewplayer --win32 --out ./../outplayer --electronVersion 1.4.13 --overwrite&quot; &#125;, &quot;author&quot;: &quot;Andrew li&quot;, &quot;license&quot;: &quot;ISC&quot;, &quot;dependencies&quot;: &#123; &quot;electron&quot;: &quot;^1.6.11&quot;, &quot;electron-packager&quot;: &quot;^8.7.2&quot;, &quot;electron-prebuilt&quot;: &quot;^1.4.13&quot; &#125;&#125; package文件的打包脚本pack说明一下：andrewplayer –是我的程序名win32 –生成windows下的exe可执行文件,其他平台: linux, win32, darwin, mas, all./../outplayer —生成的项目所在地方，和player（当前项目）同级目录–electronVersion 1.4.13 —这个是electron-prebuilt的版本 更多查 官网api 开始安装，先把源切到淘宝的镜像（yarn官网那个时慢时快）1234// 查看下载源yarn config get registry // 更换为淘宝源 1yarn config set registry https://registry.npm.taobao.org 后面直接运行脚本即可12yarn install 先测试下能不能用 1yarn run start 最后打包123yarn run pack 和player同级目录外面应该已经生成一个outplayer目录了","categories":[],"tags":[{"name":"node","slug":"node","permalink":"https://vlwq.github.io/tags/node/"}]},{"title":"yarn更换为淘宝镜像","slug":"2017/20170701","date":"2017-07-01T02:36:00.000Z","updated":"2017-07-16T04:34:21.559Z","comments":true,"path":"2017/07/01/2017/20170701/","link":"","permalink":"https://vlwq.github.io/2017/07/01/2017/20170701/","excerpt":"npm install cnpm cnpm install yarn -g","text":"npm install cnpm cnpm install yarn -g 1234// 查看下载源yarn config get registry // 更换为淘宝源 1yarn config set registry https://registry.npm.taobao.org // 初始化项目 1yarn init -y // 安装webpack 1yarn add webpack // 安装webpack到dev 1yarn add webpack -D // 更新到最新的 1yarn upgrade webpack // 安装项目里的依赖 1yarn install","categories":[],"tags":[{"name":"node","slug":"node","permalink":"https://vlwq.github.io/tags/node/"}]},{"title":"html 网页中的锚点(命名锚记)的使用介绍","slug":"2017/20170626","date":"2017-06-26T02:36:00.000Z","updated":"2017-07-07T13:33:30.062Z","comments":true,"path":"2017/06/26/2017/20170626/","link":"","permalink":"https://vlwq.github.io/2017/06/26/2017/20170626/","excerpt":"锚点是网页制作中超级链接的一种，又叫命名锚记。命名锚记像一个迅速定位器一样是一种页面内的超级链接，运用相当普遍。英文名：anchor使用命名锚记可以在文档中设置标记，这些标记通常放在文档的特定主题处或顶部。然后可以创建到这些命名锚记的链接，这些链接可快速将访问者带到指定位置。创建到命名锚记的链接的过程分为两步。首先，创建命名锚记，然后创建到该命名锚记的链接。","text":"锚点是网页制作中超级链接的一种，又叫命名锚记。命名锚记像一个迅速定位器一样是一种页面内的超级链接，运用相当普遍。英文名：anchor使用命名锚记可以在文档中设置标记，这些标记通常放在文档的特定主题处或顶部。然后可以创建到这些命名锚记的链接，这些链接可快速将访问者带到指定位置。创建到命名锚记的链接的过程分为两步。首先，创建命名锚记，然后创建到该命名锚记的链接。 1234567891011121314151617代码如下: 这种方法测试不行必须加上id这个字段才可以&lt;html&gt;&lt;body&gt;&lt;p&gt;&lt;a href=&quot;#method1&quot;&gt;页面锚点方法一&lt;/a&gt;&lt;/p&gt;&lt;p&gt;&lt;a href=&quot;#method2&quot;&gt;页面锚点方法二&lt;/a&gt;&lt;/p&gt;&lt;h2&gt;&lt;a name=&quot;method1&quot;&gt;方法一&lt;/a&gt;&lt;/h2&gt;&lt;p&gt;使用锚标签的 href 和 name 属性&lt;/p&gt;&lt;h2 id=&quot;method2&quot;&gt;方法二&lt;/h2&gt;&lt;p&gt;使用锚标签和 id 属性&lt;/p&gt;&lt;/body&gt;&lt;/html&gt;","categories":[],"tags":[{"name":"node","slug":"node","permalink":"https://vlwq.github.io/tags/node/"}]},{"title":"mongoose分页","slug":"2017/20170625","date":"2017-06-25T11:36:00.000Z","updated":"2017-07-04T13:57:10.592Z","comments":true,"path":"2017/06/25/2017/20170625/","link":"","permalink":"https://vlwq.github.io/2017/06/25/2017/20170625/","excerpt":"123456789var mongoose = require(&#x27;mongoose&#x27;);mongoose.connect(&#x27;MongoDB://192.168.0.229:27017/Test&#x27;);var Cat = mongoose.model(&#x27;Cat&#x27;, &#123; name: String , _id:String , age:&#123; type: Number, min: 18, max: 65 &#125;&#125;);","text":"123456789var mongoose = require(&#x27;mongoose&#x27;);mongoose.connect(&#x27;MongoDB://192.168.0.229:27017/Test&#x27;);var Cat = mongoose.model(&#x27;Cat&#x27;, &#123; name: String , _id:String , age:&#123; type: Number, min: 18, max: 65 &#125;&#125;); 12345678910111213var query=Cat.find(&#123;&#125;);query.where(&#123;age:30&#125;);query.sort(&#123; name: &#x27;asc&#x27;, age: -1 &#125;);//query.and(&#123;_id:&quot;123456222&quot;&#125;);query.or([&#123;_id:&quot;123456fff222&quot;&#125;,&#123;_id:&quot;123456222&quot;&#125;]);//query.limit(3); //限制条数//query.skip(3) //开始数 ，通过计算可是实现分页//query.friends(&#x27;name&#x27;)query.exec(function(err,docs)&#123; console.log(docs);&#125;) 开发文档地址：http://mongoosejs.com/docs/api.html#query_Query-or","categories":[],"tags":[{"name":"node","slug":"node","permalink":"https://vlwq.github.io/tags/node/"}]},{"title":"bootstrap弹出框","slug":"2017/20170623","date":"2017-06-22T16:00:00.000Z","updated":"2017-07-16T04:34:47.981Z","comments":true,"path":"2017/06/23/2017/20170623/","link":"","permalink":"https://vlwq.github.io/2017/06/23/2017/20170623/","excerpt":"bootstrap弹出框标签（空格分隔）： bootstrap","text":"bootstrap弹出框标签（空格分隔）： bootstrap 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667&lt;!DOCTYPE html&gt;&lt;html&gt;&lt;head&gt; &lt;meta charset=&quot;utf-8&quot;&gt; &lt;title&gt;Bootstrap 实例 - 模态框（Modal）插件&lt;/title&gt; &lt;link rel=&quot;stylesheet&quot; href=&quot;http://cdn.static.runoob.com/libs/bootstrap/3.3.7/css/bootstrap.min.css&quot;&gt; &lt;script src=&quot;http://cdn.static.runoob.com/libs/jquery/2.1.1/jquery.min.js&quot;&gt;&lt;/script&gt; &lt;script src=&quot;http://cdn.static.runoob.com/libs/bootstrap/3.3.7/js/bootstrap.min.js&quot;&gt;&lt;/script&gt;&lt;/head&gt;&lt;body&gt;&lt;h2&gt;创建模态框（Modal）&lt;/h2&gt;&lt;!-- 按钮触发模态框 --&gt;&lt;button class=&quot;btn btn-primary btn-lg&quot; data-toggle=&quot;modal&quot; data-target=&quot;#myModal&quot;&gt; 开始演示模态框&lt;/button&gt;&lt;!-- 模态框（Modal） --&gt;&lt;div class=&quot;modal fade&quot; id=&quot;myModal&quot; tabindex=&quot;-1&quot; role=&quot;dialog&quot; aria-labelledby=&quot;myModalLabel&quot; aria-hidden=&quot;true&quot;&gt; &lt;div class=&quot;modal-dialog&quot;&gt; &lt;div class=&quot;modal-content&quot;&gt; &lt;div class=&quot;modal-header&quot;&gt; &lt;button type=&quot;button&quot; class=&quot;close&quot; data-dismiss=&quot;modal&quot; aria-hidden=&quot;true&quot;&gt; &amp;times; &lt;/button&gt; &lt;h4 class=&quot;modal-title&quot; id=&quot;myModalLabel&quot;&gt; 模态框（Modal）标题 &lt;/h4&gt; &lt;/div&gt; &lt;div class=&quot;modal-body&quot;&gt; &lt;form class=&quot;bs-example bs-example-form&quot; role=&quot;form&quot;&gt; &lt;div class=&quot;input-group&quot;&gt; &lt;span class=&quot;input-group-addon&quot;&gt;字段1&lt;/span&gt; &lt;input type=&quot;text&quot; class=&quot;form-control&quot; placeholder=&quot;测试&quot;&gt; &lt;span class=&quot;input-group-addon&quot;&gt;字段2&lt;/span&gt; &lt;input type=&quot;text&quot; class=&quot;form-control&quot; &gt; &lt;/div&gt; &lt;br&gt; &lt;div class=&quot;input-group&quot;&gt; &lt;span class=&quot;input-group-addon&quot;&gt;字段1&lt;/span&gt; &lt;input type=&quot;text&quot; class=&quot;form-control&quot; placeholder=&quot;测试&quot;&gt; &lt;span class=&quot;input-group-addon&quot;&gt;字段2&lt;/span&gt; &lt;input type=&quot;text&quot; class=&quot;form-control&quot; &gt; &lt;/div&gt; &lt;br&gt; &lt;div class=&quot;input-group&quot;&gt; &lt;span class=&quot;input-group-addon&quot;&gt;字段1&lt;/span&gt; &lt;input type=&quot;text&quot; class=&quot;form-control&quot; placeholder=&quot;测试&quot;&gt; &lt;span class=&quot;input-group-addon&quot;&gt;字段2&lt;/span&gt; &lt;input type=&quot;text&quot; class=&quot;form-control&quot; &gt; &lt;/div&gt; &lt;/form&gt; &lt;/div&gt; &lt;div class=&quot;modal-footer&quot;&gt; &lt;button type=&quot;button&quot; class=&quot;btn btn-default&quot; data-dismiss=&quot;modal&quot;&gt;关闭 &lt;/button&gt; &lt;button type=&quot;button&quot; class=&quot;btn btn-primary&quot;&gt; 提交更改 &lt;/button&gt; &lt;/div&gt; &lt;/div&gt;&lt;!-- /.modal-content --&gt; &lt;/div&gt;&lt;!-- /.modal --&gt;&lt;/div&gt;&lt;/body&gt;&lt;/html&gt;","categories":[],"tags":[{"name":"html5","slug":"html5","permalink":"https://vlwq.github.io/tags/html5/"}]},{"title":"mongoose里.save()/update()/findOneAndUpdate()的区别","slug":"2017/20170622","date":"2017-06-22T02:36:00.000Z","updated":"2017-08-27T05:53:31.963Z","comments":true,"path":"2017/06/22/2017/20170622/","link":"","permalink":"https://vlwq.github.io/2017/06/22/2017/20170622/","excerpt":".save()和update()update比find之后save()效率高，因为这样不用读取整个文档。Mongoose的update是MongoDB的update，但是Mongoose的save可能是MongoDB的插入或是update。","text":".save()和update()update比find之后save()效率高，因为这样不用读取整个文档。Mongoose的update是MongoDB的update，但是Mongoose的save可能是MongoDB的插入或是update。 关于save，mongoose会自动diff新文档，只更改更新部分。这有利于原子性。update不能触发中间件，validation默认不能，但是可以修改。update()和findOneAndUpdate()update()返回数据处理条数findOneAndUpdate()返回处理后的数据简单来说，你需要获取数据就用findOneAndUpdate()，只需要修改数据而不关注修改后数据那就用update()。","categories":[],"tags":[{"name":"mongoose","slug":"mongoose","permalink":"https://vlwq.github.io/tags/mongoose/"}]},{"title":"移动端","slug":"2017/20170620","date":"2017-06-20T02:36:00.000Z","updated":"2017-08-27T05:53:31.932Z","comments":true,"path":"2017/06/20/2017/20170620/","link":"","permalink":"https://vlwq.github.io/2017/06/20/2017/20170620/","excerpt":"","text":"https://github.com/wuchangming/spy-debugger推荐一个移动端的调试工具，可在 pc 端操作移动端页面，可看到操作台","categories":[],"tags":[{"name":"mongoose","slug":"mongoose","permalink":"https://vlwq.github.io/tags/mongoose/"}]},{"title":"高程笔记9-新api","slug":"2017/20170617","date":"2017-06-17T02:36:00.000Z","updated":"2017-07-16T04:25:43.362Z","comments":true,"path":"2017/06/17/2017/20170617/","link":"","permalink":"https://vlwq.github.io/2017/06/17/2017/20170617/","excerpt":"高程笔记9","text":"高程笔记9 requestAnimationFrame()1234567891011mozRequestAnimationFrame()方法接收一个参数，即在重绘屏幕前调用的一个函数。这个函数负责改变下一次重绘时的 DOM 样式。为了创建动画循环，可以像以前使用 setTimeout()一样，把多个对 mozRequestAnimationFrame()的调用连缀起来。比如：function updateProgress()&#123; var div = document.getElementById(&quot;status&quot;); div.style.width = (parseInt(div.style.width, 10) + 5) + &quot;%&quot;; if (div.style.left != &quot;100%&quot;)&#123; mozRequestAnimationFrame(updateProgress); &#125;&#125;mozRequestAnimationFrame(updateProgress); webkitRequestAnimationFrame与msRequestAnimationFrame 基于 mozRequestAnimationFrame()，Chrome 和 IE10+也都给出了自己的实现，分别叫 webkitRequestAnimationFrame()和msRequestAnimationFrame()。这两个版本与 Mozilla 的版本有两个方面的微小差异。首先，不会给回调函数传递时间码，因此你无法知道下一次重绘将发生在什么时间。其次，Chrome 又增加了第二个可选的参数，即将要发生变化的 DOM 元素。知道了重绘将发生在页面中哪个特定元素的区域内，就可以将重绘限定在该区域中。既然没有下一次重绘的时间码，那 Chrome 和 IE 没有提供 mozAnimationStartTime 的实现也就很容易理解了——没有那个时间码，实现这个属性也没有什么用。不过，Chrome 倒是又提供了另一个方法 webkitCancelAnimationFrame()，用于取消之前计划执行的重绘操作。假如你不需要知道精确的时间差，那么可以在 Firefox 4+、IE10+和 Chrome 中可以参考以下模式创建动画循环。 1234567891011121314151617181920(function()&#123; function draw(timestamp)&#123; //计算两次重绘的时间间隔 var drawStart = (timestamp || Date.now()), diff = drawStart - startTime; //使用 diff 确定下一步的绘制时间 //把 startTime 重写为这一次的绘制时间 startTime = drawStart; //重绘 UI requestAnimationFrame(draw); &#125; var requestAnimationFrame = window.requestAnimationFrame || window.mozRequestAnimationFrame || window.webkitRequestAnimationFrame || window.msRequestAnimationFrame, startTime = window.mozAnimationStartTime || Date.now(); requestAnimationFrame(draw);&#125;)(); File APIFile API 在表单中的文件输入字段的基础上，又添加了一些直接访问文件信息的接口。HTML5 在DOM 中为文件输入元素添加了一个 files 集合。在通过文件输入字段选择了一或多个文件时，files集合中将包含一组 File 对象，每个 File 对象对应着一个文件。每个 File 对象都有下列只读属性。  name：本地文件系统中的文件名。 size：文件的字节大小。 type：字符串，文件的 MIME 类型。 lastModifiedDate：字符串，文件上一次被修改的时间（只有 Chrome 实现了这个属性）。举个例子，通过侦听 change 事件并读取 files 集合就可以知道选择的每个文件的信息： 1234567891011var filesList = document.getElementById(&quot;files-list&quot;);EventUtil.addHandler(filesList, &quot;change&quot;, function(event)&#123;var files = EventUtil.getTarget(event).files, i = 0, len = files.length; while (i &lt; len)&#123; console.log(files[i].name + &quot; (&quot; + files[i].type + &quot;, &quot; + files[i].size + &quot; bytes) &quot;); i++; &#125;&#125;); FileReader类型FileReader类型实现的是一种异步文件读取机制。可以把FileReader想象成XMLHttpRequest，区别只是它读取的是文件系统，而不是远程服务器。为了读取文件中的数据，FileReader 提供了如下几个方法。  readAsText(file,encoding)：以纯文本形式读取文件，将读取到的文本保存在 result 属性中。第二个参数用于指定编码类型，是可选的。 readAsDataURL(file)：读取文件并将文件以数据 URI 的形式保存在 result 属性中。 readAsBinaryString(file)：读取文件并将一个字符串保存在 result 属性中，字符串中的每个字符表示一字节。 readAsArrayBuffer(file)：读取文件并将一个包含文件内容的 ArrayBuffer 保存在result 属性中。这些读取文件的方法为灵活地处理文件数据提供了极大便利。例如，可以读取图像文件并将其保存为数据 URI，以便将其显示给用户，或者为了解析方便，可以将文件读取为文本形式。 123456789101112131415161718192021222324252627282930313233343536373839404142var filesList = document.getElementById(&quot;files-list&quot;);EventUtil.addHandler(filesList, &quot;change&quot;, function(event)&#123; var info = &quot;&quot;, output = document.getElementById(&quot;output&quot;), progress = document.getElementById(&quot;progress&quot;), files = EventUtil.getTarget(event).files, type = &quot;default&quot;, reader = new FileReader(); if (/image/.test(files[0].type))&#123; reader.readAsDataURL(files[0]); type = &quot;image&quot;; &#125; else &#123; reader.readAsText(files[0]); type = &quot;text&quot;; &#125; reader.onerror = function()&#123; output.innerHTML = &quot;Could not read file, error code is &quot; + reader.error.code; &#125;; reader.onprogress = function(event)&#123; if (event.lengthComputable)&#123; progress.innerHTML = event.loaded + &quot;/&quot; + event.total; &#125; &#125;; reader.onload = function()&#123; var html = &quot;&quot;; switch(type)&#123; case &quot;image&quot;: html = &quot;&lt;img src=\\&quot;&quot; + reader.result + &quot;\\&quot;&gt;&quot;; break; case &quot;text&quot;: html = reader.result; break; &#125; output.innerHTML = html; &#125;;&#125;);这个例子读取了表单字段中选择的文件，并将其内容显示在了页面中。如果文件有 MIMI 类型，表示文件是图像，因此在 load 事件中就把它保存为数据 URI，并在页面中将这幅图像显示出来。如果文件不是图像，则以字符串形式读取文件内容，然后如实在页面中显示读取到的内容。这里使用了progress 事件来跟踪读取了多少字节的数据，而 error 事件则用于监控发生的错误。 读取部分内容有时候，我们只想读取文件的一部分而不是全部内容。为此，File 对象还支持一个 slice()方法，这个方法在 Firefox 中的实现叫 mozSlice()，在 Chrome 中的实现叫 webkitSlice()，Safari 的 5.1 及之前版本不支持这个方法。slice()方法接收两个参数：起始字节及要读取的字节数。这个方法返回一个 Blob 的实例，Blob 是 File 类型的父类型。下面是一个通用的函数，可以在不同实现中使用 slice()方法： 1234567891011function blobSlice(blob, startByte, length)&#123; if (blob.slice)&#123; return blob.slice(startByte, length); &#125; else if (blob.webkitSlice)&#123; return blob.webkitSlice(startByte, length); &#125; else if (blob.mozSlice)&#123; return blob.mozSlice(startByte, length); &#125; else &#123; return null; &#125;&#125; 对象URL1234567891011121314对象 URL 也被称为 blob URL，指的是引用保存在 File 或 Blob 中数据的 URL。使用对象 URL 的好处是可以不必把文件内容读取到 JavaScript 中而直接使用文件内容。为此，只要在需要文件内容的地方提供对象 URL 即可。要创建对象 URL，可以使用 window.URL.createObjectURL()方法，并传入File 或 Blob 对象。这个方法在 Chrome 中的实现叫 window.webkitURL.createObjectURL()，因此可以通过如下函数来消除命名的差异：function createObjectURL(blob)&#123; if (window.URL)&#123; return window.URL.createObjectURL(blob); &#125; else if (window.webkitURL)&#123; return window.webkitURL.createObjectURL(blob); &#125; else &#123; return null; &#125;&#125; 读取拖放的文件围绕读取文件信息，结合使用 HTML5 拖放 API 和文件 API，能够创造出令人瞩目的用户界面：在页面上创建了自定义的放置目标之后，你可以从桌面上把文件拖放到该目标。与拖放一张图片或者一个链接类似，从桌面上把文件拖放到浏览器中也会触发 drop 事件。而且可以在 event.dataTransfer. files中读取到被放置的文件，当然此时它是一个 File 对象，与通过文件输入字段取得的 File 对象一样。下面这个例子会将放置到页面中自定义的放置目标中的文件信息显示出来 123456789101112131415161718192021var droptarget = document.getElementById( &quot;droptarget&quot;);function handleEvent(event)&#123; var info = &quot;&quot;, output = document.getElementById(&quot;output&quot;), files, i, len; EventUtil.preventDefault(event); if (event.type == &quot;drop&quot;)&#123; files = event.dataTransfer.files; i = 0; len = files.length; while (i &lt; len)&#123; info += files[i].name + &quot; (&quot; + files[i].type + &quot;, &quot; + files[i].size + &quot; bytes)&lt;br&gt;&quot;; i++; &#125; output.innerHTML = info; &#125;&#125;EventUtil.addHandler(droptarget, &quot;dragenter&quot;, handleEvent);EventUtil.addHandler(droptarget, &quot;dragover&quot;, handleEvent);EventUtil.addHandler(droptarget, &quot;drop&quot;, handleEvent); 使用XHR上传文件首先，要创建一个 FormData对象，通过它调用 append()方法并传入相应的 File 对象作为参数。然后，再把 FormData 对象传递给 XHR 的 send()方法，结果与通过表单上传一模一样。 12345678910111213141516171819202122232425262728293031var droptarget = document.getElementById(&quot;droptarget&quot;);function handleEvent(event)&#123; var info = &quot;&quot;, output = document.getElementById(&quot;output&quot;), data, xhr, files, i, len; EventUtil.preventDefault(event); if (event.type == &quot;drop&quot;)&#123; data = new FormData(); //读取拖放的文件 files = event.dataTransfer.files; i = 0; len = files.length; while (i &lt; len)&#123; data.append(&quot;file&quot; + i, files[i]); i++; &#125; xhr = new XMLHttpRequest(); xhr.open(&quot;post&quot;, &quot;FileAPIExample06Upload.php&quot;, true); xhr.onreadystatechange = function()&#123; if (xhr.readyState == 4)&#123; alert(xhr.responseText); &#125; &#125;; xhr.send(data); &#125;&#125;EventUtil.addHandler(droptarget, &quot;dragenter&quot;, handleEvent);EventUtil.addHandler(droptarget, &quot;dragover&quot;, handleEvent);EventUtil.addHandler(droptarget, &quot;drop&quot;, handleEvent);","categories":[],"tags":[{"name":"高程","slug":"高程","permalink":"https://vlwq.github.io/tags/%E9%AB%98%E7%A8%8B/"}]},{"title":"高程笔记8-cookie","slug":"2017/20170616","date":"2017-06-16T02:36:00.000Z","updated":"2017-07-16T04:25:18.699Z","comments":true,"path":"2017/06/16/2017/20170616/","link":"","permalink":"https://vlwq.github.io/2017/06/16/2017/20170616/","excerpt":"高程笔记8","text":"高程笔记8 数据存储Cookie HTTP Cookie，通常直接叫做 cookie，最初是在客户端用于存储会话信息的。该标准要求服务器对任意 HTTP 请求发送 Set-Cookie HTTP 头作为响应的一部分，其中包含会话信息。例如，这种服务器响应的头可能如下：HTTP/1.1 200 OKContent-type: text/htmlSet-Cookie: name=valueOther-header: other-header-value 由于 cookie 是存在客户端计算机上的，还加入了一些限制确保 cookie 不会被恶意使用，同时不会占据太多磁盘空间。每个域的 cookie 总数是有限的，不过浏览器之间各有不同。如下所示。  IE6 以及更低版本限制每个域名最多 20 个 cookie。 IE7 和之后版本每个域名最多 50 个。IE7 最初是支持每个域名最大 20 个 cookie，之后被微软的一个补丁所更新。 Firefox 限制每个域最多 50 个 cookie。 Opera 限制每个域最多 30 个 cookie。 Safari 和 Chrome 对于每个域的 cookie 数量限制没有硬性规定。 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455var CookieUtil = &#123; get: function (name)&#123; var cookieName = encodeURIComponent(name) + &quot;=&quot;, cookieStart = document.cookie.indexOf(cookieName), cookieValue = null; if (cookieStart &gt; -1)&#123; var cookieEnd = document.cookie.indexOf(&quot;;&quot;, cookieStart); if (cookieEnd == -1)&#123; cookieEnd = document.cookie.length; &#125; cookieValue = decodeURIComponent(document.cookie.substring(cookieStart + cookieName.length, cookieEnd)); &#125; return cookieValue; &#125;, set: function (name, value, expires, path, domain, secure) &#123; var cookieText = encodeURIComponent(name) + &quot;=&quot; + encodeURIComponent(value); if (expires instanceof Date) &#123; cookieText += &quot;; expires=&quot; + expires.toGMTString(); &#125; if (path) &#123; cookieText += &quot;; path=&quot; + path; &#125; if (domain) &#123; cookieText += &quot;; domain=&quot; + domain; &#125; if (secure) &#123; cookieText += &quot;; secure&quot;; &#125; document.cookie = cookieText; &#125;, unset: function (name, path, domain, secure)&#123; this.set(name, &quot;&quot;, new Date(0), path, domain, secure); &#125;&#125;;可以像下面这样使用上述方法。//设置 cookieCookieUtil.set(&quot;name&quot;, &quot;Nicholas&quot;);CookieUtil.set(&quot;book&quot;, &quot;Professional JavaScript&quot;);//读取 cookie 的值alert(CookieUtil.get(&quot;name&quot;)); //&quot;Nicholas&quot;alert(CookieUtil.get(&quot;book&quot;)); //&quot;Professional JavaScript&quot;//删除 cookieCookieUtil.unset(&quot;name&quot;);CookieUtil.unset(&quot;book&quot;);//设置 cookie，包括它的路径、域、失效日期CookieUtil.set(&quot;name&quot;, &quot;Nicholas&quot;, &quot;/books/projs/&quot;, &quot;www.wrox.com&quot;, new Date(&quot;January 1, 2010&quot;));//删除刚刚设置的 cookieCookieUtil.unset(&quot;name&quot;, &quot;/books/projs/&quot;, &quot;www.wrox.com&quot;);//设置安全的 cookieCookieUtil.set(&quot;name&quot;, &quot;Nicholas&quot;, null, null, null, true); Web存储机制 Web Storage 的两个主要目标是： 提供一种在 cookie 之外存储会话数据的途径； 提供一种存储大量可以跨会话存在的数据的机制。最初的 Web Storage 规范包含了两种对象的定义：sessionStorage 和 globalStorage。 Storage 类型 Storage 类型提供最大的存储空间（因浏览器而异）来存储名值对儿。Storage 的实例与其他对象类似，有如下方法。 clear()： 删除所有值；Firefox 中没有实现 。 getItem(name)：根据指定的名字 name 获取对应的值。 key(index)：获得 index 位置处的值的名字。 removeItem(name)：删除由 name 指定的名值对儿。 setItem(name, value)：为指定的 name 设置一个对应的值。 sessionStorage 对象 sessionStorage 对象存储特定于某个会话的数据，也就是该数据只保持到浏览器关闭。这个对象就像会话 cookie，也会在浏览器关闭后消失。存储在 sessionStorage 中的数据可以跨越页面刷新而存在，同时如果浏览器支持，浏览器崩溃并重启之后依然可用（Firefox 和 WebKit 都支持，IE 则不行）。 123456789101112131415161718192021//使用方法存储数据sessionStorage.setItem(&quot;name&quot;, &quot;Nicholas&quot;);//使用属性存储数据sessionStorage.book = &quot;Professional JavaScript&quot;;//使用方法读取数据var name = sessionStorage.getItem(&quot;name&quot;);//使用属性读取数据var book = sessionStorage.book;使用 for-in 循环来迭代 sessionStorage 中的值：for (var key in sessionStorage)&#123; var value = sessionStorage.getItem(key); alert(key + &quot;=&quot; + value);&#125;//使用 delete 删除一个值——在 WebKit 中无效delete sessionStorage.name;//使用方法删除一个值sessionStorage.removeItem(&quot;book&quot;); 3. globalStorage 对象12345678910111213//保存数据globalStorage[&quot;wrox.com&quot;].name = &quot;Nicholas&quot;;//获取数据var name = globalStorage[&quot;wrox.com&quot;].name;/*在这里，访问的是针对域名 wrox.com 的存储空间。globalStorage 对象不是 Storage 的实例，而具体的 globalStorage[&quot;wrox.com&quot;]才是。这个存储空间对于 wrox.com 及其所有子域都是可以访问的。可以像下面这样指定子域名。*///保存数据globalStorage[&quot;www.wrox.com&quot;].name = &quot;Nicholas&quot;;//获取数据var name = globalStorage[&quot;www.wrox.com&quot;].name; 4.localStorage 对象localStorage 对象在修订过的 HTML 5 规范中作为持久保存客户端数据的方案取代了globalStorage。与 globalStorage 不同，不能给 localStorage 指定任何访问规则；规则事先就设定好了。要访问同一个 localStorage 对象，页面必须来自同一个域名（子域名无效），使用同一种协议，在同一个端口上。这相当于 globalStorage[location.host]。 5.Storage限制 对于 localStorage 而言，大多数桌面浏览器会设置每个来源 5MB 的限制。Chrome 和 Safari 对每个来源的限制是 2.5MB。而 iOS 版 Safari 和 Android 版 WebKit 的限制也是 2.5MB。对 sessionStorage 的限制也是因浏览器而异。有的浏览器对 sessionStorage 的大小没有限制，但 Chrome、Safari、iOS 版 Safari 和 Android 版 WebKit 都有限制，也都是 2.5MB。IE8+和 Opera 对sessionStorage 的限制是 5MB。 IndexedDB 数据库IndexedDB 就是一个数据库，与 MySQL 或 Web SQL Database 等这些你以前可能用过的数据库类似。IndexedDB 最大的特色是使用对象保存数据，而不是使用表来保存数据。一个 IndexedDB 数据库，就是一组位于相同命名空间下的对象的集合。123456789var request, database;request = indexedDB.open(&quot;admin&quot;);request.onerror = function(event)&#123; alert(&quot;Something bad happened while trying to open: &quot; + event.target.errorCode);&#125;;request.onsuccess = function(event)&#123; database = event.target.result;&#125;; 最 佳 实 践 / 代 码 风 格命名的一般规则如下所示。  变量名应为名词如 car 或 person。 函数名应该以动词开始，如 getName()。返回布尔类型值的函数一般以 is 开头，如isEnable()。 变量和函数都应使用合乎逻辑的名字，不要担心长度。长度问题可以通过后处理和压缩（本章后面会讲到）来缓解。 变量类型透明123456789101112131415161718//通过初始化指定变量类型var found = false; //布尔型var count = -1; //数字var name = &quot;&quot;; //字符串var person = null; //对象第二种方法是使用匈牙利标记法来指定变量类型。//用于指定数据类型的匈牙利标记法var bFound; //布尔型var iCount; //整数var sName; //字符串var oPerson; //对象//用于指定类型的类型注释var found /*:Boolean*/ = false;var count /*:int*/ = 10;var name /*:String*/ = &quot;Nicholas&quot;;var person /*:Object*/ = null; 解耦应用逻辑／事件处理程序12345678910111213141516171819function validateValue(value)&#123; value = 5 * parseInt(value); if (value &gt; 10)&#123; document.getElementById(&quot;error-msg&quot;).style.display = &quot;block&quot;; &#125;&#125;function handleKeyPress(event)&#123; event = EventUtil.getEvent(event); if (event.keyCode == 13)&#123; var target = EventUtil.getTarget(event); validateValue(target.value); &#125;&#125;以下是要牢记的应用和业务逻辑之间松散耦合的几条原则： 勿将 event 对象传给其他方法；只传来自 event 对象中所需的数据； 任何可以在应用层面的动作都应该可以在不执行任何事件处理程序的情况下进行； 任何事件处理程序都应该处理事件，然后将处理转交给应用逻辑。牢记这几条可以在任何代码中都获得极大的可维护性的改进，并且为进一步的测试和开发制造了很多可能。 避免全局量与尊重对象所有权密切相关的是尽可能避免全局变量和函数。这也关系到创建一个脚本执行的一致的和可维护的环境。最多创建一个全局变量，让其他对象和函数存在其中。请看以下例子： 1234567891011121314//两个全局量——避免！！var name = &quot;Nicholas&quot;;function sayName()&#123; alert(name);&#125;这段代码包含了两个全局量：变量 name 和函数 sayName()。其实可以创建一个包含两者的对象，如下例所示：//一个全局量——推荐var MyApplication = &#123; name: &quot;Nicholas&quot;, sayName: function()&#123; alert(this.name); &#125;&#125;; 避免与 null 进行比较1234567891011121314由于 JavaScript 不做任何自动的类型检查，所有它就成了开发人员的责任。因此，在 JavaScript 代码中其实很少进行类型检测。最常见的类型检测就是查看某个值是否为 null。但是，直接将值与 null比较是使用过度的，并且常常由于不充分的类型检查导致错误。看以下例子：function sortArray(values)&#123; if (values != null)&#123; //避免！ values.sort(comparator); &#125;&#125;比如数组，可以改造成function sortArray(values)&#123; if (values instanceof Array)&#123; //推荐 values.sort(comparator); &#125;&#125; 如果看到了与 null 比较的代码，尝试使用以下技术替换： 如果值应为一个引用类型，使用 instanceof 操作符检查其构造函数； 如果值应为一个基本类型，使用 typeof 检查其类型； 如果是希望对象包含某个特定的方法名，则使用 typeof 操作符确保指定名字的方法存在于对象上。代码中的 null 比较越少，就越容易确定代码的目的，并消除不必要的错误。 使用常量尽管 JavaScript 没有常量的正式概念，但它还是很有用的。这种将数据从应用逻辑分离出来的思想，可以在不冒引入错误的风险的同时，就改变数据。请看以下例子： 123456789101112131415161718function validate(value)&#123; if (!value)&#123; alert(&quot;Invalid value!&quot;); location.href = &quot;/errors/invalid.php&quot;; &#125;&#125;改成：var Constants = &#123; INVALID_VALUE_MSG: &quot;Invalid value!&quot;, INVALID_VALUE_URL: &quot;/errors/invalid.php&quot;&#125;;function validate(value)&#123; if (!value)&#123; alert(Constants.INVALID_VALUE_MSG); location.href = Constants.INVALID_VALUE_URL; &#125;&#125; 关键在于将数据和使用它的逻辑进行分离。要注意的值的类型如下所示。 重复值——任何在多处用到的值都应抽取为一个常量。这就限制了当一个值变了而另一个没变的时候会造成的错误。这也包含了 CSS 类名。 用户界面字符串 —— 任何用于显示给用户的字符串，都应被抽取出来以方便国际化。 URLs ——在 Web 应用中，资源位置很容易变更，所以推荐用一个公共地方存放所有的 URL。 任意可能会更改的值 —— 每当你在用到字面量值的时候，你都要问一下自己这个值在未来是不是会变化。如果答案是“是”，那么这个值就应该被提取出来作为一个常量。 作用域1.避免全局查找可能优化脚本性能最重要的就是注意全局查找。使用全局变量和函数肯定要比局部的开销更大，因为要涉及作用域链上的查找。请看以下函数： 123456789101112131415161718192021function updateUI()&#123; var imgs = document.getElementsByTagName(&quot;img&quot;); for (var i=0, len=imgs.length; i &lt; len; i++)&#123; imgs[i].title = document.title + &quot; image &quot; + i; &#125; var msg = document.getElementById(&quot;msg&quot;); msg.innerHTML = &quot;Update complete.&quot;;&#125;该函数可能看上去完全正常，但是它包含了三个对于全局 document 对象的引用。如果在页面上有多个图片，那么 for 循环中的 document 引用就会被执行多次甚至上百次，每次都会要进行作用域链查找。通过创建一个指向 document 对象的局部变量，就可以通过限制一次全局查找来改进这个函数的性能：function updateUI()&#123; var doc = document; var imgs = doc.getElementsByTagName(&quot;img&quot;); for (var i=0, len=imgs.length; i &lt; len; i++)&#123; imgs[i].title = doc.title + &quot; image &quot; + i; &#125; var msg = doc.getElementById(&quot;msg&quot;); msg.innerHTML = &quot;Update complete.&quot;;&#125; 1. 多个变量声明 有个地方很多开发人员都容易创建很多语句，那就是多个变量的声明。很容易看到代码中由多个var 语句来声明多个变量，如下所示：//4 个语句——很浪费var count = 5;var color = “blue”;var values = [1,2,3];var now = new Date();在强类型语言中，不同的数据类型的变量必须在不同的语句中声明。然而，在 JavaScript 中所有的变量都可以使用单个 var 语句来声明。前面的代码可以如下重写：//一个语句var count = 5, color = “blue”, values = [1,2,3], now = new Date();","categories":[],"tags":[{"name":"高程","slug":"高程","permalink":"https://vlwq.github.io/tags/%E9%AB%98%E7%A8%8B/"}]},{"title":"高程笔记7-JSON和ajax","slug":"2017/20170615","date":"2017-06-15T02:36:00.000Z","updated":"2017-07-16T04:23:32.286Z","comments":true,"path":"2017/06/15/2017/20170615/","link":"","permalink":"https://vlwq.github.io/2017/06/15/2017/20170615/","excerpt":"高程笔记7","text":"高程笔记7 语法 JSON 的语法可以表示以下三种类型的值。 简单值：使用与 JavaScript 相同的语法，可以在 JSON 中表示字符串、数值、布尔值和 null。但 JSON 不支持 JavaScript 中的特殊值 undefined。 对象：对象作为一种复杂数据类型，表示的是一组无序的键值对儿。而每个键值对儿中的值可以是简单值，也可以是复杂数据类型的值。 数组：数组也是一种复杂数据类型，表示一组有序的值的列表，可以通过数值索引来访问其中的值。数组的值也可以是任意类型——简单值、对象或数组。JSON 不支持变量、函数或对象实例，它就是一种表示结构化数据的格式，虽然与 JavaScript 中表示数据的某些语法相同，但它并不局限于 JavaScript 的范畴。 对象12345678910111213141516JSON 中的对象与 JavaScript 字面量稍微有一些不同。下面是一个 JavaScript 中的对象字面量：var person = &#123; name: &quot;Nicholas&quot;, age: 29&#125;;这虽然是开发人员在 JavaScript 中创建对象字面量的标准方式，但 JSON 中的对象要求给属性加引号。实际上，在 JavaScript 中，前面的对象字面量完全可以写成下面这样：var object = &#123; &quot;name&quot;: &quot;Nicholas&quot;, &quot;age&quot;: 29&#125;;JSON 表示上述对象的方式如下：&#123; &quot;name&quot;: &quot;Nicholas&quot;, &quot;age&quot;: 29&#125; JSON 对象有两个方法：stringify()和 parse()。在最简单的情况下，这两个方法分别用于把JavaScript 对象序列化为 JSON 字符串和把 JSON 字符串解析为原生 JavaScript 值。例如： 1234567891011121314151617181920212223242526272829var book = &#123; title: &quot;Professional JavaScript&quot;, authors: [ &quot;Nicholas C. Zakas&quot; ], edition: 3, year: 2011 &#125;;var jsonText = JSON.stringify(book);实际上，JSON.stringify()除了要序列化的 JavaScript 对象外，还可以接收另外两个参数，这两个参数用于指定以不同的方式序列化 JavaScript 对象。第一个参数是个过滤器，可以是一个数组，也可以是一个函数；第二个参数是一个选项，表示是否在 JSON 字符串中保留缩进。单独或组合使用这两个参数，可以更全面深入地控制 JSON 的序列化2. 字符串缩进JSON.stringify()方法的第三个参数用于控制结果中的缩进和空白符。如果这个参数是一个数值，那它表示的是每个级别缩进的空格数。例如，要在每个级别缩进 4 个空格，可以这样写代码：var book = &#123; &quot;title&quot;: &quot;Professional JavaScript&quot;, &quot;authors&quot;: [ &quot;Nicholas C. Zakas&quot; ], edition: 3, year: 2011 &#125;;var jsonText = JSON.stringify(book, null, 4); 解析选项123456789101112131415161718var book = &#123; &quot;title&quot;: &quot;Professional JavaScript&quot;, &quot;authors&quot;: [ &quot;Nicholas C. Zakas&quot; ], edition: 3, year: 2011, releaseDate: new Date(2011, 11, 1) &#125;;var jsonText = JSON.stringify(book);var bookCopy = JSON.parse(jsonText, function(key, value)&#123; if (key == &quot;releaseDate&quot;)&#123; return new Date(value); &#125; else &#123; return value; &#125; &#125;);alert(bookCopy.releaseDate.getFullYear()); ajaxXHR的用法 在使用 XHR 对象时，要调用的第一个方法是 open()，它接受 3 个参数：要发送的请求的类型（”get”、”post”等）、请求的 URL 和表示是否异步发送请求的布尔值。下面就是调用这个方法的例子。xhr.open(“get”, “example.php”, false);这行代码会启动一个针对 example.php 的 GET 请求。有关这行代码，需要说明两点：一是 URL相对于执行代码的当前页面（当然也可以使用绝对路径）；二是调用 open()方法并不会真正发送请求，而只是启动一个请求以备发送。 123要发送特定的请求，必须像下面这样调用 send()方法：xhr.open(&quot;get&quot;, &quot;example.txt&quot;, false);xhr.send(null); 在收到响应后，响应的数据会自动填充 XHR 对象的属性，相关的属性简介如下。  responseText：作为响应主体被返回的文本。 responseXML：如果响应的内容类型是”text/xml”或”application/xml”，这个属性中将保存包含着响应数据的 XML DOM 文档。 status：响应的 HTTP 状态。 statusText：HTTP 状态的说明 1234567xhr.open(&quot;get&quot;, &quot;example.txt&quot;, false);xhr.send(null);if ((xhr.status &gt;= 200 &amp;&amp; xhr.status &lt; 300) || xhr.status == 304)&#123; alert(xhr.responseText);&#125; else &#123; alert(&quot;Request was unsuccessful: &quot; + xhr.status);&#125; 但多数情况下，我们还是要发送异步请求，才能让JavaScript 继续执行而不必等待响应。此时，可以检测 XHR 对象的 readyState 属性，该属性表示请求/响应过程的当前活动阶段。这个属性可取的值如下。  0：未初始化。尚未调用 open()方法。 1：启动。已经调用 open()方法，但尚未调用 send()方法。 2：发送。已经调用 send()方法，但尚未接收到响应。 3：接收。已经接收到部分响应数据。 4：完成。已经接收到全部响应数据，而且已经可以在客户端使用了。 123456789101112var xhr = createXHR();xhr.onreadystatechange = function()&#123; if (xhr.readyState == 4)&#123; if ((xhr.status &gt;= 200 &amp;&amp; xhr.status &lt; 300) || xhr.status == 304)&#123; alert(xhr.responseText); &#125; else &#123; alert(&quot;Request was unsuccessful: &quot; + xhr.status); &#125; &#125;&#125;;xhr.open(&quot;get&quot;, &quot;example.txt&quot;, true);xhr.send(null); HTTP头部信息 默认情况下，在发送 XHR 请求的同时，还会发送下列头部信息。 Accept：浏览器能够处理的内容类型。 Accept-Charset：浏览器能够显示的字符集。 Accept-Encoding：浏览器能够处理的压缩编码。 Accept-Language：浏览器当前设置的语言。 Connection：浏览器与服务器之间连接的类型。 Cookie：当前页面设置的任何 Cookie。 Host：发出请求的页面所在的域 。 Referer：发出请求的页面的 URI。注意，HTTP 规范将这个头部字段拼写错了，而为保证与规范一致，也只能将错就错了。（这个英文单词的正确拼法应该是 referrer。） User-Agent：浏览器的用户代理字符串 虽然不同浏览器实际发送的头部信息会有所不同，但以上列出的基本上是所有浏览器都会发送的。使用 setRequestHeader()方法可以设置自定义的请求头部信息。这个方法接受两个参数：头部字段的名称和头部字段的值。要成功发送请求头部信息，必须在调用 open()方法之后且调用 send()方法之前调用 setRequestHeader() GET请求1234567891011使用 GET 请求经常会发生的一个错误，就是查询字符串的格式有问题。查询字符串中每个参数的名称和值都必须使用 encodeURIComponent()进行编码，然后才能放到 URL 的末尾；而且所有名-值对儿都必须由和号（&amp;）分隔，如下面的例子所示。xhr.open(&quot;get&quot;, &quot;example.php?name1=value1&amp;name2=value2&quot;, true);下面这个函数可以辅助向现有 URL 的末尾添加查询字符串参数：function addURLParam(url, name, value) &#123; url += (url.indexOf(&quot;?&quot;) == -1 ? &quot;?&quot; : &quot;&amp;&quot;); url += encodeURIComponent(name) + &quot;=&quot; + encodeURIComponent(value); return url;&#125; post请求1234xhr.open(&quot;post&quot;, &quot;example.php&quot;, true);发送 POST 请求的第二步就是向 send()方法中传入某些数据。由于 XHR 最初的设计主要是为了处理 XML，因此可以在此传入 XML DOM 文档，传入的文档经序列化之后将作为请求主体被提交到服务器。当然，也可以在此传入任何想发送到服务器的字符串。 XMLHttpRequest 2 级 现代 Web 应用中频繁使用的一项功能就是表单数据的序列化，XMLHttpRequest 2 级为此定义了FormData 类型。FormData 为序列化表单以及创建与表单格式相同的数据（用于通过 XHR 传输）提供了便利。下面的代码创建了一个 FormData 对象，并向其中添加了一些数据。var data = new FormData();data.append(“name”, “Nicholas”);这个 append()方法接收两个参数：键和值，分别对应表单字段的名字和字段中包含的值。可以像这样添加任意多个键值对儿。而通过向 FormData 构造函数中传入表单元素，也可以用表单元素的数据预先向其中填入键值对儿：var data = new FormData(document.forms[0]); 超时设定12345678910111213141516171819202122var xhr = createXHR();xhr.onreadystatechange = function()&#123; if (xhr.readyState == 4)&#123; try &#123; if ((xhr.status &gt;= 200 &amp;&amp; xhr.status &lt; 300) || xhr.status == 304)&#123; alert(xhr.responseText); &#125; else &#123; alert(&quot;Request was unsuccessful: &quot; + xhr.status); &#125; &#125; catch (ex)&#123; //假设由 ontimeout 事件处理程序处理 &#125; &#125;&#125;;xhr.open(&quot;get&quot;, &quot;timeout.php&quot;, true);xhr.timeout = 1000; //将超时设置为 1 秒钟（仅适用于 IE8+）xhr.ontimeout = function()&#123; alert(&quot;Request did not return in a second.&quot;);&#125;;xhr.send(null);在写作本书时，IE 8+仍然是唯一支持超时设定的浏览器。 overrideMimeType()方法1234567比如，服务器返回的 MIME 类型是 text/plain，但数据中实际包含的是 XML。根据 MIME 类型，即使数据是 XML，responseXML 属性中仍然是 null。通过调用 overrideMimeType()方法，可以保证把响应当作 XML 而非纯文本来处理。var xhr = createXHR();xhr.open(&quot;get&quot;, &quot;text.php&quot;, true);xhr.overrideMimeType(&quot;text/xml&quot;);xhr.send(null); progress事件 Mozilla 对 XHR 的另一个革新是添加了 progress 事件，这个事件会在浏览器接收新数据期间周期性地触发。而 onprogress 事件处理程序会接收到一个 event 对象，其 target 属性是 XHR 对象，但包含着三个额外的属性：lengthComputable、position 和 totalSize。其中，lengthComputable是一个表示进度信息是否可用的布尔值，position 表示已经接收的字节数，totalSize 表示根据Content-Length 响应头部确定的预期字节数。有了这些信息，我们就可以为用户创建一个进度指示器了。下面展示了为用户创建进度指示器的一个示例。 123456789101112131415161718var xhr = createXHR();xhr.onload = function(event)&#123; if ((xhr.status &gt;= 200 &amp;&amp; xhr.status &lt; 300) || xhr.status == 304)&#123; alert(xhr.responseText); &#125; else &#123; alert(&quot;Request was unsuccessful: &quot; + xhr.status); &#125;&#125;;xhr.onprogress = function(event)&#123; var divStatus = document.getElementById(&quot;status&quot;); if (event.lengthComputable)&#123; divStatus.innerHTML = &quot;Received &quot; + event.position + &quot; of &quot; + event.totalSize +&quot; bytes&quot;; &#125;&#125;;xhr.open(&quot;get&quot;, &quot;altevents.php&quot;, true);xhr.send(null); 跨域 如果服务器认为这个请求可以接受，就在 Access-Control-Allow-Origin 头部中回发相同的源信息（如果是公共资源，可以回发”*”）。例如：Access-Control-Allow-Origin: http://www.nczonline.net如果没有这个头部，或者有这个头部但源信息不匹配，浏览器就会驳回请求。正常情况下，浏览器会处理请求。注意，请求和响应都不包含 cookie 信息。 123456789101112131415Firefox 3.5+、Safari 4+、Chrome、iOS 版 Safari 和 Android 平台中的 WebKit 都通过 XMLHttpRequest对象实现了对 CORS 的原生支持。在尝试打开不同来源的资源时，无需额外编写代码就可以触发这个行为。要请求位于另一个域中的资源，使用标准的 XHR 对象并在 open()方法中传入绝对 URL 即可，例如：var xhr = createXHR();xhr.onreadystatechange = function()&#123; if (xhr.readyState == 4)&#123; if ((xhr.status &gt;= 200 &amp;&amp; xhr.status &lt; 300) || xhr.status == 304)&#123; alert(xhr.responseText); &#125; else &#123; alert(&quot;Request was unsuccessful: &quot; + xhr.status); &#125; &#125;&#125;;xhr.open(&quot;get&quot;, &quot;http://www.somewhere-else.com/page/&quot;, true);xhr.send(null); 跨浏览器的CORS123456789101112131415161718function createCORSRequest(method, url)&#123; var xhr = new XMLHttpRequest(); if (&quot;withCredentials&quot; in xhr)&#123; xhr.open(method, url, true); &#125; else if (typeof XDomainRequest != &quot;undefined&quot;)&#123; vxhr = new XDomainRequest(); xhr.open(method, url); &#125; else &#123; xhr = null; &#125; return xhr;&#125;var request = createCORSRequest(&quot;get&quot;, &quot;http://www.somewhere-else.com/page/&quot;);if (request)&#123; request.onload = function()&#123; //对 request.responseText 进行处理 &#125;; request.send(); Firefox、Safari 和 Chrome 中的 XMLHttpRequest 对象与 IE 中的 XDomainRequest 对象类似，都提供了够用的接口，因此以上模式还是相当有用的。这两个对象共同的属性/方法如下。 abort()：用于停止正在进行的请求。 onerror：用于替代 onreadystatechange 检测错误。 onload：用于替代 onreadystatechange 检测成功。 responseText：用于取得响应内容。 send()：用于发送请求。以上成员都包含在 createCORSRequest()函数返回的对象中，在所有浏览器中都能正常使用。 JSONP JSONP 是 JSON with padding（填充式 JSON 或参数式 JSON）的简写，是应用 JSON 的一种新方法，在后来的 Web 服务中非常流行。JSONP 看起来与 JSON 差不多，只不过是被包含在函数调用中的 JSON，就像下面这样。callback({ “name”: “Nicholas” });JSONP 由两部分组成：回调函数和数据。回调函数是当响应到来时应该在页面中调用的函数。回调函数的名字一般是在请求中指定的。而数据就是传入回调函数中的JSON数据。下面是一个典型的JSONP请求。http://freegeoip.net/json/?callback=handleResponse Web Sockets 要说最令人津津乐道的新浏览器 API，就得数 Web Sockets 了。Web Sockets 的目标是在一个单独的持久连接上提供全双工、双向通信。在 JavaScript 中创建了 Web Socket 之后，会有一个 HTTP 请求发送到浏览器以发起连接。在取得服务器响应后，建立的连接会使用 HTTP 升级从 HTTP 协议交换为 WebSocket 协议。也就是说，使用标准的 HTTP 服务器无法实现 Web Sockets，只有支持这种协议的专门服务器才能正常工作。由于 Web Sockets 使用了自定义的协议，所以 URL 模式也略有不同。未加密的连接不再是 http://，而是 ws://；加密的连接也不是 https://，而是 wss://。在使用 Web Socket URL 时，必须带着这个模式，因为将来还有可能支持其他模式。 12345678910111213141516171819202122232425262728293031323334353637383940414243444546471. Web Sockets API要创建 Web Socket，先实例一个 WebSocket 对象并传入要连接的 URL：var socket = new WebSocket(&quot;ws://www.example.com/server.php&quot;);注意，必须给 WebSocket 构造函数传入绝对 URL。同源策略对 Web Sockets 不适用，因此可以通过它打开到任何站点的连接。至于是否会与某个域中的页面通信，则完全取决于服务器。（通过握手信息就可以知道请求来自何方。）实例化了 WebSocket 对象后，浏览器就会马上尝试创建连接。与 XHR 类似，WebSocket 也有一个表示当前状态的 readyState 属性。不过，这个属性的值与 XHR 并不相同，而是如下所示。 WebSocket.OPENING (0)：正在建立连接。 WebSocket.OPEN (1)：已经建立连接。 WebSocket.CLOSING (2)：正在关闭连接。 WebSocket.CLOSE (3)：已经关闭连接。WebSocket 没有 readystatechange 事件；不过，它有其他事件，对应着不同的状态。readyState的值永远从 0 开始。要关闭 Web Socket 连接，可以在任何时候调用 close()方法。socket.close();调用了 close()之后，readyState 的值立即变为 2（正在关闭），而在关闭连接后就会变成 3。2. 发送和接收数据因为 Web Sockets 只能通过连接发送纯文本数据，所以对于复杂的数据结构，在通过连接发送之前，必须进行序列化。下面的例子展示了先将数据序列化为一个 JSON 字符串，然后再发送到服务器：var message = &#123; time: new Date(), text: &quot;Hello world!&quot;, clientId: &quot;asdfp8734rew&quot;&#125;;socket.send(JSON.stringify(message));接下来，服务器要读取其中的数据，就要解析接收到的 JSON 字符串。当服务器向客户端发来消息时，WebSocket 对象就会触发 message 事件。这个 message 事件与其他传递消息的协议类似，也是把返回的数据保存在 event.data 属性中。socket.onmessage = function(event)&#123; var data = event.data; //处理数据&#125;;与通过 send()发送到服务器的数据一样，event.data 中返回的数据也是字符串。如果你想得到其他格式的数据，必须手工解析这些数据。3.其他事件WebSocket 对象还有其他三个事件，在连接生命周期的不同阶段触发。 open：在成功建立连接时触发。 error：在发生错误时触发，连接不能持续。 close：在连接关闭时触发 总结 Ajax 是无需刷新页面就能够从服务器取得数据的一种方法。关于 Ajax，可以从以下几方面来总结一下。 负责 Ajax 运作的核心对象是 XMLHttpRequest（XHR）对象。 XHR 对象由微软最早在 IE5 中引入，用于通过 JavaScript 从服务器取得 XML 数据。 在此之后，Firefox、Safari、Chrome 和 Opera 都实现了相同的特性，使 XHR 成为了 Web 的一个事实标准。 虽然实现之间存在差异，但 XHR 对象的基本用法在不同浏览器间还是相对规范的，因此可以放心地用在 Web 开发当中。同源策略是对 XHR 的一个主要约束，它为通信设置了“相同的域、相同的端口、相同的协议”这一限制。试图访问上述限制之外的资源，都会引发安全错误，除非采用被认可的跨域解决方案。这个解决方案叫做 CORS（Cross-Origin Resource Sharing，跨源资源共享），IE8 通过 XDomainRequest 对象支持CORS，其他浏览器通过 XHR 对象原生支持 CORS。图像 Ping 和 JSONP 是另外两种跨域通信的技术，但不如 CORS 稳妥。Comet 是对 Ajax 的进一步扩展，让服务器几乎能够实时地向客户端推送数据。实现 Comet 的手段主要有两个：长轮询和 HTTP 流。所有浏览器都支持长轮询，而只有部分浏览器原生支持 HTTP 流。SSE（Server-Sent Events，服务器发送事件）是一种实现 Comet 交互的浏览器 API，既支持长轮询，也支持HTTP 流。Web Sockets 是一种与服务器进行全双工、双向通信的信道。与其他方案不同，Web Sockets 不使用HTTP 协议，而使用一种自定义的协议。这种协议专门为快速传输小数据设计。虽然要求使用不同的Web 服务器，但却具有速度上的优势。各方面对 Ajax 和 Comet 的鼓吹吸引了越来越多的开发人员学习 JavaScript，人们对 Web 开发的关注也再度升温。与 Ajax 有关的概念都还相对比较新，这些概念会随着时间推移继续发展。","categories":[],"tags":[{"name":"高程","slug":"高程","permalink":"https://vlwq.github.io/tags/%E9%AB%98%E7%A8%8B/"}]},{"title":"高程笔记6-表单知识","slug":"2017/20170614","date":"2017-06-14T02:36:00.000Z","updated":"2017-07-16T04:22:22.325Z","comments":true,"path":"2017/06/14/2017/20170614/","link":"","permalink":"https://vlwq.github.io/2017/06/14/2017/20170614/","excerpt":"高程笔记6","text":"高程笔记6 表单的基础知识在 HTML 中，表单是由元素来表示的，而在 JavaScript 中，表单对应的则是 HTMLFormElement类型。HTMLFormElement 继承了 HTMLElement，因而与其他 HTML 元素具有相同的默认属性。不过，HTMLFormElement 也有它自己下列独有的属性和方法。  acceptCharset：服务器能够处理的字符集；等价于 HTML 中的 accept-charset 特性。 action：接受请求的 URL；等价于 HTML 中的 action 特性。 elements：表单中所有控件的集合（HTMLCollection）。 enctype：请求的编码类型；等价于 HTML 中的 enctype 特性。 length：表单中控件的数量。 method：要发送的 HTTP 请求类型，通常是”get”或”post”；等价于 HTML 的 method 特性。 name：表单的名称；等价于 HTML 的 name 特性。 reset()：将所有表单域重置为默认值。 submit()：提交表单。 target：用于发送请求和接收响应的窗口名称；等价于 HTML 的 target 特性 12345678910111213提交表单&lt;!-- 通用提交按钮 --&gt;&lt;input type=&quot;submit&quot; value=&quot;Submit Form&quot;&gt;&lt;!-- 自定义提交按钮 --&gt;&lt;button type=&quot;submit&quot;&gt;Submit Form&lt;/button&gt;&lt;!-- 图像按钮 --&gt;&lt;input type=&quot;image&quot; src=&quot;graphic.gif&quot;&gt;&lt;!-- 通用重置按钮 --&gt;&lt;input type=&quot;reset&quot; value=&quot;Reset Form&quot;&gt;&lt;!-- 自定义重置按钮 --&gt;&lt;button type=&quot;reset&quot;&gt;Reset Form&lt;/button&gt; 表单共有的表单字段属性除了元素之外，所有表单字段都拥有相同的一组属性。由于类型可以表示多种表单字段，因此有些属性只适用于某些字段，但还有一些属性是所有字段所共有的。表单字段共有的属性如下。  disabled：布尔值，表示当前字段是否被禁用。 form：指向当前字段所属表单的指针；只读。 name：当前字段的名称。 readOnly：布尔值，表示当前字段是否只读。 tabIndex：表示当前字段的切换（tab）序号。 type：当前字段的类型，如”checkbox”、”radio”，等等。 value：当前字段将被提交给服务器的值。对文件字段来说，这个属性是只读的，包含着文件在计算机中的路径。 123456789//避免多次提交表单EventUtil.addHandler(form, &quot;submit&quot;, function(event)&#123; event = EventUtil.getEvent(event); var target = EventUtil.getTarget(event); //取得提交按钮 var btn = target.elements[&quot;submit-btn&quot;]; //禁用它 btn.disabled = true;&#125;); 除了之外，所有表单字段都有 type 属性。对于元素，这个值等于 HTML 特性 type 的值。对于其他元素，这个 type 属性的值如下表所列.此外，和元素的 type 属性是可以动态修改的，而元素的 type 属性则是只读的。 2. 共有的表单字段方法每个表单字段都有两个方法：focus()和 blur()。其中，focus()方法用于将浏览器的焦点设置到表单字段，即激活表单字段，使其可以响应键盘事件 3. 共有的表单字段事件除了支持鼠标、键盘、更改和 HTML 事件之外，所有表单字段都支持下列 3 个事件。 1234 blur：当前字段失去焦点时触发。 change：对于&lt;input&gt;和&lt;textarea&gt;元素，在它们失去焦点且 value 值改变时触发；对于&lt;select&gt;元素，在其选项改变时触发 focus：当前字段获得焦点时触发。 文本框脚本1234567&lt;textarea&gt;元素则始终会呈现为一个多行文本框。要指定文本框的大小，可以使用 rows和 cols 特性。其中，rows 特性指定的是文本框的字符行数，而 cols 特性指定的是文本框的字符列数（类似于&lt;inpu&gt;元素的 size 特性）。与&lt;input&gt;元素不同，&lt;textarea&gt;的初始值必须要放在&lt;textarea&gt;和&lt;/textarea&gt;之间，如下面的例子所示。&lt;textarea rows=&quot;25&quot; cols=&quot;5&quot;&gt;initial value&lt;/textarea&gt;注意： 在处理文本框的值时，最好不要使用 DOM 方法。 过滤输入123456789例如，下列代码只允许用户输入数值。EventUtil.addHandler(textbox, &quot;keypress&quot;, function(event)&#123; event = EventUtil.getEvent(event); var target = EventUtil.getTarget(event); var charCode = EventUtil.getCharCode(event); if (!/\\d/.test(String.fromCharCode(charCode)))&#123; EventUtil.preventDefault(event); &#125;&#125;); 自动切换焦点1234567891011121314151617181920212223242526272829&lt;input type=&quot;text&quot; name=&quot;tel1&quot; id=&quot;txtTel1&quot; maxlength=&quot;3&quot;&gt;&lt;input type=&quot;text&quot; name=&quot;tel2&quot; id=&quot;txtTel2&quot; maxlength=&quot;3&quot;&gt;&lt;input type=&quot;text&quot; name=&quot;tel3&quot; id=&quot;txtTel3&quot; maxlength=&quot;4&quot;&gt;(function()&#123; function tabForward(event)&#123; event = EventUtil.getEvent(event); var target = EventUtil.getTarget(event); if (target.value.length == target.maxLength)&#123; var form = target.form; for (var i=0, len=form.elements.length; i &lt; len; i++) &#123; if (form.elements[i] == target) &#123; if (form.elements[i+1])&#123; form.elements[i+1].focus(); &#125; return; &#125; &#125; &#125; &#125; var textbox1 = document.getElementById(&quot;txtTel1&quot;); var textbox2 = document.getElementById(&quot;txtTel2&quot;); var textbox3 = document.getElementById(&quot;txtTel3&quot;); EventUtil.addHandler(textbox1, &quot;keyup&quot;, tabForward); EventUtil.addHandler(textbox2, &quot;keyup&quot;, tabForward); EventUtil.addHandler(textbox3, &quot;keyup&quot;, tabForward);&#125;)(); HTML5 约束验证API1234567891011121314151617181920212223242526272829303132333435361. 必填字段第一种情况是在表单字段中指定了 required 属性，如下面的例子所示：&lt;input type=&quot;text&quot; name=&quot;username&quot; required&gt;2. 其他输入类型HTML5 为&lt;input&gt;元素的 type 属性又增加了几个值。这些新的类型不仅能反映数据类型的信息，而且还能提供一些默认的验证功能。其中，&quot;email&quot;和&quot;url&quot;是两个得到支持最多的类型，各浏览器也都为它们增加了定制的验证机制。例如：&lt;input type=&quot;email&quot; name =&quot;email&quot;&gt;&lt;input type=&quot;url&quot; name=&quot;homepage&quot;&gt;3. 数值范围除了&quot;email&quot;和&quot;url&quot;，HTML5还定义了另外几个输入元素。这几个元素都要求填写某种基于数字的值：&quot;number&quot;、&quot;range&quot;、&quot;datetime&quot;、&quot;datetime-local&quot;、&quot;date&quot;、&quot;month&quot;、&quot;week&quot;，还有&quot;time&quot;。浏览器对这几个类型的支持情况并不好，对所有这些数值类型的输入元素，可以指定 min 属性（最小的可能值）、max 属性（最大的可能值）和 step 属性（从 min 到 max 的两个刻度间的差值）。例如，想让用户只能输入 0 到 100 的值，而且这个值必须是 5 的倍数，可以这样写代码：&lt;input type=&quot;number&quot; min=&quot;0&quot; max=&quot;100&quot; step=&quot;5&quot; name=&quot;count&quot;&gt;4. 输入模式HTML5 为文本字段新增了 pattern 属性。这个属性的值是一个正则表达式，用于匹配文本框中的值。例如，如果只想允许在文本字段中输入数值，可以像下面的代码一样应用约束：&lt;input type=&quot;text&quot; pattern=&quot;\\d+&quot; name=&quot;count&quot;&gt;5. 检测有效性使用 checkValidity()方法可以检测表单中的某个字段是否有效。所有表单字段都有个方法，如果字段的值有效，这个方法返回 true，否则返回 false。字段的值是否有效的判断依据是本节前面介绍过的那些约束。6. 禁用验证通过设置 novalidate 属性，可以告诉表单不进行验证。&lt;form method=&quot;post&quot; action=&quot;signup.php&quot; novalidate&gt; &lt;!--这里插入表单元素--&gt;&lt;/form&gt; 选择框脚本选择框是通过和元素创建的。为了方便与这个控件交互，除了所有表单字段共有的属性和方法外，HTMLSelectElement 类型还提供了下列属性和方法。 12345678910111213141516171819202122232425 add(newOption, relOption)：向控件中插入新&lt;option&gt;元素，其位置在相关项（relOption）之前。 multiple：布尔值，表示是否允许多项选择；等价于 HTML 中的 multiple 特性。 options：控件中所有&lt;option&gt;元素的 HTMLCollection。 remove(index)：移除给定位置的选项。 selectedIndex：基于 0 的选中项的索引，如果没有选中项，则值为-1。对于支持多选的控件，只保存选中项中第一项的索引。 size：选择框中可见的行数；等价于 HTML 中的 size 特性。选择框的 type 属性不是&quot;select-one&quot;，就是&quot;select-multiple&quot;，这取决于 HTML 代码中有没有 multiple 特性。选择框的 value 属性由当前选中项决定，相应规则如下。 如果没有选中的项，则选择框的 value 属性保存空字符串。 如果有一个选中项，而且该项的 value 特性已经在 HTML 中指定，则选择框的 value 属性等于选中项的 value 特性。即使 value 特性的值是空字符串，也同样遵循此条规则。 如果有一个选中项，但该项的 value 特性在 HTML 中未指定，则选择框的 value 属性等于该项的文本。 如果有多个选中项，则选择框的 value 属性将依据前两条规则取得第一个选中项的值。以下面的选择框为例：&lt;select name=&quot;location&quot; id=&quot;selLocation&quot;&gt; &lt;option value=&quot;Sunnyvale, CA&quot;&gt;Sunnyvale&lt;/option&gt; &lt;option value=&quot;Los Angeles, CA&quot;&gt;Los Angeles&lt;/option&gt; &lt;option value=&quot;Mountain View, CA&quot;&gt;Mountain View&lt;/option&gt; &lt;option value=&quot;&quot;&gt;China&lt;/option&gt; &lt;option&gt;Australia&lt;/option&gt;&lt;/select&gt; 在 DOM 中，每个&lt;option&gt;元素都有一个 HTMLOptionElement 对象表示。为便于访问数据，HTMLOptionElement 对象添加了下列属性： 123456789 index：当前选项在 options 集合中的索引。 label：当前选项的标签；等价于 HTML 中的 label 特性。 selected：布尔值，表示当前选项是否被选中。将这个属性设置为 true 可以选中当前选项。 text：选项的文本。 value：选项的值（等价于 HTML 中的 value 特性）//推荐var text = selectbox.options[0].text; //选项的文本var value = selectbox.options[0].value; //选项的值 移动和重排选项 123var selectbox1 = document.getElementById(&quot;selLocations1&quot;);var selectbox2 = document.getElementById(&quot;selLocations2&quot;);selectbox2.appendChild(selectbox1.options[0]); 表单序列化12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758function serialize(form)&#123; var parts = [], field = null, i, len, j, optLen, option, optValue; for (i=0, len=form.elements.length; i &lt; len; i++)&#123; field = form.elements[i]; switch(field.type)&#123; case &quot;select-one&quot;: case &quot;select-multiple&quot;: if (field.name.length)&#123; for (j=0, optLen = field.options.length; j &lt; optLen; j++)&#123; option = field.options[j]; if (option.selected)&#123; optValue = &quot;&quot;; if (option.hasAttribute)&#123; optValue = (option.hasAttribute(&quot;value&quot;) ? option.value : option.text); &#125; else &#123; optValue = (option.attributes[&quot;value&quot;].specified ? option.value : option.text); &#125; parts.push(encodeURIComponent(field.name) + &quot;=&quot; + encodeURIComponent(optValue)); &#125; &#125; &#125; break; case undefined: //字段集 case &quot;file&quot;: //文件输入 case &quot;submit&quot;: //提交按钮 case &quot;reset&quot;: //重置按钮 case &quot;button&quot;: //自定义按钮 break; case &quot;radio&quot;: //单选按钮 case &quot;checkbox&quot;: //复选框 if (!field.checked)&#123; break; &#125; /* 执行默认操作 */ default: //不包含没有名字的表单字段 if (field.name.length)&#123; parts.push(encodeURIComponent(field.name) + &quot;=&quot; + encodeURIComponent(field.value)); &#125; &#125; &#125; return parts.join(&quot;&amp;&quot;);&#125; 跨域问题 跨文档消息传递跨文档消息传送（cross-document messaging），有时候简称为 XDM，指的是在来自不同域的页面间传递消息。例如，www.wrox.com 域中的页面与位于一个内嵌框架中的 p2p.wrox.com 域中的页面通信。在 XDM 机制出现之前，要稳妥地实现这种通信需要花很多工夫。XDM 把这种机制规范化，让我们能既稳妥又简单地实现跨文档通信。 12345678910postMessage()方法接收两个参数：一条消息和一个表示消息接收方来自哪个域的字符串。第二个参数对保障安全通信非常重要，可以防止浏览器把消息发送到不安全的地方。来看下面的例子。//注意：所有支持 XDM 的浏览器也支持 iframe 的 contentWindow 属性var iframeWindow = document.getElementById(&quot;myframe&quot;).contentWindow;iframeWindow.postMessage(&quot;A secret&quot;, &quot;http://www.wrox.com&quot;);使用 postMessage()时，最好还是只传字符串。如果你想传入结构化的数据，最佳选择是先在要传入的数据上调用 JSON.stringify()，通过 postMessage()传入得到的字符串，然后再在 onmessage 事件处理程序中调用 JSON.parse()。 可拖动1234&lt;!-- 让这个图像不可以拖动 --&gt;&lt;img src=&quot;smile.gif&quot; draggable=&quot;false&quot; alt=&quot;Smiley face&quot;&gt;&lt;!-- 让这个元素可以拖动 --&gt;&lt;div draggable=&quot;true&quot;&gt;...&lt;/div&gt; 媒体元素123456789随着音频和视频在 Web 上的迅速流行，大多数提供富媒体内容的站点为了保证跨浏览器兼容性，不得不选择使用 Flash。HTML5 新增了两个与媒体相关的标签，让开发人员不必依赖任何插件就能在网页中嵌入跨浏览器的音频和视频内容。这两个标签就是&lt;audio&gt;和&lt;video&gt;。这两个标签除了能让开发人员方便地嵌入媒体文件之外，都提供了用于实现常用功能的 JavaScriptAPI，允许为媒体创建自定义的控件。这两个元素的用法如下。&lt;!-- 嵌入视频 --&gt;&lt;video src=&quot;conference.mpg&quot; id=&quot;myVideo&quot;&gt;Video player not available.&lt;/video&gt;&lt;!-- 嵌入音频 --&gt;&lt;audio src=&quot;song.mp3&quot; id=&quot;myAudio&quot;&gt;Audio player not available.&lt;/audio&gt; history对象12345678910111213141516history.pushState(&#123;name:&quot;Nicholas&quot;&#125;, &quot;Nicholas&#x27; page&quot;, &quot;nicholas.html&quot;);执行 pushState()方法后，新的状态信息就会被加入历史状态栈，而浏览器地址栏也会变成新的相对 URL。但是，浏览器并不会真的向服务器发送请求，即使状态改变之后查询 location.href 也会返回与地址栏中相同的地址。另外，第二个参数目前还没有浏览器实现，因此完全可以只传入一个空字符串，或者一个短标题也可以。而第一个参数则应该尽可能提供初始化页面状态所需的各种信息。因为 pushState()会创建新的历史状态，所以你会发现“后退”按钮也能使用了。按下“后退”按钮，会触发 window 对象的 popstate 事件①。popstate 事件的事件对象有一个 state 属性，这个属性就包含着当初以第一个参数传递给 pushState()的状态对象。EventUtil.addHandler(window, &quot;popstate&quot;, function(event)&#123; var state = event.state; if (state)&#123; //第一个页面加载时 state 为空 processState(state); &#125;&#125;);要更新当前状态，可以调用 replaceState()，传入的参数与 pushState()的前两个参数相同。调用这个方法不会在历史状态栈中创建新状态，只会重写当前状态。history.replaceState(&#123;name:&quot;Greg&quot;&#125;, &quot;Greg&#x27;s page&quot;);","categories":[],"tags":[{"name":"高程","slug":"高程","permalink":"https://vlwq.github.io/tags/%E9%AB%98%E7%A8%8B/"}]},{"title":"高程笔记5-事件","slug":"2017/20170613","date":"2017-06-13T02:36:00.000Z","updated":"2017-07-16T04:21:14.746Z","comments":true,"path":"2017/06/13/2017/20170613/","link":"","permalink":"https://vlwq.github.io/2017/06/13/2017/20170613/","excerpt":"高程笔记5","text":"高程笔记5 事件冒泡IE 的事件流叫做事件冒泡（event bubbling），即事件开始时由最具体的元素（文档中嵌套层次最深的那个节点）接收，然后逐级向上传播到较为不具体的节点（文档）。以下面的 HTML 页面为例： 1234567891011121314151617&lt;!DOCTYPE html&gt;&lt;html&gt;&lt;head&gt; &lt;title&gt;Event Bubbling Example&lt;/title&gt;&lt;/head&gt;&lt;body&gt; &lt;div id=&quot;myDiv&quot;&gt;Click Me&lt;/div&gt;&lt;/body&gt;&lt;/html&gt;如果你单击了页面中的&lt;div&gt;元素，那么这个 click 事件会按照如下顺序传播：(1) &lt;div&gt;(2) &lt;body&gt;(3) &lt;html&gt;(4) document也就是说，click 事件首先在&lt;div&gt;元素上发生，而这个元素就是我们单击的元素。然后，click事件沿 DOM 树向上传播，在每一级节点上都会发生，直至传播到 document 对象。图 13-1 展示了事件冒泡的过程。 事件捕获12345678910Netscape Communicator 团队提出的另一种事件流叫做事件捕获（event capturing）。事件捕获的思想是不太具体的节点应该更早接收到事件，而最具体的节点应该最后接收到事件。事件捕获的用意在于在事件到达预定目标之前捕获它。如果仍以前面的 HTML 页面作为演示事件捕获的例子，那么单击&lt;div&gt;元素就会以下列顺序触发 click 事件。(1) document(2) &lt;html&gt;(3) &lt;body&gt;(4) &lt;div&gt;在事件捕获过程中，document 对象首先接收到 click 事件，然后事件沿 DOM 树依次向下，一直传播到事件的实际目标，即&lt;div&gt;元素。 HTML事件处理程序12345678910111213在 HTML 中定义的事件处理程序可以包含要执行的具体动作，也可以调用在页面其他地方定义的脚本，如下面的例子所示：&lt;script type=&quot;text/javascript&quot;&gt; function showMessage()&#123; alert(&quot;Hello world!&quot;); &#125;&lt;/script&gt;&lt;input type=&quot;button&quot; value=&quot;Click Me&quot; onclick=&quot;showMessage()&quot; /&gt;通过 HTML 指定事件处理程序的最后一个缺点是 HTML 与 JavaScript 代码紧密耦合。如果要更换事件处理程序，就要改动两个地方：HTML 代码和 JavaScript 代码。而这正是许多开发人员摒弃 HTML 事件处理程序，转而使用 JavaScript 指定事件处理程序的原因所在。 DOM2 级事件处理程序 “DOM2级事件”定义了两个方法，用于处理指定和删除事件处理程序的操作：addEventListener()和 removeEventListener()。所有 DOM 节点中都包含这两个方法，并且它们都接受 3 个参数：要处理的事件名、作为事件处理程序的函数和一个布尔值。最后这个布尔值参数如果是 true，表示在捕获阶段调用事件处理程序；如果是 false，表示在冒泡阶段调用事件处理程序。要在按钮上为 click 事件添加事件处理程序，可以使用下列代码： 1234567891011121314151617var btn = document.getElementById(&quot;myBtn&quot;);btn.addEventListener(&quot;click&quot;, function()&#123; alert(this.id);&#125;, false);上面的代码为一个按钮添加了 onclick 事件处理程序，而且该事件会在冒泡阶段被触发（因为最后一个参数是 false）。与 DOM0 级方法一样，这里添加的事件处理程序也是在其依附的元素的作用域中运行。//移除removeEventListener，函数不能匿名var btn = document.getElementById(&quot;myBtn&quot;);var handler = function()&#123; alert(this.id);&#125;;btn.addEventListener(&quot;click&quot;, handler, false);//这里省略了其他代码btn.removeEventListener(&quot;click&quot;, handler, false); //有效！ 事件类型 Web 浏览器中可能发生的事件有很多类型。如前所述，不同的事件类型具有不同的信息，而“DOM3级事件”规定了以下几类事件。 12345678910 UI（User Interface，用户界面）事件，当用户与页面上的元素交互时触发； 焦点事件，当元素获得或失去焦点时触发； 鼠标事件，当用户通过鼠标在页面上执行操作时触发； 滚轮事件，当使用鼠标滚轮（或类似设备）时触发； 文本事件，当在文档中输入文本时触发； 键盘事件，当用户通过键盘在页面上执行操作时触发； 合成事件，当为 IME（Input Method Editor，输入法编辑器）输入字符时触发； 变动（mutation）事件，当底层 DOM 结构发生变化时触发。 变动名称事件，当元素或属性名变动时触发。此类事件已经被废弃，没有任何浏览器实现它们，因此本章不做介绍 UI事件UI 事件指的是那些不一定与用户操作有关的事件。这些事件在 DOM 规范出现之前，都是以这种或那种形式存在的，而在 DOM 规范中保留是为了向后兼容。现有的 UI 事件如下。 1234567891011121314151617 DOMActivate：表示元素已经被用户操作（通过鼠标或键盘）激活。这个事件在 DOM3 级事件中被废弃，但 Firefox 2+和 Chrome 支持它。考虑到不同浏览器实现的差异，不建议使用这个事件。 load：当页面完全加载后在 window 上面触发，当所有框架都加载完毕时在框架集上面触发，当图像加载完毕时在&lt;img&gt;元素上面触发，或者当嵌入的内容加载完毕时在&lt;object&gt;元素上面触发。 unload：当页面完全卸载后在 window 上面触发，当所有框架都卸载后在框架集上面触发，或者当嵌入的内容卸载完毕后在&lt;object&gt;元素上面触发。 abort：在用户停止下载过程时，如果嵌入的内容没有加载完，则在&lt;object&gt;元素上面触发。 error：当发生 JavaScript 错误时在 window 上面触发，当无法加载图像时在&lt;img&gt;元素上面触发，当无法加载嵌入内容时在&lt;object&gt;元素上面触发，或者当有一或多个框架无法加载时在框架集上面触发。第 17 章将继续讨论这个事件。 select：当用户选择文本框（&lt;input&gt;或&lt;texterea&gt;）中的一或多个字符时触发。第 14 章将继续讨论这个事件。 resize：当窗口或框架的大小变化时在 window 或框架上面触发。 scroll：当用户滚动带滚动条的元素中的内容时，在该元素上面触发。&lt;body&gt;元素中包含所加载页面的滚动条。 load 事件 JavaScript 中最常用的一个事件就是 load。当页面完全加载后（包括所有图像、JavaScript 文件、CSS 文件等外部资源），就会触发 window 上面的 load 事件。有两种定义 onload 事件处理程序的方式。第一种方式是使用如下所示的 JavaScript 代码：EventUtil.addHandler(window, “load”, function(event){alert(“Loaded!”);}); unload 事件 与 load 事件对应的是 unload 事件，这个事件在文档被完全卸载后触发。只要用户从一个页面切换到另一个页面，就会发生 unload 事件。而利用这个事件最多的情况是清除引用，以避免内存泄漏。与 load 事件类似，也有两种指定 onunload 事件处理程序的方式。第一种方式是使用 JavaScript，如下所示：EventUtil.addHandler(window, “unload”, function(event){alert(“Unloaded”);}); resize 事件 当浏览器窗口被调整到一个新的高度或宽度时，就会触发resize事件。这个事件在window（窗口）上面触发，因此可以通过JavaScript或者元素中的onresize特性来指定事件处理程序。如前所述，我们还是推荐使用如下所示的 JavaScript 方式：EventUtil.addHandler(window, “resize”, function(event){alert(“Resized”);}); 4.scroll 事件 虽然 scroll 事件是在 window 对象上发生的，但它实际表示的则是页面中相应元素的变化。在混杂模式下，可以通过元素的 scrollLeft 和 scrollTop 来监控到这一变化；而在标准模式下，除 Safari 之外的所有浏览器都会通过元素来反映这一变化（Safari 仍然基于跟踪滚动位置），如下面的例子所示：EventUtil.addHandler(window, “scroll”, function(event){ if (document.compatMode == “CSS1Compat”){ alert(document.documentElement.scrollTop); } else { alert(document.body.scrollTop); }}); 焦点事件  blur：在元素失去焦点时触发。这个事件不会冒泡；所有浏览器都支持它。 focus：在元素获得焦点时触发。这个事件不会冒泡；所有浏览器都支持它。 鼠标与滚轮事件鼠标事件是 Web 开发中最常用的一类事件，毕竟鼠标还是最主要的定位设备。DOM3 级事件中定义了 9 个鼠标事件，简介如下。  click：在用户单击主鼠标按钮（一般是左边的按钮）或者按下回车键时触发。这一点对确保易访问性很重要，意味着 onclick 事件处理程序既可以通过键盘也可以通过鼠标执行。 dblclick：在用户双击主鼠标按钮（一般是左边的按钮）时触发。从技术上说，这个事件并不是 DOM2 级事件规范中规定的，但鉴于它得到了广泛支持，所以 DOM3 级事件将其纳入了标准。 mousedown：在用户按下了任意鼠标按钮时触发。不能通过键盘触发这个事件。 mouseenter：在鼠标光标从元素外部首次移动到元素范围之内时触发。这个事件不冒泡，而且在光标移动到后代元素上不会触发。DOM2 级事件并没有定义这个事件，但 DOM3 级事件将它纳入了规范。IE、Firefox 9+和 Opera 支持这个事件。 mouseleave：在位于元素上方的鼠标光标移动到元素范围之外时触发。这个事件不冒泡，而且在光标移动到后代元素上不会触发。DOM2 级事件并没有定义这个事件，但 DOM3 级事件将它纳入了规范。IE、Firefox 9+和 Opera 支持这个事件。 mousemove：当鼠标指针在元素内部移动时重复地触发。不能通过键盘触发这个事件。 mouseout：在鼠标指针位于一个元素上方，然后用户将其移入另一个元素时触发。又移入的另一个元素可能位于前一个元素的外部，也可能是这个元素的子元素。不能通过键盘触发这个事件。 mouseover：在鼠标指针位于一个元素外部，然后用户将其首次移入另一个元素边界之内时触发。不能通过键盘触发这个事件。 mouseup：在用户释放鼠标按钮时触发。不能通过键盘触发这个事件。 键盘与文本事件有 3 个键盘事件，简述如下。  keydown：当用户按下键盘上的任意键时触发，而且如果按住不放的话，会重复触发此事件。 keypress：当用户按下键盘上的字符键时触发，而且如果按住不放的话，会重复触发此事件。按下 Esc 键也会触发这个事件。Safari 3.1 之前的版本也会在用户按下非字符键时触发 keypress事件。 keyup：当用户释放键盘上的键时触发。 123456789101112131415161718var textbox = document.getElementById(&quot;myText&quot;);EventUtil.addHandler(textbox, &quot;keyup&quot;, function(event)&#123; event = EventUtil.getEvent(event); alert(event.keyCode);&#125;);//字符编码var EventUtil = &#123; //省略的代码 getCharCode: function(event)&#123; if (typeof event.charCode == &quot;number&quot;)&#123; return event.charCode; &#125; else &#123; return event.keyCode; &#125; &#125;, //省略的代码&#125;; 事件委托 对“事件处理程序过多”问题的解决方案就是事件委托。事件委托利用了事件冒泡，只指定一个事件处理程序，就可以管理某一类型的所有事件。例如，click 事件会一直冒泡到 document 层次。也就是说，我们可以为整个页面指定一个 onclick 事件处理程序，而不必给每个可单击的元素分别添加事件处理程序。以下面的 HTML 代码为例。 1234567891011121314151617181920212223&lt;ul id=&quot;myLinks&quot;&gt; &lt;li id=&quot;goSomewhere&quot;&gt;Go somewhere&lt;/li&gt; &lt;li id=&quot;doSomething&quot;&gt;Do something&lt;/li&gt; &lt;li id=&quot;sayHi&quot;&gt;Say hi&lt;/li&gt;&lt;/ul&gt;var list = document.getElementById(&quot;myLinks&quot;);EventUtil.addHandler(list, &quot;click&quot;, function(event)&#123; event = EventUtil.getEvent(event); var target = EventUtil.getTarget(event); switch(target.id)&#123; case &quot;doSomething&quot;: document.title = &quot;I changed the document&#x27;s title&quot;; break; case &quot;goSomewhere&quot;: location.href = &quot;http://www.wrox.com&quot;; break; case &quot;sayHi&quot;: alert(&quot;hi&quot;); break; &#125;&#125;); 最适合采用事件委托技术的事件包括 click、mousedown、mouseup、keydown、keyup 和 keypress。虽然 mouseover 和 mouseout 事件也冒泡，但要适当处理它们并不容易，而且经常需要计算元素的位置。（因为当鼠标从一个元素移到其子节点时，或者当鼠标移出该元素时，都会触发 mouseout 事件。） 自定义 DOM 事件DOM3 级还定义了“自定义事件”。自定义事件不是由 DOM 原生触发的，它的目的是让开发人员创建自己的事件。要创建新的自定义事件，可以调用 createEvent(“CustomEvent”)。返回的对象有一个名为 initCustomEvent()的方法，接收如下 4 个参数。  type（字符串）：触发的事件类型，例如”keydown”。 bubbles（布尔值）：表示事件是否应该冒泡。 cancelable（布尔值）：表示事件是否可以取消。 detail（对象）：任意值，保存在 event 对象的 detail 属性中。 123456789101112131415161718var div = document.getElementById(&quot;myDiv&quot;), event;EventUtil.addHandler(div, &quot;myevent&quot;, function(event)&#123; alert(&quot;DIV: &quot; + event.detail);&#125;);EventUtil.addHandler(document, &quot;myevent&quot;, function(event)&#123; alert(&quot;DOCUMENT: &quot; + event.detail);&#125;);if (document.implementation.hasFeature(&quot;CustomEvents&quot;, &quot;3.0&quot;))&#123; event = document.createEvent(&quot;CustomEvent&quot;); event.initCustomEvent(&quot;myevent&quot;, true, false, &quot;Hello world!&quot;); div.dispatchEvent(event);&#125;这个例子创建了一个冒泡事件&quot;myevent&quot;。而 event.detail 的值被设置成了一个简单的字符串，然后在&lt;div&gt;元素和 document 上侦听这个事件。因为 initCustomEvent()方法已经指定这个事件应该冒泡，所以浏览器会负责将事件向上冒泡到 document。支持自定义 DOM 事件的浏览器有 IE9+和 Firefox 6+。","categories":[],"tags":[{"name":"高程","slug":"高程","permalink":"https://vlwq.github.io/tags/%E9%AB%98%E7%A8%8B/"}]},{"title":"高程笔记4-BOM","slug":"2017/20170612","date":"2017-06-12T02:36:00.000Z","updated":"2017-07-16T04:19:24.266Z","comments":true,"path":"2017/06/12/2017/20170612/","link":"","permalink":"https://vlwq.github.io/2017/06/12/2017/20170612/","excerpt":"高程笔记4-BOM","text":"高程笔记4-BOM 8-windows对象1234567891011抛开全局变量会成为 window 对象的属性不谈，定义全局变量与在 window 对象上直接定义属性还是有一点差别：全局变量不能通过 delete 操作符删除，而直接在 window 对象上的定义的属性可以。例如：var age = 29;window.color = &quot;red&quot;;//在 IE &lt; 9 时抛出错误，在其他所有浏览器中都返回 falsedelete window.age;//在 IE &lt; 9 时抛出错误，在其他所有浏览器中都返回 truedelete window.color; //returns truealert(window.age); //29alert(window.color); //undefined 间歇调用和超时调用1234567891011121314//设置超时调用var timeoutId = setTimeout(function() &#123; alert(&quot;Hello world!&quot;);&#125;, 1000);//注意：把它取消clearTimeout(timeoutId);//不建议传递字符串！setInterval (&quot;alert(&#x27;Hello world!&#x27;) &quot;, 10000);//推荐的调用方式setInterval (function() &#123; alert(&quot;Hello world!&quot;);&#125;, 10000) 浏览器通过 alert()、confirm()和 prompt()方法可以调用系统对话框向用户显示消息。//显示“打印”对话框window.print();//显示“查找”对话框window.find(); location 对象位置操作 123456789101112131415161718192021location.assign(&quot;http://www.wrox.com&quot;);window.location = &quot;http://www.wrox.com&quot;;location.href = &quot;http://www.wrox.com&quot;;//假设初始 URL 为 http://www.wrox.com/WileyCDA///将 URL 修改为&quot;http://www.wrox.com/WileyCDA/#section1&quot;location.hash = &quot;#section1&quot;;//将 URL 修改为&quot;http://www.wrox.com/WileyCDA/?q=javascript&quot;location.search = &quot;?q=javascript&quot;;//将 URL 修改为&quot;http://www.yahoo.com/WileyCDA/&quot;location.hostname = &quot;www.yahoo.com&quot;;//将 URL 修改为&quot;http://www.yahoo.com/mydir/&quot;location.pathname = &quot;mydir&quot;;//将 URL 修改为&quot;http://www.yahoo.com:8080/WileyCDA/&quot;location.port = 8080;每次修改 location 的属性（hash 除外），页面都会以新 URL 重新加载。 重新加载location.reload(); //重新加载（有可能从缓存中加载）location.reload(true); //重新加载（从服务器重新加载） history 对象12345678910111213141516171819使用 go()方法可以在用户的历史记录中任意跳转，可以向后也可以向前。这个方法接受一个参数，表示向后或向前跳转的页面数的一个整数值。负数表示向后跳转（类似于单击浏览器的“后退”按钮），正数表示向前跳转（类似于单击浏览器的“前进”按钮）。来看下面的例子。//后退一页history.go(-1);//前进一页history.go(1);//前进两页history.go(2);//跳转到最近的 wrox.com 页面history.go(&quot;wrox.com&quot;);//跳转到最近的 nczonline.net 页面history.go(&quot;nczonline.net&quot;);另外，还可以使用两个简写方法 back()和 forward()来代替 go()。顾名思义，这两个方法可以模仿浏览器的“后退”和“前进”按钮。//后退一页history.back();//前进一页history.forward(); BOM总结 浏览器对象模型（BOM）以 window 对象为依托，表示浏览器窗口以及页面可见区域。同时，window对象还是 ECMAScript 中的 Global 对象，因而所有全局变量和函数都是它的属性，且所有原生的构造函数及其他函数也都存在于它的命名空间下。本章讨论了下列 BOM 的组成部分。 在使用框架时，每个框架都有自己的 window 对象以及所有原生构造函数及其他函数的副本。每个框架都保存在 frames 集合中，可以通过位置或通过名称来访问。 有一些窗口指针，可以用来引用其他框架，包括父框架。 top 对象始终指向最外围的框架，也就是整个浏览器窗口。 parent 对象表示包含当前框架的框架，而 self 对象则回指 window。 使用 location 对象可以通过编程方式来访问浏览器的导航系统。设置相应的属性，可以逐段或整体性地修改浏览器的 URL。 调用 replace()方法可以导航到一个新 URL，同时该 URL 会替换浏览器历史记录中当前显示的页面。 navigator 对象提供了与浏览器有关的信息。到底提供哪些信息，很大程度上取决于用户的浏览器；不过，也有一些公共的属性（如 userAgent）存在于所有浏览器中。BOM 中还有两个对象：screen 和 history，但它们的功能有限。screen 对象中保存着与客户端显示器有关的信息，这些信息一般只用于站点分析。history 对象为访问浏览器的历史记录开了一个小缝隙，开发人员可以据此判断历史记录的数量，也可以在历史记录中向后或向前导航到任意页面。 10.DOMDOCUMENT 这个页面在经过浏览器解析后，其文档中只包含一个子节点，即元素。可以通过documentElement 或 childNodes 列表来访问这个元素，如下所示。 12345678910111213141516var html = document.documentElement; //取得对&lt;html&gt;的引用alert(html === document.childNodes[0]); //truealert(html === document.firstChild); //true//取得文档标题var originalTitle = document.title;//设置文档标题document.title = &quot;New page title&quot;;//取得完整的 URLvar url = document.URL;//取得域名var domain = document.domain;//取得来源页面的 URLvar referrer = document.referrer; 文档写入 有一个 document 对象的功能已经存在很多年了，那就是将输出流写入到网页中的能力。这个能力体现在下列 4 个方法中：write()、writeln()、open()和 close()。其中，write()和 writeln()方法都接受一个字符串参数，即要写入到输出流中的文本。write()会原样写入，而 writeln()则会在字符串的末尾添加一个换行符（\\n）。在页面被加载的过程中，可以使用这两个方法向页面中动态地加入内容，如下面的例子所示。 Element类型12345678910111213if (element.tagName == &quot;div&quot;)&#123; //不能这样比较，很容易出错！ //在此执行某些操作&#125;if (element.tagName.toLowerCase() == &quot;div&quot;)&#123; //这样最好（适用于任何文档） //在此执行某些操作&#125;//属性的3个方法div.setAttribute(&quot;id&quot;, &quot;someOtherId&quot;);alert(div.getAttribute(&quot;mycolor&quot;)); //null（IE 除外）div.removeAttribute(&quot;class&quot;); DOM拓展querySelector()方法 1234567891011121314//取得 body 元素var body = document.querySelector(&quot;body&quot;);//取得某&lt;div&gt;中的所有&lt;em&gt;元素（类似于 getElementsByTagName(&quot;em&quot;)）var ems = document.getElementById(&quot;myDiv&quot;).querySelectorAll(&quot;em&quot;);//matchesSelector()方法//Selectors API Level 2 规范为 Element 类型新增了一个方法 matchesSelector()。这个方法接收//一个参数，即 CSS 选择符，如果调用元素与该选择符匹配，返回 true；否则，返回 false。看例子。if (document.body.matchesSelector(&quot;body.page1&quot;))&#123; //true&#125; classList 属性  add(value)：将给定的字符串值添加到列表中。如果值已经存在，就不添加了。 contains(value)：表示列表中是否存在给定的值，如果存在则返回 true，否则返回 false。 remove(value)：从列表中删除给定的字符串。 toggle(value)：如果列表中已经存在给定的值，删除它；如果列表中没有给定的值，添加它。 1234567891011121314151617//删除&quot;disabled&quot;类div.classList.remove(&quot;disabled&quot;);//添加&quot;current&quot;类div.classList.add(&quot;current&quot;);//切换&quot;user&quot;类div.classList.toggle(&quot;user&quot;);//确定元素中是否包含既定的类名if (div.classList.contains(&quot;bd&quot;) &amp;&amp; !div.classList.contains(&quot;disabled&quot;))&#123; //执行操作)//迭代类名for (var i=0, len=div.classList.length; i &lt; len; i++)&#123; doSomething(div.classList[i]);&#125;有了 classList 属性，除非你需要全部删除所有类名，或者完全重写元素的 class 属性，否则也就用不到 className 属性了。支持 classList 属性的浏览器有 Firefox 3.6+和 Chrome。 焦点管理123456默认情况下，文档刚刚加载完成时，document.activeElement 中保存的是 document.body 元素的引用。文档加载期间，document.activeElement 的值为 null。另外就是新增了 document.hasFocus()方法，这个方法用于确定文档是否获得了焦点。var button = document.getElementById(&quot;myButton&quot;);button.focus();alert(document.hasFocus()); //true 自定义数据属性 HTML5 规定可以为元素添加非标准的属性，但要添加前缀 data-，目的是为元素提供与渲染无关的信息，或者提供语义信息。这些属性可以任意添加、随便命名，只要以 data-开头即可。来看一个例子。 12345678910111213&lt;div id=&quot;myDiv&quot; data-appId=&quot;12345&quot; data-myname=&quot;Nicholas&quot;&gt;&lt;/div&gt;添加了自定义属性之后，可以通过元素的 dataset 属性来访问自定义属性的值。dataset 属性的值是 DOMStringMap 的一个实例，也就是一个名值对儿的映射。在这个映射中，每个 data-name 形式的属性都会有一个对应的属性，只不过属性名没有 data-前缀（比如，自定义属性是 data-myname，那映射中对应的属性就是 myname）。还是看一个例子吧。//本例中使用的方法仅用于演示var div = document.getElementById(&quot;myDiv&quot;);//取得自定义属性的值var appId = div.dataset.appId;var myName = div.dataset.myname;//设置值div.dataset.appId = 23456;div.dataset.myname = &quot;Michael&quot;; 字符集属性12345HTML5 新增了几个与文档字符集有关的属性。其中，charset 属性表示文档中实际使用的字符集，也可以用来指定新字符集。默认情况下，这个属性的值为&quot;UTF-16&quot;，但可以通过&lt;meta&gt;元素、响应头部或直接设置 charset 属性修改这个值。来看一个例子。alert(document.charset); //&quot;UTF-16&quot;document.charset = &quot;UTF-8&quot;; 插入标记1234567innerHTMLs属性div.innerHTML = &quot;Hello world!&quot;;outerHTML 属性outerHTML会根据指定的 HTML 字符串创建新的 DOM 子树，然后用这个 DOM 子树完全替换调用元素div.outerHTML = &quot;&lt;p&gt;This is a paragraph.&lt;/p&gt;&quot;; //div会被覆盖掉 insertAdjacentHTML()方法插入标记的最后一个新增方式是insertAdjacentHTML()方法。这个方法最早也是在IE中出现的，它接收两个参数：插入位置和要插入的 HTML 文本。第一个参数必须是下列值之一： “beforebegin”，在当前元素之前插入一个紧邻的同辈元素； “afterbegin”，在当前元素之下插入一个新的子元素或在第一个子元素之前再插入新的子元素； “beforeend”，在当前元素之下插入一个新的子元素或在最后一个子元素之后再插入新的子元素； “afterend”，在当前元素之后插入一个紧邻的同辈元素。 123456789//作为前一个同辈元素插入element.insertAdjacentHTML(&quot;beforebegin&quot;, &quot;&lt;p&gt;Hello world!&lt;/p&gt;&quot;);//作为第一个子元素插入element.insertAdjacentHTML(&quot;afterbegin&quot;, &quot;&lt;p&gt;Hello world!&lt;/p&gt;&quot;);//作为最后一个子元素插入element.insertAdjacentHTML(&quot;beforeend&quot;, &quot;&lt;p&gt;Hello world!&lt;/p&gt;&quot;);//作为后一个同辈元素插入element.insertAdjacentHTML(&quot;afterend&quot;, &quot;&lt;p&gt;Hello world!&lt;/p&gt;&quot;);支持 insertAdjacentHTML()方法的浏览器有 IE、Firefox 8+、Safari、Opera 和 Chrome。 scrollIntoView()方法 如何滚动页面也是 DOM 规范没有解决的一个问题。为了解决这个问题，浏览器实现了一些方法，以方便开发人员更好地控制页面滚动。在各种专有方法中，HTML5 最终选择了 scrollIntoView()作为标准方法。//让元素可见 1document.forms[0].scrollIntoView();  scrollIntoViewIfNeeded(alignCenter)：只在当前元素在视口中不可见的情况下，才滚动浏览器窗口或容器元素，最终让它可见。如果当前元素在视口中可见，这个方法什么也不做。如果将可选的 alignCenter 参数设置为 true，则表示尽量将元素显示在视口中部（垂直方向）。Safari 和 Chrome 实现了这个方法。 scrollByLines(lineCount)：将元素的内容滚动指定的行高，lineCount 值可以是正值，也可以是负值。Safari 和 Chrome 实现了这个方法。 scrollByPages(pageCount)：将元素的内容滚动指定的页面高度，具体高度由元素的高度决定。Safari 和 Chrome 实现了这个方法。 设置CSS1234567891011只要取得一个有效的 DOM 元素的引用，就可以随时使用 JavaScript 为其设置样式。以下是几个例子。var myDiv = document.getElementById(&quot;myDiv&quot;);//设置背景颜色myDiv.style.backgroundColor = &quot;red&quot;;//改变大小myDiv.style.width = &quot;100px&quot;;myDiv.style.height = &quot;200px&quot;;//指定边框myDiv.style.border = &quot;1px solid black&quot;;在以这种方式改变样式时，元素的外观会自动被更新。 DOM 样式属性和方法“DOM2级样式”规范还为 style 对象定义了一些属性和方法。这些属性和方法在提供元素的 style特性值的同时，也可以修改样式。下面列出了这些属性和方法。 cssText：如前所述，通过它能够访问到 style 特性中的 CSS 代码。 length：应用给元素的 CSS 属性的数量。 parentRule：表示 CSS 信息的 CSSRule 对象。本节后面将讨论 CSSRule 类型。 getPropertyCSSValue(propertyName)：返回包含给定属性值的 CSSValue 对象。 getPropertyPriority(propertyName)：如果给定的属性使用了!important 设置，则返回“important”；否则，返回空字符串。 getPropertyValue(propertyName)：返回给定属性的字符串值。 item(index)：返回给定位置的 CSS 属性的名称。 removeProperty(propertyName)：从样式中删除给定属性。 setProperty(propertyName,value,priority)：将给定属性设置为相应的值，并加上优先权标志（”important”或者一个空字符串）。 12345678910myDiv.style.cssText = &quot;width: 25px; height: 100px; background-color: green&quot;;alert(myDiv.style.cssText);设计 length 属性的目的，就是将其与 item()方法配套使用，以便迭代在元素中定义的 CSS 属性。在使用 length 和 item()时，style 对象实际上就相当于一个集合，都可以使用方括号语法来代替item()来取得给定位置的 CSS 属性，如下面的例子所示。for (var i=0, len=myDiv.style.length; i &lt; len; i++)&#123; alert(myDiv.style[i]); //或者 myDiv.style.item(i)&#125; // CSS 规则 123456789101112131415161718192021var sheet = document.styleSheets[0];var rules = sheet.cssRules || sheet.rules; //取得规则列表var rule = rules[0]; //取得第一条规则alert(rule.selectorText); //&quot;div.box&quot;alert(rule.style.cssText); //完整的 CSS 代码alert(rule.style.backgroundColor); //&quot;blue&quot;alert(rule.style.width); //&quot;100px&quot;alert(rule.style.height); //&quot;200px&quot;/*使用这种方式，可以像确定元素的行内样式信息一样，确定与规则相关的样式信息。与使用元素的方式一样，在这种方式下也可以修改样式信息，如下面的例子所示。*/var sheet = document.styleSheets[0];var rules = sheet.cssRules || sheet.rules; //取得规则列表var rule = rules[0]; //取得第一条规则rule.style.backgroundColor = &quot;red&quot;//2. 创建规则sheet.insertRule(&quot;body &#123; background-color: silver &#125;&quot;, 0); //DOM 方法//3. 删除规则sheet.deleteRule(0); //DOM 方法","categories":[],"tags":[{"name":"高程","slug":"高程","permalink":"https://vlwq.github.io/tags/%E9%AB%98%E7%A8%8B/"}]},{"title":"高程笔记3-函数表达式","slug":"2017/20170611","date":"2017-06-11T02:36:00.000Z","updated":"2017-07-16T04:18:01.498Z","comments":true,"path":"2017/06/11/2017/20170611/","link":"","permalink":"https://vlwq.github.io/2017/06/11/2017/20170611/","excerpt":"高程笔记3","text":"高程笔记3 函数表达式 123456函数表达式与其他表达式一样，在使用前必须先赋值。以下代码会导致错误。sayHi(); //错误：函数还不存在var sayHi = function()&#123; //匿名函数 alert(&quot;Hi!&quot;);&#125;; 递归函数是在一个函数通过名字调用自身的情况下构成的，如下所示。 1234567891011121314151617function factorial(num)&#123; if (num &lt;= 1)&#123; return 1; &#125; else &#123; return num * factorial(num-1); &#125;&#125;arguments.callee 是一个指向正在执行的函数的指针，因此可以用它来实现对函数的递归调用，例如function factorial(num)&#123; if (num &lt;= 1)&#123; return 1; &#125; else &#123; return num * arguments.callee(num-1); &#125;&#125; 闭包闭包是指有权访问另一个函数作用域中的变量的函数。创建闭包的常见方式，就是在一个函数内部创建另一个函数 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950function createComparisonFunction(propertyName) &#123; return function(object1, object2)&#123; var value1 = object1[propertyName]; var value2 = object2[propertyName]; if (value1 &lt; value2)&#123; return -1; &#125; else if (value1 &gt; value2)&#123; return 1; &#125; else &#123; return 0; &#125; &#125;;&#125;/*作用域链的这种配置机制引出了一个值得注意的副作用，即闭包只能取得包含函数中任何变量的最后一个值。别忘了闭包所保存的是整个变量对象，而不是某个特殊的变量。下面这个例子可以清晰地说明这个问题。*/function createFunctions()&#123; var result = new Array(); for (var i=0; i &lt; 10; i++)&#123; result[i] = function()&#123; return i; &#125;; &#125; return result;&#125;/*这个函数会返回一个函数数组。表面上看，似乎每个函数都应该返自己的索引值，即位置 0 的函数返回 0，位置 1 的函数返回 1，以此类推。但实际上，每个函数都返回 10。因为每个函数的作用域链中都保存着 createFunctions() 函数的活动对象，所以它们引用的都是同一个变量 i 。 当createFunctions()函数返回后，变量 i 的值是 10，此时每个函数都引用着保存变量 i 的同一个变量对象，所以在每个函数内部 i 的值都是 10。但是，我们可以通过创建另一个匿名函数强制让闭包的行为符合预期，如下所示。*/function createFunctions()&#123; var result = new Array(); for (var i=0; i &lt; 10; i++)&#123; result[i] = function(num)&#123; return function()&#123; return num; &#125;; &#125;(i); &#125; return result;&#125; 每个函数在被调用时都会自动取得两个特殊变量：this 和 arguments。 123456789101112把外部作用域中的 this 对象保存在一个闭包能够访问到的变量里，就可以让闭包访问该对象了var name = &quot;The Window&quot;;var object = &#123; name : &quot;My Object&quot;, getNameFunc : function()&#123; var that = this; return function()&#123; return that.name; &#125;; &#125;&#125;;alert(object.getNameFunc()()); //&quot;My Object&quot; 内存泄漏 12345678910function assignHandler()&#123; var element = document.getElementById(&quot;someElement&quot;); var id = element.id; element.onclick = function()&#123; alert(id); &#125;; element = null;&#125; 模仿块级作用域 123456789function outputNumbers(count)&#123; (function () &#123; for (var i=0; i &lt; count; i++)&#123; alert(i); &#125; &#125;)(); alert(i); //导致一个错误！&#125; 私有变量 12345678910111213141516171819202122232425262728293031function MyObject()&#123; //私有变量和私有函数 var privateVariable = 10; function privateFunction()&#123; return false; &#125; //特权方法 this.publicMethod = function ()&#123; privateVariable++; return privateFunction(); &#125;;&#125;这个模式在构造函数内部定义了所有私有变量和函数。然后，又继续创建了能够访问这些私有成员的特权方法。能够在构造函数中定义特权方法，是因为特权方法作为闭包有权访问在构造函数中定义的所有变量和函数。对这个例子而言，变量 privateVariable 和函数 privateFunction()只能通过特权方法 publicMethod()来访问。在创建 MyObject 的实例后，除了使用 publicMethod()这一个途径外，没有任何办法可以直接访问 privateVariable 和 privateFunction()。利用私有和特权成员，可以隐藏那些不应该被直接修改的数据，例如：function Person(name)&#123; this.getName = function()&#123; return name; &#125;; this.setName = function (value) &#123; name = value; &#125;;&#125;var person = new Person(&quot;Nicholas&quot;);alert(person.getName()); //&quot;Nicholas&quot;person.setName(&quot;Greg&quot;);alert(person.getName()); //&quot;Greg&quot; 静态私有变量 1234567891011121314151617181920212223(function()&#123; var name = &quot;&quot;; Person = function(value)&#123; name = value; &#125;; Person.prototype.getName = function()&#123; return name; &#125;; Person.prototype.setName = function (value)&#123; name = value; &#125;;&#125;)();var person1 = new Person(&quot;Nicholas&quot;);alert(person1.getName()); //&quot;Nicholas&quot;person1.setName(&quot;Greg&quot;);alert(person1.getName()); //&quot;Greg&quot;var person2 = new Person(&quot;Michael&quot;);alert(person1.getName()); //&quot;Michael&quot;alert(person2.getName()); //&quot;Michael&quot; 模块模式123456789101112131415161718192021222324252627282930313233343536373839模块模式通过为单例添加私有变量和特权方法能够使其得到增强，其语法形式如下：var singleton = function()&#123; //私有变量和私有函数 var privateVariable = 10; function privateFunction()&#123; return false; &#125; //特权/公有方法和属性 return &#123; publicProperty: true, publicMethod : function()&#123; privateVariable++; return privateFunction(); &#125; &#125;;&#125;();/*增强的模块模式*/var singleton = function()&#123; //私有变量和私有函数 var privateVariable = 10; function privateFunction()&#123; return false; &#125; //创建对象 var object = new CustomType(); //添加特权/公有属性和方法 object.publicProperty = true; object.publicMethod = function()&#123; privateVariable++; return privateFunction(); &#125;; //返回这个对象 return object;&#125;(); 总结 在 JavaScript 编程中，函数表达式是一种非常有用的技术。使用函数表达式可以无须对函数命名，从而实现动态编程。匿名函数，也称为拉姆达函数，是一种使用 JavaScript 函数的强大方式。以下总结了函数表达式的特点。 函数表达式不同于函数声明。函数声明要求有名字，但函数表达式不需要。没有名字的函数表达式也叫做匿名函数。 在无法确定如何引用函数的情况下，递归函数就会变得比较复杂； 递归函数应该始终使用 arguments.callee 来递归地调用自身，不要使用函数名——函数名可能会发生变化。当在函数内部定义了其他函数时，就创建了闭包。闭包有权访问包含函数内部的所有变量，原理如下。 在后台执行环境中，闭包的作用域链包含着它自己的作用域、包含函数的作用域和全局作用域。 通常，函数的作用域及其所有变量都会在函数执行结束后被销毁。 但是，当函数返回了一个闭包时，这个函数的作用域将会一直在内存中保存到闭包不存在为止。使用闭包可以在 JavaScript 中模仿块级作用域（JavaScript 本身没有块级作用域的概念），要点如下。 创建并立即调用一个函数，这样既可以执行其中的代码，又不会在内存中留下对该函数的引用。 结果就是函数内部的所有变量都会被立即销毁——除非将某些变量赋值给了包含作用域（即外部作用域）中的变量。闭包还可以用于在对象中创建私有变量，相关概念和要点如下。 即使 JavaScript 中没有正式的私有对象属性的概念，但可以使用闭包来实现公有方法，而通过公有方法可以访问在包含作用域中定义的变量。 有权访问私有变量的公有方法叫做特权方法。 可以使用构造函数模式、原型模式来实现自定义类型的特权方法，也可以使用模块模式、增强的模块模式来实现单例的特权方法。JavaScript 中的函数表达式和闭包都是极其有用的特性，利用它们可以实现很多功能。不过，因为创建闭包必须维护额外的作用域，所以过度使用它们可能会占用大量内存。","categories":[],"tags":[{"name":"高程","slug":"高程","permalink":"https://vlwq.github.io/tags/%E9%AB%98%E7%A8%8B/"}]},{"title":"高程笔记2-面向对象的程序设计","slug":"2017/20170610","date":"2017-06-10T02:36:00.000Z","updated":"2017-07-16T04:16:48.823Z","comments":true,"path":"2017/06/10/2017/20170610/","link":"","permalink":"https://vlwq.github.io/2017/06/10/2017/20170610/","excerpt":"高程笔记二","text":"高程笔记二 面向对象的程序设计Object  [[Configurable]]：表示能否通过 delete 删除属性从而重新定义属性，能否修改属性的特性，或者能否把属性修改为访问器属性。像前面例子中那样直接在对象上定义的属性，它们的这个特性默认值为 true。 [[Enumerable]]：表示能否通过 for-in 循环返回属性。像前面例子中那样直接在对象上定义的属性，它们的这个特性默认值为 true。 [[Writable]]：表示能否修改属性的值。像前面例子中那样直接在对象上定义的属性，它们的这个特性默认值为 true。 [[Value]]：包含这个属性的数据值。读取属性值的时候，从这个位置读；写入属性值的时候，把新值保存在这个位置。这个特性的默认值为 undefined。 要修改属性默认的特性，必须使用ECMAScript 5的Object.defineProperty()方法。这个方法接收三个参数：属性所在的对象、属性的名字和一个描述符对象。其中，描述符（descriptor）对象的属性必须是：configurable、enumerable、writable 和 value。 123456789101112131415161718192021222324var person = &#123;&#125;;Object.defineProperty(person, &quot;name&quot;, &#123; writable: false, value: &quot;Nicholas&quot;&#125;);alert(person.name); //&quot;Nicholas&quot;person.name = &quot;Greg&quot;;alert(person.name); //&quot;Nicholas&quot;/*这个例子创建了一个名为 name 的属性，它的值&quot;Nicholas&quot;是只读的。这个属性的值是不可修改的，如果尝试为它指定新值，则在非严格模式下，赋值操作将被忽略；在严格模式下，赋值操作将会导致抛出错误。类似的规则也适用于不可配置的属性。例如：*/var person = &#123;&#125;;Object.defineProperty(person, &quot;name&quot;, &#123; configurable: false, value: &quot;Nicholas&quot;&#125;);alert(person.name); //&quot;Nicholas&quot;delete person.name;alert(person.name); //&quot;Nicholas&quot; 访问器属性1234567891011121314151617var book = &#123; _year: 2004, edition: 1&#125;;Object.defineProperty(book, &quot;year&quot;, &#123; get: function()&#123; return this._year; &#125;, set: function(newValue)&#123; if (newValue &gt; 2004) &#123; this._year = newValue; this.edition += newValue - 2004; &#125; &#125;&#125;);book.year = 2005;alert(book.edition); //2 工厂模式 工厂模式是软件工程领域一种广为人知的设计模式，这种模式抽象了创建具体对象的过程（本书后面还将讨论其他设计模式及其在 JavaScript 中的实现） 123456789101112function createPerson(name, age, job)&#123; var o = new Object(); o.name = name; o.age = age; o.job = job; o.sayName = function()&#123; alert(this.name); &#125;; return o;&#125;var person1 = createPerson(&quot;Nicholas&quot;, 29, &quot;Software Engineer&quot;);var person2 = createPerson(&quot;Greg&quot;, 27, &quot;Doctor&quot;); 原型模式123456789101112131415我们创建的每个函数都有一个 prototype（原型）属性，这个属性是一个指针，指向一个对象，而这个对象的用途是包含可以由特定类型的所有实例共享的属性和方法。如果按照字面意思来理解，那么 prototype 就是通过调用构造函数而创建的那个对象实例的原型对象。使用原型对象的好处是可以让所有对象实例共享它所包含的属性和方法。换句话说，不必在构造函数中定义对象实例的信息，而是可以将这些信息直接添加到原型对象中，如下面的例子所示。function Person()&#123;&#125;Person.prototype.name = &quot;Nicholas&quot;;Person.prototype.age = 29;Person.prototype.job = &quot;Software Engineer&quot;;Person.prototype.sayName = function()&#123; alert(this.name);&#125;;var person1 = new Person();person1.sayName(); //&quot;Nicholas&quot; 组合使用构造函数模式和原型模式1234567891011121314151617181920212223创建自定义类型的最常见方式，就是组合使用构造函数模式与原型模式。构造函数模式用于定义实例属性，而原型模式用于定义方法和共享的属性。结果，每个实例都会有自己的一份实例属性的副本，但同时又共享着对方法的引用，最大限度地节省了内存。另外，这种混成模式还支持向构造函数传递参数；可谓是集两种模式之长。下面的代码重写了前面的例子。function Person(name, age, job)&#123; this.name = name; this.age = age; this.job = job; this.friends = [&quot;Shelby&quot;, &quot;Court&quot;];&#125;Person.prototype = &#123; constructor : Person, sayName : function()&#123; alert(this.name); &#125;&#125;var person1 = new Person(&quot;Nicholas&quot;, 29, &quot;Software Engineer&quot;);var person2 = new Person(&quot;Greg&quot;, 27, &quot;Doctor&quot;);person1.friends.push(&quot;Van&quot;);alert(person1.friends); //&quot;Shelby,Count,Van&quot;alert(person2.friends); //&quot;Shelby,Count&quot;alert(person1.friends === person2.friends); //falsealert(person1.sayName === person2.sayName); //true 动态原型模式123456789101112131415161718有其他 OO 语言经验的开发人员在看到独立的构造函数和原型时，很可能会感到非常困惑。动态原型模式正是致力于解决这个问题的一个方案，它把所有信息都封装在了构造函数中，而通过在构造函数中初始化原型（仅在必要的情况下），又保持了同时使用构造函数和原型的优点。换句话说，可以通过检查某个应该存在的方法是否有效，来决定是否需要初始化原型。来看一个例子。function Person(name, age, job)&#123; //属性 this.name = name; this.age = age; this.job = job; //方法 if (typeof this.sayName != &quot;function&quot;)&#123; Person.prototype.sayName = function()&#123; alert(this.name); &#125;; &#125;&#125;var friend = new Person(&quot;Nicholas&quot;, 29, &quot;Software Engineer&quot;);friend.sayName(); 寄生构造函数模式123456789101112131415通常，在前述的几种模式都不适用的情况下，可以使用寄生（parasitic）构造函数模式。这种模式的基本思想是创建一个函数，该函数的作用仅仅是封装创建对象的代码，然后再返回新创建的对象；但从表面上看，这个函数又很像是典型的构造函数。下面是一个例子。function Person(name, age, job)&#123; var o = new Object(); o.name = name; o.age = age; o.job = job; o.sayName = function()&#123; alert(this.name); &#125;; return o;&#125;var friend = new Person(&quot;Nicholas&quot;, 29, &quot;Software Engineer&quot;);friend.sayName(); //&quot;Nicholas&quot; 原型链的问题1234567891011121314151617原型链虽然很强大，可以用它来实现继承，但它也存在一些问题。其中，最主要的问题来自包含引用类型值的原型。想必大家还记得，我们前面介绍过包含引用类型值的原型属性会被所有实例共享；而这也正是为什么要在构造函数中，而不是在原型对象中定义属性的原因。在通过原型来实现继承时，原型实际上会变成另一个类型的实例。于是，原先的实例属性也就顺理成章地变成了现在的原型属性了。下列代码可以用来说明这个问题。function SuperType()&#123; this.colors = [&quot;red&quot;, &quot;blue&quot;, &quot;green&quot;]; &#125;function SubType()&#123;&#125;//继承了 SuperTypeSubType.prototype = new SuperType();var instance1 = new SubType();instance1.colors.push(&quot;black&quot;);alert(instance1.colors); //&quot;red,blue,green,black&quot;var instance2 = new SubType();alert(instance2.colors); //&quot;red,blue,green,black&quot; 组合继承123456789101112131415161718192021222324252627282930313233组合继承（combination inheritance），有时候也叫做伪经典继承，指的是将原型链和借用构造函数的技术组合到一块，从而发挥二者之长的一种继承模式。其背后的思路是使用原型链实现对原型属性和方法的继承，而通过借用构造函数来实现对实例属性的继承。这样，既通过在原型上定义方法实现了函数复用，又能够保证每个实例都有它自己的属性。下面来看一个例子。function SuperType(name)&#123; this.name = name; this.colors = [&quot;red&quot;, &quot;blue&quot;, &quot;green&quot;];&#125;SuperType.prototype.sayName = function()&#123; alert(this.name); &#125;;function SubType(name, age)&#123; //继承属性 SuperType.call(this, name); this.age = age;&#125;//继承方法SubType.prototype = new SuperType();SubType.prototype.constructor = SubType;SubType.prototype.sayAge = function()&#123; alert(this.age);&#125;;var instance1 = new SubType(&quot;Nicholas&quot;, 29);instance1.colors.push(&quot;black&quot;);alert(instance1.colors); //&quot;red,blue,green,black&quot;instance1.sayName(); //&quot;Nicholas&quot;;instance1.sayAge(); //29var instance2 = new SubType(&quot;Greg&quot;, 27);alert(instance2.colors); //&quot;red,blue,green&quot;instance2.sayName(); //&quot;Greg&quot;;instance2.sayAge(); //27 原型式继承1234567891011var person = &#123; name: &quot;Nicholas&quot;, friends: [&quot;Shelby&quot;, &quot;Court&quot;, &quot;Van&quot;]&#125;;var anotherPerson = object(person);anotherPerson.name = &quot;Greg&quot;;anotherPerson.friends.push(&quot;Rob&quot;);var yetAnotherPerson = object(person);yetAnotherPerson.name = &quot;Linda&quot;;yetAnotherPerson.friends.push(&quot;Barbie&quot;);alert(person.friends); //&quot;Shelby,Court,Van,Rob,Barbie&quot; ECMAScript 5 通过新增 Object.create()方法规范化了原型式继承。这个方法接收两个参数：一个用作新对象原型的对象和（可选的）一个为新对象定义额外属性的对象。在传入一个参数的情况下，Object.create()与 object()方法的行为相同。 123456789101112var person = &#123; name: &quot;Nicholas&quot;, friends: [&quot;Shelby&quot;, &quot;Court&quot;, &quot;Van&quot;]&#125;;var anotherPerson = Object.create(person);anotherPerson.name = &quot;Greg&quot;;anotherPerson.friends.push(&quot;Rob&quot;);var yetAnotherPerson = Object.create(person);yetAnotherPerson.name = &quot;Linda&quot;;yetAnotherPerson.friends.push(&quot;Barbie&quot;);alert(person.friends); //&quot;Shelby,Court,Van,Rob,Barbie&quot; 寄生组合式继承1234567891011121314151617function SuperType(name)&#123; this.name = name; this.colors = [&quot;red&quot;, &quot;blue&quot;, &quot;green&quot;];&#125;SuperType.prototype.sayName = function()&#123; alert(this.name);&#125;;function SubType(name, age)&#123; SuperType.call(this, name); this.age = age;&#125;inheritPrototype(SubType, SuperType);SubType.prototype.sayAge = function()&#123; alert(this.age);&#125;; 总结 ECMAScript 支持面向对象（OO）编程，但不使用类或者接口。对象可以在代码执行过程中创建和增强，因此具有动态性而非严格定义的实体。在没有类的情况下，可以采用下列模式创建对象。 工厂模式，使用简单的函数创建对象，为对象添加属性和方法，然后返回对象。这个模式后来被构造函数模式所取代。 构造函数模式，可以创建自定义引用类型，可以像创建内置对象实例一样使用 new 操作符。不过，构造函数模式也有缺点，即它的每个成员都无法得到复用，包括函数。由于函数可以不局限于任何对象（即与对象具有松散耦合的特点），因此没有理由不在多个对象间共享函数。 原型模式，使用构造函数的 prototype 属性来指定那些应该共享的属性和方法。组合使用构造函数模式和原型模式时，使用构造函数定义实例属性，而使用原型定义共享的属性和方法。JavaScript 主要通过原型链实现继承。原型链的构建是通过将一个类型的实例赋值给另一个构造函数的原型实现的。这样，子类型就能够访问超类型的所有属性和方法，这一点与基于类的继承很相似。原型链的问题是对象实例共享所有继承的属性和方法，因此不适宜单独使用。解决这个问题的技术是借用构造函数，即在子类型构造函数的内部调用超类型构造函数。这样就可以做到每个实例都具有自己的属性，同时还能保证只使用构造函数模式来定义类型。使用最多的继承模式是组合继承，这种模式使用原型链继承共享的属性和方法，而通过借用构造函数继承实例属性。此外，还存在下列可供选择的继承模式。 原型式继承，可以在不必预先定义构造函数的情况下实现继承，其本质是执行对给定对象的浅复制。而复制得到的副本还可以得到进一步改造。 寄生式继承，与原型式继承非常相似，也是基于某个对象或某些信息创建一个对象，然后增强对象，最后返回对象。为了解决组合继承模式由于多次调用超类型构造函数而导致的低效率问题，可以将这个模式与组合继承一起使用。 寄生组合式继承，集寄生式继承和组合继承的优点与一身，是实现基于类型继承的最有效方式。","categories":[],"tags":[{"name":"高程","slug":"高程","permalink":"https://vlwq.github.io/tags/%E9%AB%98%E7%A8%8B/"}]},{"title":"高程笔记1","slug":"2017/20170609","date":"2017-06-09T02:36:00.000Z","updated":"2017-07-16T04:15:32.006Z","comments":true,"path":"2017/06/09/2017/20170609/","link":"","permalink":"https://vlwq.github.io/2017/06/09/2017/20170609/","excerpt":"高程笔记一","text":"高程笔记一 JavaScript 是一种专为与网页交互而设计的脚本语言，由下列三个不同的部分组成：ECMAScript，由 ECMA-262 定义，提供核心语言功能；文档对象模型（DOM），提供访问和操作网页内容的方法和接口；浏览器对象模型（BOM），提供与浏览器交互的方法和接口。 JavaScript 的这三个组成部分，在当前五个主要浏览器（IE、Firefox、Chrome、Safari 和 Opera）中都得到了不同程度的支持。其中，所有浏览器对 ECMAScript 第 3 版的支持大体上都还不错，而对ECMAScript 5 的支持程度越来越高，但对 DOM 的支持则彼此相差比较多。对已经正式纳入 HTML5 标准的 BOM 来说，尽管各浏览器都实现了某些众所周知的共同特性，但其他特性还是会因浏览器而异。 &lt;script&gt;定义了下列 6 个属性。 async：可选。表示应该立即下载脚本，但不应妨碍页面中的其他操作， 比如下载其他资源或等待加载其他脚本。只对外部脚本文件有效。  charset：可选。表示通过src属性指定的代码的字符集。由于大多数浏览器会忽略它的值，因此这个属性很少有人用。  defer：可选。表示脚本可以延迟到文档完全被解析和显示之后再执行。 只对外部脚本文件有效。IE7 及更早版本对嵌入脚本也支持这个属性。  language：已废弃。原来用于表示编写代码使用的脚本语言（如JavaScript、JavaScript1.2或VBScript）。大多数浏览器会忽略这个属性，因此也没有必要再用了。  src：可选。表示包含要执行代码的外部文件。  type：可选。可以看成是language的替代属性；表示编写代码使用的脚本语言的内容类型（也称为 MIME 类型）。虽然 text/javascript 和 text/ecmascript 都已经不被推荐使用，但人们一直以来使用的都还是text/javascript。实际上，服务器在传送JavaScript文件时使用的MIME类型通常是application/x–javascript，但在type中设置这个值却可能导致脚本被忽略。另外，在非IE浏览器中还可以使用以下值：application/javascript和application/ecmascript。考虑到约定俗成和最大限度的浏览器兼容性，目前type属性的值依旧还是text/javascript。不过，这个属性并不是必需的，如果没有指定这个属性，则其默认值仍为text/javascript XHTML运行script1234567891011&lt;script type=&quot;text/javascript&quot;&gt;&lt;![CDATA[ function compare(a, b) &#123; if (a &lt; b) &#123; alert(&quot;A is less than B&quot;); &#125; else if (a &gt; b) &#123; alert(&quot;A is greater than B&quot;); &#125; else &#123; alert(&quot;A is equal to B&quot;); &#125; &#125;]]&gt;&lt;/script&gt; html文档模式 标准模式 12345678910&lt;!-- HTML 4.01 严格型 --&gt;&lt;!DOCTYPE HTML PUBLIC &quot;-//W3C//DTD HTML 4.01//EN&quot;&quot;http://www.w3.org/TR/html4/strict.dtd&quot;&gt;&lt;!-- XHTML 1.0 严格型 --&gt;&lt;!DOCTYPE html PUBLIC&quot;-//W3C//DTD XHTML 1.0 Strict//EN&quot;&quot;http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd&quot;&gt;&lt;!-- HTML 5 --&gt;&lt;!DOCTYPE html&gt; 非标准模式 12345678910111213141516&lt;!-- HTML 4.01 过渡型 --&gt;&lt;!DOCTYPE HTML PUBLIC&quot;-//W3C//DTD HTML 4.01 Transitional//EN&quot;&quot;http://www.w3.org/TR/html4/loose.dtd&quot;&gt;&lt;!-- HTML 4.01 框架集型 --&gt;&lt;!DOCTYPE HTML PUBLIC&quot;-//W3C//DTD HTML 4.01 Frameset//EN&quot;&quot;http://www.w3.org/TR/html4/frameset.dtd&quot;&gt;&lt;!-- XHTML 1.0 过渡型 --&gt;&lt;!DOCTYPE html PUBLIC&quot;-//W3C//DTD XHTML 1.0 Transitional//EN&quot;&quot;http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd&quot;&gt;&lt;!-- XHTML 1.0 框架集型 --&gt;&lt;!DOCTYPE html PUBLIC&quot;-//W3C//DTD XHTML 1.0 Frameset//EN&quot;&quot;http://www.w3.org/TR/xhtml1/DTD/xhtml1-frameset.dtd&quot;&gt; ECMAScript 中有 5 种简单数据类型（也称为基本数据类型）：Undefined、Null、Boolean、Number和 String。 3 个函数可以把非数值转换为数值：Number()、parseInt()和parseFloat()。第一个函数，即转型函数Number()可以用于任何数据类型，而另两个函数则专门用于把字符串转换成数值。这 3 个函数对于同样的输入会有返回不同的结果。Number()函数的转换规则如下。 如果是 Boolean 值，true 和 false 将分别被转换为 1 和 0。 如果是数字值，只是简单的传入和返回。 如果是 null 值，返回 0。 如果是 undefined，返回 NaN。 数值转换有 3 个函数可以把非数值转换为数值：Number()、parseInt()和 parseFloat()。第一个函数，即转型函数Number()可以用于任何数据类型，而另两个函数则专门用于把字符串转换成数值。这3个函数对于同样的输入会有返回不同的结果。Number()函数的转换规则如下。 如果是 Boolean 值，true 和 false 将分别被转换为 1 和 0。 如果是数字值，只是简单的传入和返回。 如果是 null 值，返回 0。 如果是 undefined，返回 NaN。 如果是字符串，遵循下列规则：  如果字符串中只包含数字（包括前面带正号或负号的情况），则将其转换为十进制数值，即”1”会变成1，”123”会变成123，而”011”会变成11（注意：前导的零被忽略了）； 如果字符串中包含有效的浮点格式，如”1.1”，则将其转换为对应的浮点数值 同样，也会忽略前导零）； 如果字符串中包含有效的十六进制格式，例如”0xf”，则将其转换为相同大小的 十进制整数值； 如果字符串是空的（不包含任何字符），则将其转换为 0； 如果字符串中包含除上述格式之外的字符，则将其转换为 NaN。 如果是对象，则调用对象的valueOf()方法，然后依照前面的规则转换返回的值。如果转换的结果是NaN，则调用对象的toString()方法，然后再次依照前面的规则转换返回的字符串值。根据这么多的规则使用Number()把各种数据类型转换为数值确实有点复杂。下面还是给出几个具体的例子吧。var num1 = Number(“Hello world!”); //NaNvar num2 = Number(“”); //0var num3 = Number(“000011”); //11 parseInt1234var num1 = parseInt(&quot;10&quot;, 2); //2 （按二进制解析）var num2 = parseInt(&quot;10&quot;, 8); //8 （按八进制解析）var num3 = parseInt(&quot;10&quot;, 10); //10 （按十进制解析）var num4 = parseInt(&quot;10&quot;, 16); //16 （按十六进制解析 parseFloat123456var num1 = parseFloat(&quot;1234blue&quot;); //1234 （整数）var num2 = parseFloat(&quot;0xA&quot;); //0var num3 = parseFloat(&quot;22.5&quot;); //22.5var num4 = parseFloat(&quot;22.34.5&quot;); //22.34var num5 = parseFloat(&quot;0908.5&quot;); //908.5var num6 = parseFloat(&quot;3.125e7&quot;); //31250000 字符String12345678910\\n 换行\\t 制表\\b 空格\\r 回车\\f 进纸\\\\ 斜杠\\&#x27; 单引号（&#x27;），在用单引号表示的字符串中使用。例如：&#x27;He said, \\&#x27;hey.\\&#x27;&#x27;\\&quot; 双引号（&quot;），在用双引号表示的字符串中使用。例如：&quot;He said, \\&quot;hey.\\&quot;&quot;\\xnn 以十六进制代码nn表示的一个字符（其中n为0～F）。例如，\\x41表示&quot;A&quot;\\unnnn 以十六进制代码nnnn表示的一个Unicode字符（其中n为0～F）。例如，\\u03a3表示希腊字符Σ 求模运算 求模（余数）操作符由一个百分号（%）表示，用法如下：var result = 26 % 5; // 等于 1与另外两个乘性操作符类似，求模操作符会遵循下列特殊规则来处理特殊的值： 如果操作数都是数值，执行常规的除法计算，返回除得的余数； 如果被除数是无穷大值而除数是有限大的数值，则结果是 NaN； 如果被除数是有限大的数值而除数是零，则结果是 NaN； 如果是 Infinity 被 Infinity 除，则结果是 NaN； 如果被除数是有限大的数值而除数是无穷大的数值，则结果是被除数； 如果被除数是零，则结果是零； 如果有一个操作数不是数值，则在后台调用 Number()将其转换为数值，然后再应用上面的规则。 减法123456var result1 = 5 - true; // 4，因为 true 被转换成了 1var result2 = NaN - 1; // NaNvar result3 = 5 - 3; // 2var result4 = 5 - &quot;&quot;; // 5，因为&quot;&quot; 被转换成了 0var result5 = 5 - &quot;2&quot;; // 3，因为&quot;2&quot;被转换成了 2var result6 = 5 - null; // 5，因为 null 被转换成了 0 全等和不全等记住：null == undefined 会返回 true，因为它们是类似的值；但 null === undefined 会返回 false，因为它们是不同类型的值 每个主要算术操作符（以及个别的其他操作符）都有对应的复合赋值操作符。这些操作符如下所示：1234567 乘/赋值（*=）； 除/赋值（/=）； 模/赋值（%=）； 加/赋值（+=）； 减/赋值（=）； 左移/赋值（&lt;&lt;=）； 有符号右移/赋值（&gt;&gt;=）； for-in语句123456for-in 语句是一种精准的迭代语句，可以用来枚举对象的属性。以下是 for-in 语句的语法：for (property in expression) statement下面是一个示例：for (var propName in window) &#123; document.write(propName);&#125; ECMAScript 对象的属性没有顺序。因此，通过 for-in 循环输出的属性名的顺序是不可预测的。具体来讲，所有属性都会被返回一次，但返回的先后次序可能会因浏览器而异。 js没有重载 ECMAScript 函数不能像传统意义上那样实现重载。而在其他语言（如Java）中，可以为一个函数编写两个定义，只要这两个定义的签名（接受的参数的类型和数量）不同即可。如前所述，ECMAScirpt函数没有签名，因为其参数是由包含零或多个值的数组来表示的。而没有函数签名，真正的重载是不可能做到的。 基本类型和引用类型的值 ECMAScript 变量可能包含两种不同数据类型的值：基本类型值和引用类型值。基本类型值指的是简单的数据段，而引用类型值指那些可能由多个值构成的对象。在将一个值赋给变量时，解析器必须确定这个值是基本类型值还是引用类型值。第 3 章讨论了 5 种基本数据类型：Undefined、Null、Boolean、Number 和 String。这 5 种基本数据类型是按值访问的，因为可以操作保存在变量中的实际的值。引用类型的值是保存在内存中的对象。与其他语言不同，JavaScript不允许直接访问内存中的位置，也就是说不能直接操作对象的内存空间。在操作对象时，实际上是在操作对象的引用而不是实际的对象。为此，引用类型的值是按引用访问的①。 在 Web 浏览器中，全局执行环境被认为是 window 对象数组的栈方法12345678var colors = new Array(); // 创建一个数组var count = colors.push(&quot;red&quot;, &quot;green&quot;); // 推入两项alert(count); //2count = colors.push(&quot;black&quot;); // 推入另一项alert(count); //3var item = colors.pop(); // 取得最后一项alert(item); //&quot;black&quot;alert(colors.length); //2 数组的重排序方法1234567891011121314151617181920数组中已经存在两个可以直接用来重排序的方法：reverse()和 sort()。有读者可能猜到了，reverse()方法会反转数组项的顺序。请看下面这个例子。var values = [1, 2, 3, 4, 5];values.reverse();alert(values); //5,4,3,2,1//自定义排序function compare(value1, value2) &#123; if (value1 &lt; value2) &#123; return 1; &#125; else if (value1 &gt; value2) &#123; return -1; &#125; else &#123; return 0; &#125;&#125;var values = [0, 1, 5, 10, 15];values.sort(compare);alert(values); // 15,10,5,1,0 数组的splice12345678910var colors = [&quot;red&quot;, &quot;green&quot;, &quot;blue&quot;];var removed = colors.splice(0,1); // 删除第一项alert(colors); // green,bluealert(removed); // red，返回的数组中只包含一项removed = colors.splice(1, 0, &quot;yellow&quot;, &quot;orange&quot;); // 从位置 1 开始插入两项alert(colors); // green,yellow,orange,bluealert(removed); // 返回的是一个空数组removed = colors.splice(1, 1, &quot;red&quot;, &quot;purple&quot;); // 插入两项，删除一项alert(colors); // green,red,purple,orange,bluealert(removed); // yellow，返回的数组中只包含一项 数组迭代方法123456789101112131415 every()：对数组中的每一项运行给定函数，如果该函数对每一项都返回 true，则返回 true。 filter()：对数组中的每一项运行给定函数，返回该函数会返回 true 的项组成的数组。 forEach()：对数组中的每一项运行给定函数。这个方法没有返回值。 map()：对数组中的每一项运行给定函数，返回每次函数调用的结果组成的数组。 some()：对数组中的每一项运行给定函数，如果该函数对任一项返回 true，则返回 true。var numbers = [1,2,3,4,5,4,3,2,1];var everyResult = numbers.every(function(item, index, array)&#123; return (item &gt; 2);&#125;);alert(everyResult); //falsevar someResult = numbers.some(function(item, index, array)&#123; return (item &gt; 2);&#125;);alert(someResult); //true 数组的归并方法 这两个方法都接收两个参数：一个在每一项上调用的函数和（可选的）作为归并基础的初始值。传给reduce()和 reduceRight()的函数接收4个参数：前一个值、当前值、项的索引和数组对象。这个函数返回的任何值都会作为第一个参数自动传给下一项。第一次迭代发生在数组的第二项上，因此第一个参数是数组的第一项，第二个参数就是数组的第二项。 123456使用 reduce()方法可以执行求数组中所有值之和的操作，比如：var values = [1,2,3,4,5];var sum = values.reduce(function(prev, cur, index, array)&#123; return prev + cur;&#125;);alert(sum); //15 js没有重载（深入理解）将函数名想象为指针，也有助于理解为什么 ECMAScript 中没有函数重载的概念。以下是曾在第 3章使用过的例子。 函数声明与函数表达式 本节到目前为止，我们一直没有对函数声明和函数表达式加以区别。而实际上，解析器在向执行环境中加载数据时，对函数声明和函数表达式并非一视同仁。解析器会率先读取函数声明，并使其在执行任何代码之前可用（可以访问）；至于函数表达式，则必须等到解析器执行到它所在的代码行，才会真正被解释执行。 12345678910alert(sum(10,10));function sum(num1, num2)&#123; return num1 + num2;&#125;下面这个报错alert(sum(10,10));var sum = function(num1, num2)&#123; return num1 + num2;&#125;; 作为值的函数12345678910function callSomeFunction(someFunction, someArgument)&#123; return someFunction(someArgument);&#125;这个函数接受两个参数。第一个参数应该是一个函数，第二个参数应该是要传递给该函数的一个值。然后，就可以像下面的例子一样传递函数了。function add10(num)&#123; return num + 10;&#125;var result1 = callSomeFunction(add10, 10);alert(result1); //20 递归12345678910111213141516function factorial(num)&#123; if (num &lt;=1) &#123; return 1; &#125; else &#123; return num * factorial(num-1) &#125;&#125;为了消除这种紧密耦合的现象，可以像下面这样使用 arguments.callee。function factorial(num)&#123; if (num &lt;=1) &#123; return 1; &#125; else &#123; return num * arguments.callee(num-1) &#125;&#125; 函数的apply和bind 每个函数都包含两个非继承而来的方法：apply()和 call()。这两个方法的用途都是在特定的作用域中调用函数，实际上等于设置函数体内 this 对象的值。首先，apply()方法接收两个参数：一个是在其中运行函数的作用域，另一个是参数数组。其中，第二个参数可以是 Array 的实例，也可以是arguments 对象。例如： 1234567891011function sum(num1, num2)&#123; return num1 + num2;&#125;function callSum1(num1, num2)&#123; return sum.apply(this, arguments); // 传入 arguments 对象&#125;function callSum2(num1, num2)&#123; return sum.apply(this, [num1, num2]); // 传入数组&#125;alert(callSum1(10,10)); //20alert(callSum2(10,10)); //20 call()方法与 apply()方法的作用相同，它们的区别仅在于接收参数的方式不同。对于 call()方法而言，第一个参数是 this 值没有变化，变化的是其余参数都直接传递给函数。换句话说，在使用call()方法时，传递给函数的参数必须逐个列举出来，如下面的例子所示。 1234567function sum(num1, num2)&#123; return num1 + num2;&#125;function callSum(num1, num2)&#123; return sum.call(this, num1, num2);&#125;alert(callSum(10,10)); //20 能够扩充函数赖以运行的作用域 123456789window.color = &quot;red&quot;;var o = &#123; color: &quot;blue&quot; &#125;;function sayColor()&#123; alert(this.color);&#125;sayColor(); //redsayColor.call(this); //redsayColor.call(window); //redsayColor.call(o); //blue ECMAScript 5 还定义了一个方法：bind()。这个方法会创建一个函数的实例，其 this 值会被绑定到传给 bind()函数的值。例如： 12345678910window.color = &quot;red&quot;;var o = &#123; color: &quot;blue&quot; &#125;;function sayColor()&#123; alert(this.color);&#125;var objectSayColor = sayColor.bind(o);objectSayColor(); //blue在这里，sayColor()调用 bind()并传入对象 o，创建了 objectSayColor()函数。objectSayColor()函数的this 值等于 o，因此即使是在全局作用域中调用这个函数，也会看到&quot;blue&quot;。 基本包装类型 ECMAScript 还提供了 3 个特殊的引用类型：Boolean、Number 和String。Object 构造函数也会像工厂方法一样，根据传入值的类型返回相应基本包装类型的实例。例如：var obj = new Object(“some text”);alert(obj instanceof String); //true Number 类型还提供了一些用于将数值格式化为字符串的方法。其中，toFixed()方法会按照指定的小数位返回数值的字符串表示，例如：var num = 10;alert(num.toFixed(2)); //“10.00”toFixed()方法可以表示带有 0 到 20 个小数位的数值。但这只是标准实现的范围，有些浏览器也可能支持更多位数 var num = 10;alert(num.toExponential(1)); //“1.0e+1”以上代码输出了”1.0e+1”；不过，这么小的数值一般不必使用 e 表示法。如果你想得到表示某个数值的最合适的格式，就应该使用 toPrecision()方法。var num = 99;alert(num.toPrecision(1)); //“1e+2”alert(num.toPrecision(2)); //“99”alert(num.toPrecision(3)); //“99.0” string截取1234567var stringValue = &quot;hello world&quot;;alert(stringValue.slice(3)); //&quot;lo world&quot;alert(stringValue.substring(3)); //&quot;lo world&quot;alert(stringValue.substr(3)); //&quot;lo world&quot;alert(stringValue.slice(3, 7)); //&quot;lo w&quot;alert(stringValue.substring(3,7)); //&quot;lo w&quot;alert(stringValue.substr(3, 7)); //&quot;lo worl&quot; 在传递给这些方法的参数是负值的情况下，它们的行为就不尽相同了。其中，slice()方法会将传入的负值与字符串的长度相加，substr()方法将负的第一个参数加上字符串的长度，而将负的第二个参数转换为0。最后，substring()方法会把所有负值参数都转换为 0。下 1234567var stringValue = &quot;hello world&quot;;alert(stringValue.slice(-3)); //&quot;rld&quot;alert(stringValue.substring(-3)); //&quot;hello world&quot;alert(stringValue.substr(-3)); //&quot;rld&quot;alert(stringValue.slice(3, -4)); //&quot;lo w&quot;alert(stringValue.substring(3, -4)); //&quot;hel&quot;alert(stringValue.substr(3, -4)); //&quot;&quot;（空字符串） 字符串位置方法var stringValue = “hello world”;alert(stringValue.indexOf(“o”, 6)); //7alert(stringValue.lastIndexOf(“o”, 6)); //4 Global对象 诸如 isNaN()、isFinite()、parseInt()以及 parseFloat()，实际上全都是 Global对象的方法。除此之外，Global 对象还包含其他一些方法。Global 对象的 encodeURI()和 encodeURIComponent()方法可以对 URI（Uniform ResourceIdentifiers，通用资源标识符）进行编码，以便发送给浏览器。有效的 URI 中不能包含某些字符，例如空格。而这两个 URI 编码方法就可以对 URI 进行编码，它们用特殊的 UTF-8 编码替换所有无效的字符，从而让浏览器能够接受和理解。 encodeURI()主要用于整个URI（例如，http://www.wrox.com/illegalvalue.htm），而encodeURIComponent()主要用于对URI 中的某一段（例如前面URI中的illegal value.htm）进行编码。它们的主要区别在于，encodeURI()不会对本身属于URI的特殊字符进行编码，例如冒号、正斜杠、问号和井字号；而encodeURIComponent()则会对它发现的任何非标准字符进行编码。 12345678910var uri = &quot;http://www.wrox.com/illegal value.htm#start&quot;;//&quot;http://www.wrox.com/illegal%20value.htm#start&quot;alert(encodeURI(uri));//&quot;http%3A%2F%2Fwww.wrox.com%2Fillegal%20value.htm%23start&quot;alert(encodeURIComponent(uri));使用 encodeURI()编码后的结果是除了空格之外的其他字符都原封不动，只有空格被替换成了%20。而 encodeURIComponent()方法则会使用对应的编码替换所有非字母数字字符。这也正是可以对整个 URI 使用 encodeURI()，而只能对附加在现有 URI 后面的字符串使用 encodeURIComponent()的原因所在。 与 encodeURI()和 encodeURIComponent()方法对应的两个方法分别是 decodeURI()和decodeURIComponent()。 eval()方法在 eval()中创建的任何变量或函数都不会被提升，因为在解析代码的时候，它们被包含在一个字符串中；它们只在 eval()执行的时候创建 window 对象 另一种取得 Global 对象的方法是使用以下代码：var global = function(){ return this;}(); Math对象123要找到数组中的最大或最小值，可以像下面这样使用 apply()方法。var values = [1, 2, 3, 4, 5, 6, 7, 8];var max = Math.max.apply(Math, values); Math.ceil()执行向上舍入，即它总是将数值向上舍入为最接近的整数； Math.floor()执行向下舍入，即它总是将数值向下舍入为最接近的整数； Math.round()执行标准舍入，即它总是将数值四舍五入为最接近的整数（这也是我们在数学课上学到的舍入规则） 1234567891011function selectFrom(lowerValue, upperValue) &#123; var choices = upperValue - lowerValue + 1; return Math.floor(Math.random() * choices + lowerValue);&#125;var num = selectFrom(2, 10);alert(num); // 介于 2 和 10 之间（包括 2 和 10）的一个数值//通过调用 selectFrom(2,10)就可以得到一个介于 2 和 10 之间（包括 2 和 10）的数值了。利用这个函数，可以方便地从数组中随机取出一项var colors = [&quot;red&quot;, &quot;green&quot;, &quot;blue&quot;, &quot;yellow&quot;, &quot;black&quot;, &quot;purple&quot;, &quot;brown&quot;];var color = colors[selectFrom(0, colors.length-1)];alert(color); // 可能是数组中包含的任何一个字符串 js引用类型1234567891011121314151617181920对象在 JavaScript 中被称为引用类型的值，而且有一些内置的引用类型可以用来创建特定的对象，现简要总结如下： 引用类型与传统面向对象程序设计中的类相似，但实现不同； Object 是一个基础类型，其他所有类型都从 Object 继承了基本的行为； Array 类型是一组值的有序列表，同时还提供了操作和转换这些值的功能； Date 类型提供了有关日期和时间的信息，包括当前日期和时间以及相关的计算功能； RegExp 类型是 ECMAScript 支持正则表达式的一个接口，提供了最基本的和一些高级的正则表达式功能。函数实际上是 Function 类型的实例，因此函数也是对象；而这一点正是 JavaScript 最有特色的地方。由于函数是对象，所以函数也拥有方法，可以用来增强其行为。因为有了基本包装类型，所以 JavaScript 中的基本类型值可以被当作对象来访问。三种基本包装类型分别是：Boolean、Number 和 String。以下是它们共同的特征： 每个包装类型都映射到同名的基本类型； 在读取模式下访问基本类型值时，就会创建对应的基本包装类型的一个对象，从而方便了数据操作； 操作基本类型值的语句一经执行完毕，就会立即销毁新创建的包装对象。在所有代码执行之前，作用域中就已经存在两个内置对象：Global 和 Math。在大多数 ECMAScript实现中都不能直接访问 Global 对象；不过，Web 浏览器实现了承担该角色的 window 对象。全局变量和函数都是 Global 对象的属性。Math 对象提供了很多属性和方法，用于辅助完成复杂的数学计算任务。","categories":[],"tags":[{"name":"高程","slug":"高程","permalink":"https://vlwq.github.io/tags/%E9%AB%98%E7%A8%8B/"}]},{"title":"算法","slug":"2017/20170608","date":"2017-06-08T02:36:00.000Z","updated":"2017-08-27T05:57:21.727Z","comments":true,"path":"2017/06/08/2017/20170608/","link":"","permalink":"https://vlwq.github.io/2017/06/08/2017/20170608/","excerpt":"排序","text":"排序 冒泡排序123456789101112131415161718192021222324252627var log = console.log.bind(console) // 元素交换function exchange(arr ,a , b)&#123; var temp = arr[b]; arr[b] = arr[a]; arr[a] = temp;&#125;function compare(arr , count)&#123; //log(&#x27;2----&#x27;, arr) for (var i = 0; i &lt; count ; i++) &#123; if (arr[i] &gt; arr[i+1]) &#123; // 相邻元素两两对比 var a = exchange(arr ,i , i+1) //log(&#x27;3-------&#x27;,a) &#125; &#125;&#125;function bubbleSort(array) &#123; //复制数组 var arr = array.slice(0) var len = arr.length; //控制次数 for (var i = 0; i &lt; len; i++) &#123; var count = len- 1 - i compare(arr , count) &#125; return arr;&#125; 二分查找1234567891011121314151617Array.prototype.binarySearch = function(obj) &#123; var value = 0; var left = 0; var right = this.length; while (left &lt;= right) &#123; var center = Math.floor((left + right) / 2); if (this[center] == obj) &#123; value = center; &#125; if (obj &lt; this[center]) &#123; right = center - 1; &#125; else &#123; left = center + 1; &#125; &#125; alert(value);&#125; 快速排序123456789101112131415161718192021function quickSort(arr)&#123; if(arr.length&lt;=1)&#123; return arr;//如果数组只有一个数，就直接返回； &#125; var num = Math.floor(arr.length/2);//找到中间数的索引值，如果是浮点数，则向下取整 var numValue = arr.splice(num,1);//找到中间数的值 var left = []; var right = []; for(var i=0;i&lt;arr.length;i++)&#123; if(arr[i]&lt;numValue)&#123; left.push(arr[i]);//基准点的左边的数传到左边数组 &#125; else&#123; right.push(arr[i]);//基准点的右边的数传到右边数组 &#125; &#125; return quickSort(left).concat([numValue],quickSort(right));//递归不断重复比较&#125;alert(quickSort([32,45,37,16,2,87]));//弹出“2,16,32,37,45,87”","categories":[],"tags":[{"name":"base","slug":"base","permalink":"https://vlwq.github.io/tags/base/"}]},{"title":"使用淘宝的cnpm代替npm","slug":"2017/20170702","date":"2017-06-05T02:36:00.000Z","updated":"2017-07-05T11:39:59.447Z","comments":true,"path":"2017/06/05/2017/20170702/","link":"","permalink":"https://vlwq.github.io/2017/06/05/2017/20170702/","excerpt":"使用国内 npm 镜像 npm 默认从国外的源（https://registry.npmjs.org/）获取和下载包信息，国内访问速度很不理想。就像其他很多开源软件都有国内镜像源，npm 也不例外。所以我们可以利用国内镜像源来加速模块安装。","text":"使用国内 npm 镜像 npm 默认从国外的源（https://registry.npmjs.org/）获取和下载包信息，国内访问速度很不理想。就像其他很多开源软件都有国内镜像源，npm 也不例外。所以我们可以利用国内镜像源来加速模块安装。 国内 npm 镜像源cnpmjs 镜像： 搜索地址：https://cnpmjs.org/registry ： https://r.cnpmjs.org/淘宝 npm 镜像： 搜索地址：https://npm.taobao.org/registry ： https://registry.npm.taobao.org/ 临时使用 1npm install express --registry https://r.cnpmjs.org/ 持久使用 npm 依次通过命令行、环境变量、.npmrc 文件来获取配置 方式一：命令行修改 npm 配置 1234# 配置 registrynpm config set registry https://r.cnpmjs.org/# 验证配置是否修改成功npm config get registry 方式二：修改环境变量 任何环境变量以npm_config_开头，将被解释为配置参数。以 windows 为例，打开：系统信息 &gt; 高级系统设置 &gt; 环境变量。可以新建一条用户变量或者系统变量 1234# 变量名npm_config_registry# 变量值https://r.cnpmjs.org/ 方式三：添加 npm 配置文件 .npmrc 1234567891011.npmrc 包含 4 级，可以按需求选择配置的地方项目目录：/path/to/my/project/.npmrc用户目录：~/.npmrc全局配置：$PREFIX/etc/.npmrc内置配置：/path/to/npm/.npmrc# .npmrc 配置registry = https://r.cnpmjs.org 命令行工具 cnpm还可以通过定制的 cnpm 命令来直接从淘宝镜像源安装模块，参考 https://npm.taobao.org/ 12345# 安装 cnpmnpm install -g cnpm --registry=https://registry.npm.taobao.org# 通过 cnpm 命令替代 npm 命令安装模块cnpm install express","categories":[],"tags":[{"name":"node","slug":"node","permalink":"https://vlwq.github.io/tags/node/"}]},{"title":"nginx配置静态网页","slug":"2017/20170225","date":"2017-02-25T02:36:00.000Z","updated":"2017-07-05T11:12:41.935Z","comments":true,"path":"2017/02/25/2017/20170225/","link":"","permalink":"https://vlwq.github.io/2017/02/25/2017/20170225/","excerpt":"负载均衡 1234567upstream bbs &#123; server music.istorm.cc:80 weight=1; &#125; upstream blog &#123; server http://0.0.0.0:2020 weight=1; &#125;","text":"负载均衡 1234567upstream bbs &#123; server music.istorm.cc:80 weight=1; &#125; upstream blog &#123; server http://0.0.0.0:2020 weight=1; &#125; 静态服务器和动态服务器配置 123456789101112131415161718192021222324252627282930313233server &#123; listen 80; server_name music.istorm.cc; location / &#123; #这个地方指定被访问的文件夹位置 root /var/www/static/music; index index.html; &#125; #location /二级域名/ &#123; # root /var/www/static/music; # index index.html; #&#125;&#125;server&#123; listen 80; # 配置 www.istorm.cc server_name www.istorm.cc; access_log /var/log/nginx/www.log; location / &#123; root /home/website_root; # proxy_pass 为反向代理后的 网站 proxy_pass http://0.0.0.0:2020; proxy_read_timeout 300; proxy_connect_timeout 300; proxy_redirect off; proxy_set_header X-Forwarded-Proto $scheme; proxy_set_header Host $http_host; proxy_set_header X-Real-IP $remote_addr; &#125;&#125;","categories":[],"tags":[{"name":"nginx","slug":"nginx","permalink":"https://vlwq.github.io/tags/nginx/"}]},{"title":"nginx 的 403 Forbidden errors","slug":"2017/20170224","date":"2017-02-24T02:36:00.000Z","updated":"2017-07-05T11:12:41.904Z","comments":true,"path":"2017/02/24/2017/20170224/","link":"","permalink":"https://vlwq.github.io/2017/02/24/2017/20170224/","excerpt":"nginx 的 403 Forbidden errors 表示你在请求一个资源文件但是nginx不允许你查看。403 Forbidden 只是一个HTTP状态码，像404,200一样不是技术上的错误。哪些场景需要返回403状态码的场景？","text":"nginx 的 403 Forbidden errors 表示你在请求一个资源文件但是nginx不允许你查看。403 Forbidden 只是一个HTTP状态码，像404,200一样不是技术上的错误。哪些场景需要返回403状态码的场景？ 1.网站禁止特定的用户访问所有内容，例：网站屏蔽某个ip访问。2.访问禁止目录浏览的目录，例：设置autoindex off后访问目录。3.用户访问只能被内网访问的文件。 以上几种常见的需要返回 403 Forbidden 的场景。 由于服务器端的错误配置导致在不希望nginx返回403时返回403 Forbidden。 1.权限配置不正确 这个是nginx出现403 forbidden最常见的原因。 为了保证文件能正确执行，nginx既需要文件的读权限,又需要文件所有父目录的可执行权限。 例如，当访问/usr/local/nginx/html/image.jpg时，nginx既需要image.jpg文件的可读权限，也需要/,/usr,/usr/local,/usr/local/nginx,/usr/local/nginx/html的可以执行权限。 解决办法:设置所有父目录为755权限，设置文件为644权限可以避免权限不正确。 2.目录索引设置错误（index指令配置） 网站根目录不包含index指令设置的文件。 例如，运行PHP的网站，通常像这样配置index index index.html index.htm index.php; 当访问该网站的时，nginx 会按照 index.html，index.htm ，index.php 的先后顺序在根目录中查找文件。如果这三个文件都不存在，那么nginx就会返回403 Forbidden。 如果index中不定义 index.php ，nginx直接返回403 Forbidden而不会去检查index.php是否存在。 同样对于如果运行jsp, py时也需要添加index.jsp,index.py到目录索引指令index中。 解决办法:添加首页文件到index指令，常见的是index.php，index.jsp，index.jsp或者自定义首页文件。","categories":[],"tags":[{"name":"nginx","slug":"nginx","permalink":"https://vlwq.github.io/tags/nginx/"}]},{"title":"nginx反向代理","slug":"2017/20170223","date":"2017-02-23T02:36:00.000Z","updated":"2017-07-05T11:12:42.019Z","comments":true,"path":"2017/02/23/2017/20170223/","link":"","permalink":"https://vlwq.github.io/2017/02/23/2017/20170223/","excerpt":"当只有一台服务器，而又想运行多个 web 后端服务，且希望网址为 www.XX.com / bbs.XX.com / blog.XX.com,怎么办，此时就要用nginx进行反向代理 以 ubuntu 为例 安装 NGINX 1$ sudo apt-get install nginx","text":"当只有一台服务器，而又想运行多个 web 后端服务，且希望网址为 www.XX.com / bbs.XX.com / blog.XX.com,怎么办，此时就要用nginx进行反向代理 以 ubuntu 为例 安装 NGINX 1$ sudo apt-get install nginx 修改 NGINX 的配置文件12# 配置文件在 /etc/nginx/nginx.confcd /etc/nginx 然后修改 nginx.conf,具体为:修改配置文件中 的 http{}在 http{} 中的末尾补上反向代理配置代码 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869user www-data;worker_processes auto;pid /run/nginx.pid;events &#123; worker_connections 768; # multi_accept on;&#125;http &#123; ## # 前面的代码再此不展示了,在 http&#123;&#125; 中补上以上代码 ## ## # 反向代理配置代码 ## # 注意端口号 8081 为 bbs 服务, 8082 为 blog 服务,8083 为 www 服务 upstream bbs &#123; server 127.0.0.1:8081 weight=1; &#125; upstream blog &#123; server 127.0.0.1:8082 weight=1; &#125; upstream www &#123; server 127.0.0.1:8083 weight=1; &#125; server&#123; listen 80; # 配置 www.bigbananas.cn server_name www.bigbananas.cn; access_log /var/log/nginx/www.log; location / &#123; root /home/website_root; &#125; &#125; server&#123; listen 80; # 配置 blog.bigbananas.cn server_name blog.bigbananas.cn; access_log /var/log/nginx/blog_access.log; location / &#123; root /home/todo_root; # proxy_pass 为反向代理后的 网站 proxy_pass http://127.0.0.1:8081/; proxy_read_timeout 300; proxy_connect_timeout 300; proxy_redirect off; proxy_set_header X-Forwarded-Proto $scheme; proxy_set_header Host $http_host; proxy_set_header X-Real-IP $remote_addr; &#125; &#125; server&#123; listen 80; # 配置 bbs.bigbananas.cn server_name bbs.bigbananas.cn; access_log /var/log/nginx/bbs_access.log; location / &#123; root /home/todo_root; # proxy_pass 为反向代理后的 网站 proxy_pass http://127.0.0.1:8082/; proxy_read_timeout 300; proxy_connect_timeout 300; proxy_redirect off; proxy_set_header X-Forwarded-Proto $scheme; proxy_set_header Host $http_host; proxy_set_header X-Real-IP $remote_addr; &#125; &#125;&#125; 3、 在重启 NGINX 服务 12$ sudo nginx -s reload 4、 在服务器启动 BLOG、BBS、WWW 服务 注意：端口号 8081 为 bbs 服务, 8082 为 blog 服务,8083 为 www 服务","categories":[],"tags":[{"name":"nginx","slug":"nginx","permalink":"https://vlwq.github.io/tags/nginx/"}]},{"title":"git还原某个特定的文件到之前的版本","slug":"2017/20170203","date":"2017-02-03T02:36:00.000Z","updated":"2017-08-27T05:56:31.019Z","comments":true,"path":"2017/02/03/2017/20170203/","link":"","permalink":"https://vlwq.github.io/2017/02/03/2017/20170203/","excerpt":"场景： 对于某个Git控制下的文件进行了修改，但是改的不满意，想退回到改之前的版本。假定该文件为 src/main/main.c","text":"场景： 对于某个Git控制下的文件进行了修改，但是改的不满意，想退回到改之前的版本。假定该文件为 src/main/main.c 解决方法： 第一步： 在命令行中输入 Git log src/main/main.c 得到该文件的commit 历史。 会得到类似下面的界面 第二步： 复制需要回退版本的hash，在此假设我们回退到 d98a0f565804ba639ba46d6e4295d4f787ff2949 ,则复制该序列即可 第三步：checkout 对应版本。格式为 git checkout , 在此即为命令行中输入 git checkout d98a0f565804ba639ba46d6e4295d4f787ff2949 src/main/main.c 第四步： commit checkout下来的版本。 如： git commit -m “revert to previous version”","categories":[],"tags":[{"name":"github","slug":"github","permalink":"https://vlwq.github.io/tags/github/"}]},{"title":"node启动listen EADDRINUSE","slug":"2017/20170121","date":"2017-01-21T02:36:00.000Z","updated":"2017-07-05T11:12:41.872Z","comments":true,"path":"2017/01/21/2017/20170121/","link":"","permalink":"https://vlwq.github.io/2017/01/21/2017/20170121/","excerpt":"我在使用elasticsearch的kibana插件时候，有一次启动，遇到这个错误： Error: listen EADDRINUSE 0.0.0.0:5601它的意思是，端口5601被其他进程占用。 故而，需要kill掉那个进程，或者更换kibana的端口号。","text":"我在使用elasticsearch的kibana插件时候，有一次启动，遇到这个错误： Error: listen EADDRINUSE 0.0.0.0:5601它的意思是，端口5601被其他进程占用。 故而，需要kill掉那个进程，或者更换kibana的端口号。 我先找到那个进程是什么： 方法： 12netstat -apn|grep 5601 然后kill掉，即可启动kibana。","categories":[],"tags":[{"name":"node","slug":"node","permalink":"https://vlwq.github.io/tags/node/"}]},{"title":"github怎么绑定自己的域名？","slug":"2017/20170113","date":"2017-01-13T02:36:00.000Z","updated":"2017-07-05T11:12:41.972Z","comments":true,"path":"2017/01/13/2017/20170113/","link":"","permalink":"https://vlwq.github.io/2017/01/13/2017/20170113/","excerpt":"向你的 Github Pages 仓库添加一个CNAME(一定要大写)文件其中只能包含一个顶级域名，像这样：1example.com","text":"向你的 Github Pages 仓库添加一个CNAME(一定要大写)文件其中只能包含一个顶级域名，像这样：1example.com 如果你是用 hexo 框架搭建博客并部署到 Github Pages 上，每次 hexo ghexo d 后会把你的博客所在目录下 public 文件夹里的东西都推到 Github Pages 仓库上，并且把 CNAME 文件覆盖掉，解决这个问题可以直接把 CNAME 文件添加到 source 文件夹里，这样每次推的时候就不用担心仓库里的 CNAME 文件被覆盖掉了。 向你的 DNS 配置中添加 3 条记录123@ A 192.30.252.153@ A 192.30.252.154www CNAME username.github.io. 用你自己的 Github 用户名替换 username推荐使用 DNSPOD 的服务，使用国外的 DNS 解析服务可能有被墙的风险。至于如何使用 DNSPOD 解析域名，参考http://jingyan.baidu.com/article/546ae1857c4ee81149f28cbe.html3.等待你的 DNS 配置生效对DNS的配置不是立即生效的，过10分钟再去访问你的域名看看有没有配置成功 : )","categories":[],"tags":[{"name":"github","slug":"github","permalink":"https://vlwq.github.io/tags/github/"}]},{"title":"flex布局","slug":"2016/20161112","date":"2016-11-12T02:36:00.000Z","updated":"2017-07-05T11:09:57.934Z","comments":true,"path":"2016/11/12/2016/20161112/","link":"","permalink":"https://vlwq.github.io/2016/11/12/2016/20161112/","excerpt":"flex布局，做了3个demo","text":"flex布局，做了3个demo #垂直水平居中 123456789101112131415161718192021222324252627282930313233&lt;!DOCTYPE html&gt;&lt;html lang=&quot;en&quot;&gt;&lt;head&gt; &lt;meta charset=&quot;UTF-8&quot;&gt; &lt;title&gt;首页&lt;/title&gt; &lt;style&gt; body&#123; margin:0px; &#125; .parent&#123; position:absolute; background-color: #00a2d4; width: 100%; height: 100%; display: flex; justify-content: center; align-items: center; &#125; .child&#123; width: 150px; height: 150px; background-color: red; &#125; &lt;/style&gt;&lt;/head&gt;&lt;body&gt;&lt;div class=&quot;parent&quot;&gt; &lt;div class=&quot;child&quot;&gt; &lt;/div&gt;&lt;/div&gt;&lt;/body&gt;&lt;/html&gt; #博客布局 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071727374757677&lt;!DOCTYPE html&gt;&lt;html lang=&quot;en&quot;&gt;&lt;head&gt; &lt;meta charset=&quot;UTF-8&quot;&gt; &lt;title&gt;首页&lt;/title&gt; &lt;style&gt; body&#123; margin:0px; &#125; .blog&#123; position:absolute; width: 100%; height: 100%; &#125; .navbar&#123; width: 100%; height:50px; background-color: black; &#125; .main&#123; background-color: lightgoldenrodyellow; width: 100%; position: absolute; top: 50px; bottom: 0px; /* 水平垂直居中 */ display: flex; justify-content: center; align-items: center; &#125; .content&#123; width: 90%; height: 100%; background-color: #00a2d4; display: flex; &#125; .article&#123; background-color: chocolate; flex: 1; flex: 0 0 75%; &#125; .aside&#123; background-color: rebeccapurple; flex: 1; flex: 0 0 25%; display: flex; align-items: center; flex-direction: column; &#125; .box&#123; background-color: #2D82FF; width: 80%; margin-top :10px; margin-bottom: 10px; &#125; &lt;/style&gt;&lt;/head&gt;&lt;body&gt;&lt;div class=&quot;blog&quot;&gt; &lt;div class=&quot;navbar&quot;&gt;&lt;/div&gt; &lt;div class=&quot;main&quot;&gt; &lt;div class=&quot;content&quot;&gt; &lt;div class=&quot;article&quot;&gt;&lt;/div&gt; &lt;div class=&quot;aside&quot;&gt; &lt;div class=&quot;box&quot;&gt;111111111111111&lt;/div&gt; &lt;div class=&quot;box&quot;&gt;222222222222&lt;/div&gt; &lt;div class=&quot;box&quot;&gt;33333333333&lt;/div&gt; &lt;div class=&quot;box&quot;&gt;4444444444444&lt;/div&gt; &lt;div class=&quot;box&quot;&gt;55555555555555&lt;/div&gt; &lt;/div&gt; &lt;/div&gt; &lt;/div&gt;&lt;!-- &lt;div class=&quot;footer&quot;&gt;&lt;/div&gt;--&gt;&lt;/div&gt;&lt;/body&gt;&lt;/html&gt; #Gird布局 12345678910111213141516171819202122232425262728293031323334353637383940414243444546&lt;!DOCTYPE html&gt;&lt;html lang=&quot;en&quot;&gt;&lt;head&gt; &lt;meta charset=&quot;UTF-8&quot;&gt; &lt;title&gt;Flex布局&lt;/title&gt; &lt;style type=&quot;text/css&quot;&gt; .Grid&#123; display: flex; &#125; .Grid-cell&#123; flex: 1; &#125; .Grid-cell.u-full&#123; flex: 0 0 100%; &#125; .Grid-cell.u-1of2&#123; flex: 0 0 50%; &#125; .Grid-cell.u-1of3&#123; flex: 0 0 33.3333%; &#125; .Grid-cell.u-1of4&#123; flex: 0 0 25%; &#125; &lt;/style&gt;&lt;/head&gt;&lt;body&gt;&lt;div class=&quot;Grid&quot;&gt; &lt;div class=&quot;Grid-cell u-1of4&quot; style=&quot;background-color: #2D82FF&quot;&gt;1/4&lt;/div&gt; &lt;div class=&quot;Grid-cell&quot; style=&quot;background-color: #6DDA79&quot;&gt;auto&lt;/div&gt; &lt;div class=&quot;Grid-cell u-1of3&quot; style=&quot;background-color: #46A0CE&quot;&gt;1/3&lt;/div&gt;&lt;/div&gt;&lt;p&gt;&lt;/p&gt;&lt;div class=&quot;Grid&quot;&gt; &lt;div class=&quot;Grid-cell&quot; style=&quot;background-color: #2D82FF&quot;&gt;auto&lt;/div&gt; &lt;div class=&quot;Grid-cell u-1of3&quot; style=&quot;background-color: #6DDA79&quot;&gt;1/3&lt;/div&gt;&lt;/div&gt;&lt;p&gt;&lt;/p&gt;&lt;div class=&quot;Grid&quot;&gt; &lt;div class=&quot;Grid-cell u-1of2&quot; style=&quot;background-color: #2D82FF&quot;&gt;1/2&lt;/div&gt; &lt;div class=&quot;Grid-cell&quot; style=&quot;background-color: #6DDA79&quot;&gt;auto&lt;/div&gt; &lt;div class=&quot;Grid-cell&quot; style=&quot;background-color: #46A0CE&quot;&gt;auto&lt;/div&gt;&lt;/div&gt;&lt;/body&gt;&lt;/html&gt; #圣杯布局 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152&lt;!DOCTYPE html&gt;&lt;html lang=&quot;en&quot;&gt;&lt;head&gt; &lt;meta charset=&quot;UTF-8&quot;&gt; &lt;title&gt;Title&lt;/title&gt; &lt;style&gt; body&#123; margin: 0px; &#125; .HolyGrail &#123; display: flex; min-height: 100vh; flex-direction: column; &#125; header, footer &#123; flex: 1; &#125; .HolyGrail-body &#123; display: flex; flex: 1; &#125; .HolyGrail-content &#123; flex: 1; &#125; .HolyGrail-nav, .HolyGrail-ads &#123; /* 两个边栏的宽度设为5em */ flex: 0 0 5em; &#125; .HolyGrail-nav &#123; /* 导航放到最左边 */ order: -1; &#125; &lt;/style&gt;&lt;/head&gt;&lt;body&gt;&lt;body class=&quot;HolyGrail&quot;&gt;&lt;header style=&quot;background-color: #2D82FF&quot;&gt;...&lt;/header&gt;&lt;div class=&quot;HolyGrail-body&quot;&gt; &lt;main class=&quot;HolyGrail-content&quot; style=&quot;background-color: #6DDA79&quot;&gt;...&lt;/main&gt; &lt;nav class=&quot;HolyGrail-nav&quot; style=&quot;background-color: yellow&quot;&gt;...&lt;/nav&gt; &lt;aside class=&quot;HolyGrail-ads&quot; style=&quot;background-color: rebeccapurple&quot;&gt;...&lt;/aside&gt;&lt;/div&gt;&lt;footer style=&quot;background-color: #2D82FF&quot;&gt;...&lt;/footer&gt;&lt;/body&gt;&lt;/body&gt;&lt;/html&gt;","categories":[],"tags":[{"name":"html5","slug":"html5","permalink":"https://vlwq.github.io/tags/html5/"}]},{"title":"guajs简单版本","slug":"2016/20161111","date":"2016-11-11T02:36:00.000Z","updated":"2017-07-05T11:09:58.087Z","comments":true,"path":"2016/11/11/2016/20161111/","link":"","permalink":"https://vlwq.github.io/2016/11/11/2016/20161111/","excerpt":"guajs简单版本，备用工具","text":"guajs简单版本，备用工具 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455var log = function() &#123; console.log.apply(console, arguments)&#125;var e = function(selector) &#123; return document.querySelector(selector)&#125;var es = function(selector) &#123; return document.querySelectorAll(selector)&#125;var appendHtml = function(element, html) &#123; element.insertAdjacentHTML(&#x27;beforeend&#x27;, html)&#125;var bindEvent = function(element, eventName, callback) &#123; element.addEventListener(eventName, callback)&#125;var toggleClass = function(element, className) &#123; if (element.classList.contains(className)) &#123; element.classList.remove(className) &#125; else &#123; element.classList.add(className) &#125;&#125;var removeClassAll = function(className) &#123; var selector = &#x27;.&#x27; + className var elements = document.querySelectorAll(selector) for (var i = 0; i &lt; elements.length; i++) &#123; var e = elements[i] e.classList.remove(className) &#125;&#125;var bindAll = function(selector, eventName, callback) &#123; var elements = document.querySelectorAll(selector) for(var i = 0; i &lt; elements.length; i++) &#123; var e = elements[i] bindEvent(e, eventName, callback) &#125;&#125;// find 函数可以查找 element 的子元素var find = function(element, selector) &#123; return element.querySelector(selector)&#125;// find 函数可以查找 element 的所有子元素var findAll = function(element, selector) &#123; return element.querySelectorAll(selector)&#125;","categories":[],"tags":[{"name":"guagua","slug":"guagua","permalink":"https://vlwq.github.io/tags/guagua/"}]},{"title":"js同步异步","slug":"2016/20161110","date":"2016-11-10T02:36:00.000Z","updated":"2017-07-05T11:09:57.972Z","comments":true,"path":"2016/11/10/2016/20161110/","link":"","permalink":"https://vlwq.github.io/2016/11/10/2016/20161110/","excerpt":"guasync file/* 同步和异步编程的概念 同步的意思是 函数通过返回值来传递数据 函数从获取数据一直到返回数据之间的时间一直在等待 异步的意思是 函数通过回调函数的方式来传递获取的数据 函数执行后立刻就返回了, 数据获取成功后, 调用回调函数并传递参数 */","text":"guasync file/* 同步和异步编程的概念 同步的意思是 函数通过返回值来传递数据 函数从获取数据一直到返回数据之间的时间一直在等待 异步的意思是 函数通过回调函数的方式来传递获取的数据 函数执行后立刻就返回了, 数据获取成功后, 调用回调函数并传递参数 */ 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859var fs = require(&#x27;fs&#x27;)var log = console.log.bind(console, &#x27;---&#x27;)// 我们先写入文件// 写入成功后 读取当前目录看是否有这个文件// 如果有这个文件, 我们读取文件的内容并打印出来// 然后我们删除这个文件var filename = &#x27;message.txt&#x27;console.log(&#x27;写入前&#x27;)fs.writeFile(filename, &#x27;你好 Node.js&#x27;, (err) =&gt; &#123; fs.readdir(&#x27;.&#x27;, function(err, files)&#123; console.log(&#x27;读取文件成功 files&#x27;, files) if(files.includes(filename)) &#123; fs.readFile(filename, (err, data) =&gt; &#123; // 读取文件成功, 打印并删除文件, data 并不是 string 而是一个 Buffer 对象(以后会讲) console.log(&#x27;读取成功&#x27;, data) fs.unlink(filename, (err) =&gt; &#123; console.log(`最后一步, 文件 $&#123;filename&#125; 成功删除`) &#125;) &#125;) &#125; &#125;)&#125;)console.log(&#x27;写入函数调用后&#x27;)var guasync = function(callback) &#123; // setTimeout 函数一定会把第一个参数放到后台去执行 setTimeout(function() &#123; callback() &#125;, 0)&#125;var processFiles = function() &#123; var filename = &#x27;guasync.txt&#x27; log(&#x27;同步写入前&#x27;) fs.writeFileSync(filename, &#x27;你好 同步 api&#x27;) var files = fs.readdirSync(&#x27;.&#x27;) console.log(&#x27;读取文件成功 files&#x27;, files) if(files.includes(filename)) &#123; var data = fs.readFileSync(filename) console.log(&#x27;读取成功&#x27;, data) fs.unlinkSync(filename) console.log(`最后一步, 文件 $&#123;filename&#125; 成功删除`) &#125; log(&#x27;同步写入完成后&#x27;)&#125;// http://www.kuaidadi.com/assets/js/animate.jsguasync(function () &#123; processFiles()&#125;)log(&#x27;干点别的事情&#x27;)// guasync(function() &#123;// step1()// step2()// &#125;) guasync ajax1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253var log = console.log.bind(console)var ajax = function(request) &#123; /* request 是一个 object, 有如下属性 method, 请求的方法, string url, 请求的路径, string data, 请求发送的数据, 如果是 GET 方法则没这个值, string callback, 响应回调, function 本题不会就放弃, 本题带了一个用法在下方 */ var data = null var r = new XMLHttpRequest() r.open(request.method, request.url, false) r.setRequestHeader(&#x27;Content-Type&#x27;, request.contentType) r.onreadystatechange = function(event) &#123; if(r.readyState === 4) &#123; log(&#x27;ajax 状态 4 准备执行 callback&#x27;) data = r.response // request.callback(r.response) &#125; &#125; if (request.method === &#x27;GET&#x27;) &#123; r.send() &#125; else &#123; r.send(request.data) &#125; return data&#125;var request = &#123; method: &#x27;GET&#x27;, url: &#x27;https://vip.cocode.cc/sandbox/todo/3400711034/all&#x27;, callback: function (r) &#123; log(&#x27;响应完成 callback&#x27;) &#125;&#125;var guasync = function(callback) &#123; // setTimeout 函数一定会把第一个参数放到后台去执行 setTimeout(function() &#123; callback() &#125;, 0)&#125;guasync(function() &#123; log(&#x27;ajax 开始&#x27;) var data = ajax(request) log(&#x27;ajax 结束&#x27;, data)&#125;)log(&#x27;guasync 结束&#x27;)","categories":[],"tags":[{"name":"guagua","slug":"guagua","permalink":"https://vlwq.github.io/tags/guagua/"}]},{"title":"HTML5 新内容","slug":"2016/20161109","date":"2016-11-09T02:36:00.000Z","updated":"2017-07-05T11:09:58.123Z","comments":true,"path":"2016/11/09/2016/20161109/","link":"","permalink":"https://vlwq.github.io/2016/11/09/2016/20161109/","excerpt":"HTML5 新内容主要是以下几点 语义化标签如 article、footer、header、nav、section视频和音频标签 video 和 audio本地离线存储 localStorage 和 sessionStorage新增表单特性如新控件 calendar email color 等用于绘图的 canvas 标签(用于游戏等)用于高性能图形的 WebGL(用于游戏等, 这个是专用领域的知识, 我们不会直接接触)","text":"HTML5 新内容主要是以下几点 语义化标签如 article、footer、header、nav、section视频和音频标签 video 和 audio本地离线存储 localStorage 和 sessionStorage新增表单特性如新控件 calendar email color 等用于绘图的 canvas 标签(用于游戏等)用于高性能图形的 WebGL(用于游戏等, 这个是专用领域的知识, 我们不会直接接触) HTML5 语义化 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071727374757677787980818283848586878889909192939495969798原来的标签&lt;div id=&quot;wrapper&quot;&gt; &lt;div id=&quot;header&quot;&gt;&lt;/div&gt; &lt;div id=&quot;main&quot;&gt; &lt;div id=&quot;sidebar&quot;&gt;&lt;/div&gt; &lt;div id=&quot;content&quot;&gt;&lt;/div&gt; &lt;/div&gt; &lt;div id=&quot;footer&quot;&gt;&lt;/div&gt;&lt;/div&gt;完整的 html5 语义化标签是这样的&lt;!DOCTYPE html&gt;&lt;html&gt; &lt;title&gt;标题&lt;/title&gt; &lt;body&gt; &lt;header&gt;&lt;/header&gt; &lt;nav&gt;导航&lt;/nav&gt; &lt;article&gt; &lt;section&gt;区块&lt;/section&gt; &lt;/article&gt; &lt;aside&gt;侧栏&lt;/aside&gt; &lt;footer&gt;页脚&lt;/footer&gt; &lt;/body&gt;&lt;/html&gt;&lt;div class=&#x27;article&#x27;&gt; &lt;div class=&#x27;title&#x27;&gt; 前端掏粪指南 &lt;/div&gt; &lt;div class=&#x27;content&#x27;&gt; 前端掏粪指南 前端掏粪指南 前端掏粪指南 前端掏粪指南 前端掏粪指南 前端掏粪指南 前端掏粪指南 &lt;/div&gt;&lt;/div&gt;&lt;div class=&#x27;article&#x27;&gt; &lt;h1 class=&#x27;title&#x27;&gt; 前端掏粪指南 &lt;/h1&gt; &lt;p class=&#x27;content&#x27;&gt; 前端掏粪指南 前端掏粪指南 前端掏粪指南 前端掏粪指南 前端掏粪指南 前端掏粪指南 前端掏粪指南 &lt;/p&gt; &lt;gua&gt;&lt;/gua&gt;&lt;/div&gt;gua &#123; display: inline-block; width: 42px; height: 42px; background: url(&#x27;gua.png&#x27;);&#125;视频和音频标签和配套的 JS API 是新加入的功能以前的话只能依赖 flash, 现在有 video 和 audio带控制器的视频标签, 不同浏览器有不同的文件格式要求所以用 2 个 source 标签指定不同的视频格式&lt;video width=&quot;300&quot; height=&quot;200&quot; controls=&quot;controls&quot;&gt; &lt;source src=&quot;movie.mp4&quot;&gt; &lt;source src=&quot;movie.ogv&quot;&gt;&lt;/video&gt;带控制器的音频标签, 不同浏览器有不同的文件格式要求所以用 2 个 source 标签指定不同的音频格式&lt;audio id=&#x27;id-audio-player&#x27; controls=&quot;controls&quot;&gt; &lt;source src=&quot;audio.ogg&quot;&gt; &lt;source src=&quot;audio.mp3&quot;&gt;&lt;/audio &gt;audio 基本操作如下var a = document.querySelector(&#x27;#id-audio-player&#x27;)a.play() // 播放a.pause() // 暂停a.autoplay // bool 属性a.src // 音乐文件的地址a.volume // 音量, 0 - 1.0a.duration // 时长, 秒为单位a.currentTime = 1 // 当前播放时间, 秒为单位a.playbackRate // 播放速率, 默认为 1官方文档如下(文档永远是这样的)https://developer.mozilla.org/en/docs/Web/HTML/Element/audio HTML5 提供两种存储方法 localStorage 与 sessionStoragelocalStorage 与 sessionStorage 都是用来存储数据的使用方式一样, 区别只在于过期时间localStorage 没有过期时间, 要用 clear remove 主动删除数据sessionStorage 的数据在用户关闭浏览器后将被删除 由于之前有使用, 这里就不讲了 1234567891011121314新增表单特性如控件 calendar email color 等&lt;input type=&#x27;calendar&#x27;&gt;boolean 值的属性只要写了属性就是 truefalse&lt;input type=&quot;checkbox&quot;&gt;true&lt;input type=&quot;checkbox&quot; checked&gt;&lt;input type=&quot;checkbox&quot; checked=&quot;checked&quot;&gt;&lt;input type=&quot;checkbox&quot; checked=&quot;&quot;&gt;&lt;input type=&quot;checkbox&quot; checked=&quot;false&quot;&gt; 用于绘图的 canvas 标签(用于游戏等)canvas 标签提供一块画布, 可以访问画布中的像素点主要用途是游戏或者是高级复杂的图形效果例如 particles.js phaser.js 这些库, 例子如下https://phaser.io/examples/v2/weapon/fire-rate 移动网页手机网页和电脑网页的技术是一样的区别仅在屏幕尺寸和交互方式下面只列出手机页面开发中重要的点 1234567891011121 设置 viewportviewport 是 html 的父元素在手机上需要用下面的语句设置它的尺寸&lt;meta name=&quot;viewport&quot; content=&quot;width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no&quot;&gt;属性解释width=device-width 宽度等于设备宽度height=device-height 高度等于设备高度initial-scale 初始缩放比例minimum-scale 允许用户缩放的最小比例maximum-scale 允许用户缩放的最大比例user-scalable 是否允许用户缩放 2 调试页面可以用 chrome 的开发工具调试手机页面但是由于浏览器兼容性问题, 最终的外观得用手机真机来检验标签/css 的兼容性问题有很多网站可以查询比如下面这个网站caniuse.com 3 媒体查询媒体查询实际上是用来做响应式设计的响应式设计就是一套 CSS 根据当前的分辨率选择不同的样式现在已经没有前几年那么热门了, 不过我们还是过一遍 媒体查询主要用来: 检测媒体的类型, 比如 screen, tv等 检测布局视口的特性, 比如视口的宽高分辨率等123456用法@media all and (min-width: 200px) and (max-width: 300px)&#123; body &#123; background: red; &#125;&#125; 上面代码中, all 是媒体类型, 代表任何设备and 是逻辑操作意思是, 对于任何设备, 在宽度在 200-300 的范围内应用这个样式 4 Hybrid App(混合开发)混合开发说的是, 你写的网页运行在手机程序里本来网页能提供的功能是有限的但是应用程序可以给页面添加函数在这种情况下, js 就可以调用别人提供的功能这就是混合开发的基础 比如你 js 不能实现让手机震动的功能但是别的程序能实现这个功能, 并且把这个功能注册为你网页中的一个 js 函数这样 js 也就拥有这个功能了然后你调用 vfds() 就让手机震动了 这样的效果就是原生代码(相对于 js 而言的官方开发语言)实现功能并且提供 js 函数js 代码用别人提供的功能写逻辑 说穿了就这么一回事, 无任何难度的普通掏粪而已","categories":[],"tags":[{"name":"html5","slug":"html5","permalink":"https://vlwq.github.io/tags/html5/"}]},{"title":"linux相关","slug":"2016/20161108","date":"2016-11-08T02:36:00.000Z","updated":"2017-07-05T11:09:58.154Z","comments":true,"path":"2016/11/08/2016/20161108/","link":"","permalink":"https://vlwq.github.io/2016/11/08/2016/20161108/","excerpt":"Linux 服务器介绍和使用常用 Linux 版本分析常用工具/概念/使用方式以前和现在的服务器(托管和云平台)服务器配置部署项目","text":"Linux 服务器介绍和使用常用 Linux 版本分析常用工具/概念/使用方式以前和现在的服务器(托管和云平台)服务器配置部署项目 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172173174175176177178179180181182183184185186187188189190191192193194195196197198199200201202203204205206207208209210211212213214215216217218219220221222223224225226227228229230231232233234235236237238239240241242243244245246247248249250251252253254255256257258259260261262263264265266267268269270271272273274275276277278279280281282283284285286287288289290291292293294295296297298299300301302303304305306307308309310311312313314315316317318319320321322323324325326327328329330331332333334335336337338339340341342343344345346347348349350351352353354355356357358359360361362363364365366367368369370371372373374375376377378379380381382383384385386387388389390391392393394395396397398399400401402403404405406407408409410411412413414415416417418419420421422423424425426427428429域名购买(腾讯云买 .cc 域名)VPS购买, 可以用下面的服务(论坛使用的主机商), 2.5刀/月的即可http://www.vultr.com/?ref=6991688 地址选 日本, 如果不能访问, 那么就删除再新建一个为什么服务器多用 Linux? 微软很贵, Linux 免费Linux 生态圈更好Linux 的各种版本分析Debian 最好的 最稳定Ubuntu 抄的 debian, 用途广泛, 用户多(我们用的是 ubuntu 1604)CentOS 垃圾 工具老旧, 使用不方便连接服务器推荐使用 cmder 软件(windows下)如果在 mac 下, 直接用终端连接系统配置程序安装PATH命令参数权限用户用户组常用操作pwdprint working dir显示现在所处的目录ls不带参数就显示当前目录下的所有文件程序可以加选项-l 显示详细信息-h 人性化显示文件尺寸-a 显示所有文件， 以 . 开头的文件是隐藏文件还可以带一个目录当参数，这样就会显示这个目录ls /usr下面两个是等价的ls -l -hls -lh输入命令时, 可以用 tab 补全cdcd /usr改变当前目录 . 代表当前目录 .. 代表上级目录cd 不带参数就回到默认的家目录, 与 cd ~ 的效果是一样的每个用户都有一个家目录，默认在 /home/用户名root 用户的家目录是 /root我们可以在 linux 命令行中使用 nano 这个编辑器, 很方便操作文件与目录cp复制出一个文件，用法如下cp a.txt b.txt复制 a.txt 并把新文件取名为 b.txt复制目录要加上 -r 参数cp -r a bmkdir创建一个目录-p 可以一次性创建多层目录mkdir -p a/b/crmdir只能用来删除一个空目录rm这个命令直接删除东西，很危险，一般不要用删除文件或者目录-f 强制删除-r 用来递归删除目录mv移动文件或者文件夹也可以用来改名mv a.txt b.txtmv b.txt ../mv b.txt ../gua.txt可以用 mv xx /tmp 的方式来将文件放入临时文件夹（/tmp是操作系统提供的临时文件夹，重启会删除里面的所有文件）ls -l /usr/bin/ &gt; b.txtcat显示文件内容tac反过来显示文件内容nl显示内容并附带行号more less head tailmore 可以分屏分批看文件内容less 比 more 更高级，可以前后退看文件h 显示屏幕帮助, q 退出 less 程序head 可以显示文件的前 10 行tail 可以显示文件的后 10 行head 和 tail 有一个 -n 参数head -n 20 a.guatouchtouch a.gua如果 a.gua 存在就更新修改时间如果 a.gua 不存在就创建文件权限操作腾讯主机默认是用 ubuntu 这个用户登录, 为了方便操作, 统一选择 root 用户登录sudo用管理员帐户执行程序比如安装程序或者修改一些系统配置都需要管理员权限文件权限 文件类型 用户 用户组 文件大小 修改日期 文件名-rw-r--r-- 1 root root 45 May 24 10:17 lazy_dog.txt-rw-r--r-- 1 root root 56 May 24 09:47 ls-error.txt-rw-r--r-- 1 root root 30 May 24 09:45 ls-output.txtdrwxr-xr-x 4 root root 4096 May 24 03:37 node9 drwxr-xr-x 第一位是表示文件类型, 后面每三位分为一组, 每组表示的权限意思是一样的文件类型 是否可读 是否可写 是否可执行d r w x- r w x其中 d 表示 目录 directory, - 表示普通文件三组 rwx 分表代表 所属用户|同组用户(文件所属的群组)|其他用户rwx 可以用数字表示为 421777 表示三组都是 rwx rwx rwx也就是 -rwxrwxrwx每一位使用的是 2 进制数字表示210于是乎r-- 就是 4rw- 就是 6rwx 就是 7r-x 就是 5-rw-rw-r-- 文件的访问权限1 文件的链接数目(这个不用关心)root 文件所有者的用户名root 文件所属用户组10 文件大小（单位是字节）11/09 20:28 上次修改文件的日期和时间b.gua 文件名// 我们只考虑一个 root 用户的情况, 所以这部分不演示了, 直接跳过chown改变文件的用户chown gua c.guachown gua:gua c.guachmod改变文件权限666 这种表示按照 8 进制数字更改, 换成字符就是 rw- rw- rw-u user 表示文件所有者g group 表示文件所属群组o others 表示其他用户a all 表示 ugo 的组合+x 表示添加 x 权限, 等价于 a+x, 文件所有者/文件所属群组/其他用户都添加 x 权限-x 表示减少 x 权限chmod 666 a.txtchmod +x b.txtchmod -x tmp信息查找file显示文件的类型（不是百分之百准确）uname显示操作系统的名字或者其他信息uname -runame -awhichwhich perl有时候开发语言里会提到 3p, 也就是 perl php pythonwhich pwd显示 pwd 的具体路径whereiswhereis ls显示更全面的信息whoamifind . -name &quot;&quot;奇怪符号~ 家目录快捷方式&gt; 覆盖式重定向&gt;&gt; 追加重定向| 管道, 很麻烦 以后说`` 获取命令执行的结果比如 echo pwd 输出的就是 pwd 这个字符串echo `pwd` 输出的是 pwd 命令执行的结果, 相当于一个变量&amp; 后台执行node app.js &amp;可以用 fg 命令把一个在后台的程序拉到前台来可以用 Ctrl-z 来把一个前台的程序放到后台去挂起() 开新的子进程shell执行(不用掌握这一条, 因为几乎没人用)history查看历史命令grep查找这两个一般配合使用history | grep touchps查看进程, 一般用下面的用法ps axps ax | grep node查看带 node 字符串的进程kill 和 killall 杀进程用 ps ax 找到进程id (pid)kill [pid]kill -9 [pid]kill -15 [pid]killall 是用进程名字来杀进程后台前台fgjobs快捷键C-z 把正在运行的程序挂起并放在后台C-c 中断程序的执行C-d 输入文件终止符(end of file, EOF)比如输入 cat(不带参数), 会等待着从键盘输入内容hello输入 Ctrl-d 后会结束输入输入快捷键C-t 交换光标前面的两个字符(只在终端有效)C-w 一次删除一个单词C-u 一次删除一行（从光标删除到行首）C-k 从光标删除到行尾C-d 删除后一个字符C-h 删除前一个字符C-f forward 往前 就是右C-b backward 往后 就是左箭头C-p pres 往上 就是上箭头C-n next 往下 就是下箭头C-a 光标回到行首C-e 光标跳到行尾快捷键C-z 挂起到后台C-c 中断程序reboot重启shutdown关机可以用参数指定时间halt关机配置服务器免登陆设置ssh-key===生成 ssh-key===*** 注意, 不懂就在群里问Mac 用户直接打开终端输入命令Win 打开 cmder 程序, 在里面输入下面的命令1. 在本机生成 ssh key 公钥私钥注意 下面的 mykey 随便换一个你喜欢的名字, 这是一个标注, 方便你看的ssh-keygen -C &lt;mykey&gt;会提示你生成的文件的地址, 并且让你输入密码, 你不要输入密码, 直接回车这样你就得到了一对 ssh-key, 这是用于登录服务器用的默认你会得到两个文件id_rsa 是私钥 自己保存 不要给别人看id_rsa.pub 是公钥, 是要到处使用的这个是我们之前提到的非对称加密===重建服务器并且配置 ssh-key===去 vultr 的管理界面先删除(Destory)现有的服务器新建服务器的时候, 把刚才生成的 id_rsa.pub 文件(用 atom/webstorm 可以打开)里面的内容加入到 ssh-key 步骤中这样你就可以不用密码, 自动登录服务器了// 如果你不想重建服务器, 配置 ssh-key 的方法如下// 在服务器把本机生成的 public key 添加到 /root/.ssh/authorized_keys 文件中// 1 用 root 用户登录到服务器, 创建 .ssh 目录cd /rootmkdir .ssh// 2 编辑 authorized_keys 文件, 把刚才生成的 id_rsa.pub 文件里面的内容粘贴进去并保存退出// 注意, 这里可以粘贴多个 key, 一行一个nano .ssh/authorized_keys// 安装必备软件// 安装 oh-my-zsh 配置(方便你使用命令行的配置)wget https://github.com/robbyrussell/oh-my-zsh/raw/master/tools/install.sh -O - | sh// 安装防火墙 和 防火墙的基本套路配置// 防火墙的作用(redis安全漏洞)apt-get install ufwufw allow 22ufw allow 80ufw allow 443ufw allow 3000ufw allow 8090/8388(这个是留给飞机用的端口)ufw default deny incomingufw default allow outgoingufw status verboseufw enable部署项目软件安装====安装 git nginxapt-get install git nginxubuntu 的软件仓库中的 nodejs 更新很慢, 几乎可以认为不可用,所以我们从 nodeSource 仓库中安装新款 nodejs配置 nodeSource 仓库curl -sL https://deb.nodesource.com/setup_7.x | sudo -E bash -配置之后就可以安装最新的 nodejsapt-get install nodejs安装 yarnnpm install yarn -g(这个官网不推荐) curl -sS https://dl.yarnpkg.com/debian/pubkey.gpg | sudo apt-key add - echo &quot;deb https://dl.yarnpkg.com/debian/ stable main&quot; | sudo tee /etc/apt/sources.list.d/yarn.list sudo apt-get update &amp;&amp; sudo apt-get install yarn用 git pull 项目用 sourcetree安装依赖yarn install配置 nginxln -s /var/www/weibo/weibo.nginx /etc/nginx/sites-enabled/weibo` 这部分和部署无关列出 nginx/sites-enabled 下面的文件root@linlab:~# ls -l /etc/nginx/sites-enabled/第一个字母是 l, 这个表示 weibo 是一个软链接, 当访问 weibo 时,实际上访问的是 /var/www/weibo/weibo.nginx这样做的好处是我们只需要更新 weibo.nginx 就可以软链接类似 windows 下的快捷方式lrwxrwxrwx 1 root root 26 May 23 14:09 weibo -&gt; /var/www/weibo/weibo.nginx`移除默认的配置文件mv /etc/nginx/sites-enabled/default /tmp重启 nginxservice nginx restart运行程序yarn run start安装 pm2yarn global add pm2pm2 日志/root/.pm2/logs 文件夹会包含所有应用的日志实时日志命令pm2 logs我们已经有 node 的情况下, 为什么要用 nginx1. node 性能是不如 nginx 的, nginx 处理静态文件的性能非常高2. nginx 接收 80 端口的请求(来自用户的请求), 然后转发给各个 app.js(app.js实际上是应用服务器, 也就是我们常说的框架)3. nginx 是使用非常广泛的静态服务器, 安全性方面是非常好的 给静态资源增加一个路由，如果发现请求是静态资源， nginx直接处理, 不用让node来处理，可以这么理解吗 当然可以, 这个是完全正确的1. 高性能的静态服务器 nginx nginx nginx nginx nginx2. 高性能的网络(?)服务器 node gunicorn unicorn tomcat/jetty3. 一般性能的开发服务器 node app app app// ===// 服务器中文编码问题// ===//// 编辑下面的文件, 不要拼错nano /etc/environment// 加入下面的内容, 保存退出LC_CTYPE=&quot;en_US.UTF-8&quot;LC_ALL=&quot;en_US.UTF-8&quot;*/","categories":[],"tags":[{"name":"linux","slug":"linux","permalink":"https://vlwq.github.io/tags/linux/"}]},{"title":"数据结构与算法","slug":"2016/20161107","date":"2016-11-07T02:36:00.000Z","updated":"2017-07-05T11:09:58.050Z","comments":true,"path":"2016/11/07/2016/20161107/","link":"","permalink":"https://vlwq.github.io/2016/11/07/2016/20161107/","excerpt":"// 数据结构与算法分析 /*数据结构就是存储数据的方式算法分析是对一个算法的时间的大略估计算法是有特定的套路的 了解 5 种时间复杂度即可*/ // 时间、空间复杂度(空间复杂度一般不考虑)// 复杂度是对一个操作的大致估计// 复杂度从小到大依次如下","text":"// 数据结构与算法分析 /*数据结构就是存储数据的方式算法分析是对一个算法的时间的大略估计算法是有特定的套路的 了解 5 种时间复杂度即可*/ // 时间、空间复杂度(空间复杂度一般不考虑)// 复杂度是对一个操作的大致估计// 复杂度从小到大依次如下 /*五种常见时间复杂度复杂度用 大 O 记法 来描述(大 O 记法是描述算法复杂度的符号)O(1) 常数复杂度，最快速的算法。 求数组前 10000 个元素的和 字典和集合的存取都是 O(1) 数组的存取是 O(1)O(lgN) 对数复杂度 假设有一个有序数组，以二分法查找O(n) 线性复杂度 假设有一个数组，以遍历的方式在其中查找元素O(NlogN) 求两个数组交集，其中一个是有序数组 假设 A 数组的长度是 M, 无序 假设 B 数组的长度是 N, 有序 A 数组每一个元素都要在 B 数组中进行查找操作 每次查找如果使用二分法则复杂度是 lgN 加起来就是 M * lgN 所以时间复杂度是 NlogNO(N²) 平方复杂度 求两个无序数组的交集 假设 A 数组的长度是 M, 无序 假设 B 数组的长度是 N, 无序 A 数组每一个元素都要在 B 数组中进行查找操作 每次查找只能使用遍历操作, 所以每次查找都是 N 加起来就是 M * N 所以时间复杂度是 N²*/ /*数据结构=== 针对常用的操作，我们发明了一套常用的数据结构四大数据结构1，数组 连续的一块内存 读取元素时间是 O(1) 插入、删除是 O(n)2，链表 手拉手的盒子，一个盒子只能访问左右手的盒子 以下标方式读取元素的时间是 O(n) 插入、删除是 O(1) 栈和队列是链表的特定场景应用(当然, 不用链表也能实现栈和队列)3，字典(Hash Table 哈希表) 把字符串转为数字作为下标存储到数组中 字符串转化为数字的算法是 O(1) 所以字典的存取操作都是 O(1) 除非对数据有顺序要求，否则字典永远是最佳选择 字符串转化为数字的算法 1，确定数据规模，这样可以确定容器数组的大小 Size 2，把字符当作 N 进制数字得到结果 ‘gua’ 被视为 g * 1 + u * 10 + a * 100 得到结果 n n % Size 作为字符串在数组中的下标 通常 Size 会选一个 素数4，搜索树(平衡二叉搜索树)（我们只用，不写，甚至只是隐含在用，你并不知道你用的是树） AVL 树 红黑树 额外的，图是一种有时候有用但你一辈子都可能写不到的数据结构只了解，不用学习如何实现图的应用举例 地图导航 全国几个大城市之间的出行方案(有价格/时间/路途等权重)*/var log = console.log.bind(console) // 队列结构(先进先出)// 主要有 2 个操作// enqueue dequeue//var Queue = function() { // data 是存储元素的数组 this.data = []} // 入队Queue.prototype.enqueue = function (element) { this.data.push(element)} // 出队Queue.prototype.dequeue = function () { return this.data.splice(0, 1)} // 队列长度Queue.prototype.length = function () { return this.data.length} // 清空队列Queue.prototype.empty = function() { this.data = []} // var q = new Queue()// q.enqueue(1)// q.enqueue(2)// q.enqueue(3)// log(‘length’, q.length())// log(q.dequeue())// q.enqueue(4)// log(q.dequeue())// log(q.dequeue())// log(q.dequeue()) // Stack 栈(先进后出)// 常见的 3 个操作// push pop top//var Stack = function() { this.data = []} // push 添加一个元素Stack.prototype.push = function(e) { this.data.push(e)} // pop 删除并返回最新添加的元素Stack.prototype.pop = function() { var index = this.data.length - 1 return this.data.splice(index, 1)} // top 仅返回最新添加的元素Stack.prototype.top = function() { var index = this.data.length - 1 return this.data[index]} var s = new Stack()s.push(‘hello’)s.push(‘world’)log(s.pop())log(s.pop()) var str = ‘hello’for (var i = 0; i &lt; str.length; i++) { s.push(str[i])} var str1 = ‘’for (var i = 0; i &lt; str.length; i++) { str1 += s.pop(str[i])}log(str1) /*((1 + 2) * 3)作业 验证括号匹配*/ // 链表// LinkedList// [1, 2, 3, 4, 15, 16, 27]// [1, 2, 3, 0, 4, 5, 6, 7] // 链表实现//var Node = function(e) { this.element = e this.next = null} // var n1 = new Node(1)// var n2 = new Node(2)// var n3 = new Node(3)// n1.next = n2// n2.next = n3//// var n = n1// while(n != null) {// log(‘遍历链表’, n.element)// n = n.next// } var LinkedList = function() { this.head = new Node() this._length = 0} // 在链表末尾增加一个元素LinkedList.prototype.append = function(e) { var node = new Node(e) var n = this.head while(n.next != null) { n = n.next } n.next = node // this._length++} // 返回一个元素的 indexLinkedList.prototype.indexOf = function(e) { var index = -1 var n = this.head var i = 0 while(n.next != null) { if (e === n.element) { index = i break } n = n.next i++ } return index} // 返回链表的长度LinkedList.prototype.length = function() { return this._length} LinkedList.prototype.log = function() { var n = this.head.next log(‘遍历链表’) while(n != null) { log(‘ &gt; ‘, n.element) n = n.next }} var list = new LinkedList()list.append(‘hello’)list.append(‘gua’)list.append(‘你好’)list.log()log(list.length()) /*面向对象 多态 继承 大致讲一下 多态在某些语言里面 比如 java你函数定义的参数必须有类型 类型不匹配就是错误的var add = function(a, b) { return a + b} // 在其他语言里面可能是这样的 比如 java cvar add = function(int:a, int:b) { return a + b} add(1.1, 2.2)// 报错， 类型不匹配 var add = function(float:a, float:b) { return a + b} add(1.1, 1) var add = function(int:a, float:b) { return a + b} var add = function(float:a, int:b) { return a + b} // 现在就不会报错了。。。add(1.1, 1) // 在 js 中没这个问题// 我们称之为 duck type 继承继承是说 子类拥有父类的某些东西 定义一个类 人 再定义 男人 女人然后设置 男人 女人的 prototype = 人 */ /*其他数据结构 hash table 哈希表（散列表）tree 树set 集合graph 图 哈希表就是用 字符串 当下标，也就是 js 中的对象的实现方式也就是其他语言中的 字典 原理是用字符串 算出一个数字 然后用这个数字当下标存东西比如 gua 这个字符串 我们用每个字符乘以一个数字最后求余得到下标从字符串到数字的操作叫做 hash// hash(‘gua’) = 1// hash(‘hs’) = 3【坑1， 坑2， 坑3， 坑4， 坑5， 坑6】 gua hs wh xiao lj bl 树一般是用来实现二叉搜索树的，应用范围不多 6 / 4 8 \\ / 57 9 */","categories":[],"tags":[{"name":"js","slug":"js","permalink":"https://vlwq.github.io/tags/js/"}]},{"title":"css动画","slug":"2016/20161106","date":"2016-11-06T02:36:00.000Z","updated":"2017-07-05T11:09:58.204Z","comments":true,"path":"2016/11/06/2016/20161106/","link":"","permalink":"https://vlwq.github.io/2016/11/06/2016/20161106/","excerpt":"CSS动画","text":"CSS动画 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117&lt;!DOCTYPE html&gt;&lt;html&gt; &lt;head&gt; &lt;meta charset=&quot;utf-8&quot;&gt; &lt;title&gt;fe 21&lt;/title&gt; &lt;style&gt; .b + .b &#123; /*background: red;*/ border-top: 1px solid black; &#125; .c &#123; transform: translate(20px, 40px); &#125; wujcxy::after &#123; content: &#x27;★&#x27;; font-size: 32px; text-shadow: 1px 1px black; &#125; .orange &#123; color: # FF9800; &#125; .gray &#123; color: lightgray; &#125; &lt;/style&gt; &lt;style&gt; /* transition 动画 */ .gua-cube &#123; width: 100px; height: 200px; background: red; &#125; .gua-cube:hover &#123; width: 200px; height: 100px; background: blue; transform: scale(1.2, 2); &#125; .gua-cube &#123; transition: 1s; &#125; /* animation 动画 */ .gua-animation div &#123; height: 30px; background: lightblue; margin: 10px 10px; &#125; /* 定义一个动画 改变背景色 */ @keyframes changecolor &#123; 0% &#123; background: lightblue; /*height: 30px;*/ &#125; 100% &#123; background: black; height: 100px; &#125; &#125; @keyframes vr &#123; 0% &#123; transform: rotate(0deg); &#125; 50% &#123; transform: rotate(280deg); &#125; 100% &#123; transform: rotate(360deg); &#125; &#125; /* 播放动画 1s 完成， 动画名是 changecolor */ .gua1:hover &#123; animation: 1s changecolor; &#125; /* 利用 play-state 属性实现动画暂停 */ .gua2 &#123; animation: 1s vr infinite; animation-timing-function: linear; animation-play-state: paused; &#125; .gua2:hover &#123; animation-play-state: running; &#125; &lt;/style&gt; &lt;/head&gt; &lt;body&gt; &lt;div class=&quot;b&quot;&gt; a &lt;/div&gt; &lt;div class=&quot;c&quot;&gt; c &lt;/div&gt; &lt;div class=&quot;b&quot;&gt; &lt;wujcxy class=&quot;orange&quot;&gt;&lt;/wujcxy&gt; &lt;wujcxy class=&quot;orange&quot;&gt;&lt;/wujcxy&gt; &lt;wujcxy class=&quot;orange&quot;&gt;&lt;/wujcxy&gt; &lt;wujcxy class=&quot;gray&quot;&gt;&lt;/wujcxy&gt; &lt;wujcxy class=&quot;gray&quot;&gt;&lt;/wujcxy&gt; &lt;/div&gt; &lt;!-- transition 动画 --&gt; &lt;div class=&quot;gua-transition&quot;&gt; &lt;div class=&quot;gua-cube&quot;&gt; &lt;/div&gt; &lt;/div&gt; &lt;div class=&quot;gua-animation&quot;&gt; &lt;div class=&quot;gua1&quot;&gt;1&lt;/div&gt; &lt;div class=&quot;gua2&quot;&gt;2&lt;/div&gt; &lt;div class=&quot;gua3&quot;&gt;3&lt;/div&gt; &lt;/div&gt; &lt;/body&gt;&lt;/html&gt; js部分12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273747576777879// ============// fe21////// 本次内容如下// 1, css3 的新特性// 2, css3 动画和动态效果// ============//// CSS选择器介绍// 阮一峰 http://www.ruanyifeng.com/blog/2009/03/css_selectors.html// 1. 4种基本选择器CSS 2.1// 2. 4种多元素的 组合选择器div, p 同时匹配div h1 匹配后代div &gt; p 匹配子元素div + div 匹配同级的下一个元素(仅匹配一个)其中 div p 与 div &gt; p 的区别前者匹配全部的后代元素，而后者仅匹配向下一层（子元素）// 3. 4种属性选择器 根据某类的属性来查找选择器E[att]E[att=val]// 4. 伪类选择器 实际不存在的类E:first-childE:linkE:lang(c)// 5. 伪元素E::first-lineE::first-letterE::beforeCSS 3//CSS 3 中的新特性// 应该利用 CSS 3 generator生成CSS3代码(上课会讲)border-radius 边框圆角box text shadow 盒子阴影transform 2D 变形columns 属性 将文本分隔成多列transition 动画keyframes 动画和生成软件https://daneden.github.io/animate.css/http://cssanimate.com/其他 css3 生成软件http://css3generator.com/http://www.css3generator.in/http://css3.me/https://www.tutorialspoint.com/css/css3_boarder_image.htmCSS3 动画主要用到了 3 个属性transform 的全部函数https://developer.mozilla.org/en-US/docs/Web/CSS/transformtransition 可动画列表https://developer.mozilla.org/en-US/docs/Web/CSS/CSS_animated_propertiesanimation 动画123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121&lt;!DOCTYPE html&gt;&lt;html&gt; &lt;head&gt; &lt;meta charset=&quot;utf-8&quot;&gt; &lt;title&gt;fe 21 css3 animation&lt;/title&gt; &lt;style&gt; .gua-block &#123; background: lightblue; width: 100px; height: 100px; &#125; .gua-spin &#123; animation: spin linear 2s; animation-iteration-count: 1; &#125; @keyframes spin &#123; 0% &#123; transform: rotate(0deg); &#125; 100% &#123; transform: rotate(360deg); &#125; &#125; .shake &#123; animation: shake linear 0.6s; animation-iteration-count: 1; &#125; @keyframes shake &#123; 0% &#123; transform: translateX(0px); &#125; 10% &#123; transform: translateX(-10px); &#125; 30% &#123; transform: translateX(10px); &#125; 50% &#123; transform: translateX(-10px); &#125; 70% &#123; transform: translateX(10px); &#125; 90% &#123; transform: translateX(-10px); &#125; 100% &#123; transform: translateX(0px); &#125; &#125; .gua-shake &#123; transform: translateX(100px); &#125; &lt;/style&gt; &lt;/head&gt; &lt;body&gt; &lt;div class=&quot;gua-block&quot;&gt; 方块 &lt;/div&gt; &lt;button class=&quot;play&quot;&gt;播放动画&lt;/button&gt; &lt;div class=&quot;gua-shake&quot;&gt; &lt;input class=&#x27;input&#x27; value=&quot;&quot;&gt; &lt;br&gt; &lt;button class=&quot;login&quot;&gt;登录&lt;/button&gt; &lt;/div&gt; &lt;script&gt; var e = function(sel) &#123; return document.querySelector(sel) &#125; var playAnimation = function() &#123; var block = e(&#x27;.gua-block&#x27;) // 让它开始播放动画 block.classList.add(&#x27;gua-spin&#x27;) &#125; var shake = function(element) &#123; element.classList.add(&#x27;shake&#x27;) &#125; var __main = function() &#123; e(&#x27;.login&#x27;).addEventListener(&#x27;click&#x27;, function(event) &#123; // if 登录不成功 var input = e(&#x27;.input&#x27;) shake(input) &#125;) // 绑定一个 animationend 事件, 在动画结束后删除动画 class e(&#x27;.input&#x27;).addEventListener(&#x27;animationend&#x27;, function()&#123; e(&#x27;.input&#x27;).classList.remove(&#x27;shake&#x27;) &#125;) e(&#x27;.play&#x27;).addEventListener(&#x27;click&#x27;, function(e) &#123; playAnimation() &#125;) // 绑定一个 animationend 事件, 在动画结束后删除动画 class var block = e(&#x27;.gua-block&#x27;) block.addEventListener(&#x27;animationend&#x27;, function()&#123; block.classList.remove(&#x27;gua-spin&#x27;) &#125;) &#125; __main() /* animationend 事件 在动画播完后触发 动画播放被暂停不会触发 animationiteration 事件 在动画播放一轮后触发 如果动画只播放一轮, 那么不会触发此事件 利用事件测试动画 */ &lt;/script&gt; &lt;/body&gt;&lt;/html&gt;","categories":[],"tags":[{"name":"html5","slug":"html5","permalink":"https://vlwq.github.io/tags/html5/"}]},{"title":"ES6中的promise对象","slug":"2016/20161105","date":"2016-11-05T02:36:00.000Z","updated":"2017-07-05T11:09:58.019Z","comments":true,"path":"2016/11/05/2016/20161105/","link":"","permalink":"https://vlwq.github.io/2016/11/05/2016/20161105/","excerpt":"ES6中的promise对象","text":"ES6中的promise对象 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778/*Promise 是抽象异步处理对象以及对其进行各种操作的组件简而言之, 就是让异步操作变得好看一些Promise 的用法如下*/// 将 fs.readFile 的操作封装成 promise// 这样就可以使用 promise 的 api 了const readFile = function(filename) &#123; // 一般前端的写法 // return new Promise(function(resolve, reject) &#123;&#125;) const p = new Promise(function(resolve, reject) &#123; const fs = require(&#x27;fs&#x27;) const options = &#123; encoding: &#x27;utf8&#x27; &#125; fs.readFile(filename, options, function(error, content) &#123; if (error !== null) &#123; reject(error) &#125; else &#123; resolve(content) &#125; &#125;) &#125;) return p&#125;// 使用 promise 读取文件就不用写成回调的形式了// 直接按照同步的写法就好了// 可以无限 then, 只要你保证上一个 then 返回了东西即可let promise = readFile(&#x27;foo.txt&#x27;)promise.then(function(content) &#123; console.log(&#x27;debug file content&#x27;, content) const c = content + &#x27; suffix1&#x27; return c&#125;, function(error) &#123; console.log(&#x27;debug error message&#x27;, error)&#125;).then(function(c1) &#123; console.log(&#x27;second then&#x27;, c1) const c = c1 + &#x27; suffix2&#x27; return c&#125;).then(function(c) &#123; console.log(&#x27;third then&#x27;, c)&#125;)// 上面的写法也可以写成下面这样// 把 reject 的操作放在 catch 里面promise.then(function(content) &#123; console.log(&#x27;debug file content&#x27;, content)&#125;).catch(function(error) &#123; console.log(&#x27;debug error message&#x27;, error)&#125;)// 有时候会碰到批量执行异步操作，如果直接用循环 + 调用函数的形式会比较麻烦// 使用 Promise.all 就很方便了// all 方法是直接挂在 Promise 类上的// 而 then catch 这些方法是挂在原型上const fileList = [ &#x27;t1.txt&#x27;, &#x27;t2.txt&#x27;, &#x27;t3.txt&#x27;,]const list = fileList.map(function(item) &#123; const r = readFile(item) return r&#125;)Promise.all(list).then(function(content) &#123; console.log(&#x27;content&#x27;, content)&#125;)/*这是一个完整的参考, 如果有兴趣以后可以翻翻看, 但是现在没必要看了http://liubin.org/promises-book/*/","categories":[],"tags":[{"name":"js","slug":"js","permalink":"https://vlwq.github.io/tags/js/"}]},{"title":"lodash","slug":"2016/20161104","date":"2016-11-04T02:36:00.000Z","updated":"2017-07-05T11:09:13.530Z","comments":true,"path":"2016/11/04/2016/20161104/","link":"","permalink":"https://vlwq.github.io/2016/11/04/2016/20161104/","excerpt":"lodash的demo","text":"lodash的demo 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172173174175176177178179180181182183184185186187188189190191192193194195196197198199200201202203204205206207208209210211212213214215216217218&lt;!DOCTYPE html&gt;&lt;html&gt;&lt;head&gt; &lt;title&gt;lodash demo&lt;/title&gt; &lt;script src=&quot;https://cdn.jsdelivr.net/lodash/4.17.4/lodash.js&quot;&gt;&lt;/script&gt;&lt;/head&gt;&lt;body&gt;&lt;/body&gt;&lt;script&gt; /* lodash 是一个非常实用的 js 工具库 在 node 中可以安装 也可以自己下载来导入 在 浏览器 中, 可以通过 CDN 的方式使用 */ // _ 是 lodash 的套路用法 // const _ = require(&#x27;./lodash.js&#x27;) // each 用法 const list = [ &#x27;a&#x27;, &#x27;b&#x27;, &#x27;c&#x27;, ] const dict = &#123; k1: &#x27;a&#x27;, k2: &#x27;b&#x27;, k3: &#x27;c&#x27;, &#125; _.each(list, (v, k) =&gt; &#123; // each 方法的两个参数 // 如果 list 是 列表，那么 v 和 k 分别是指 list 的 element/index // 如果 list 是 对象（字典），那么 v 和 k 分别是指 object 的 value/key console.log(&#x27;element and index&#x27;, v, k) &#125;) _.each(dict, (v, k) =&gt; &#123; console.log(&#x27;value and key&#x27;, v, k) &#125;) // map 用法 // 用 map 可以用一个旧数组生成一个新数组 // 比如旧数组为 const list1 = [ 10, 20, 30, ] const list2 = _.map(list1, (v, k) =&gt; &#123; const r = v * v return r &#125;) console.log(&#x27;list2&#x27;, list2) // filter // 遍历数组/对象，返回符合判断函数中的元素 var us = [ &#123; &#x27;name&#x27;: &#x27;a&#x27;, &#x27;score&#x27;: 70, &#125;, &#123; &#x27;name&#x27;: &#x27;b&#x27;, &#x27;score&#x27;: 90, &#125;, &#123; &#x27;name&#x27;: &#x27;c&#x27;, &#x27;score&#x27;: 80, &#125;, &#123; &#x27;name&#x27;: &#x27;d&#x27;, &#x27;score&#x27;: 70, &#125;, ] var u = _.filter(us, (e) =&gt; &#123; var b = e.score &gt; 70 return b &#125;) console.log(&#x27;filter u&#x27;, u) // orderBy // 根据条件排序 // 先按照 score 升序，如果有 score 一样的 // 再按照 name 降序 var users = _.orderBy(us, [&#x27;score&#x27;, &#x27;name&#x27;], [&#x27;asc&#x27;, &#x27;desc&#x27;]) console.log(&#x27;order by users&#x27;, users) // flatten // 减少一层嵌套数组 // 也就是可以直接将二维数组拍成一维数组 var l = [ 1, [2], [3, [4]], [5, [6], [7]], ] var f = _.flatten(l) console.log(&#x27;flatten result&#x27;, f) // compact // 剔除数组中的假值元素 // js 中假值元素分别为 // false null 0 NaN &#x27;&#x27; undefined // 这个方法可以和 map 配合使用 // 剔除返回数组的数组中的假值元素 var l = [ 0, 1, NaN, &#x27;&#x27;, &#x27;hello&#x27;, false, undefined, null, &#123;&#125;, ] var result = _.compact(l) console.log(&#x27;compact result&#x27;, result) // isEqual // 比较两个对象是否相等 // 数组也可以用这个方法比较 var o1 = &#123; &#x27;key&#x27;: 1, &#125; var o2 = &#123; &#x27;key&#x27;: 1, &#125; var result = _.isEqual(o1, o2) console.log(&#x27;isEqual result&#x27;, result) // 获取嵌套对象的值 var o = &#123; &#x27;k1&#x27;: &#123; &#x27;k2&#x27;: &#123; &#x27;k3&#x27;: &#123; &#x27;k4&#x27;: &#x27;value in nested dict&#x27; &#125; &#125; &#125; &#125; var path = &#x27;k1.k2.k3.k4&#x27; var result = _.result(o, path) console.log(&#x27;result nested result&#x27;, result) // 生成数组 // 使用 range 生成数组后，就可以使用 // each map filter 这些方法操作数组了 var l = _.range(10) console.log(&#x27;range l&#x27;, l) // cloneDeep // 深拷贝 var o = &#123; &#x27;a&#x27;: [1], &#x27;b&#x27;: [2], &#125; var deep = _.cloneDeep(o) console.log(&#x27;deep&#x27;, deep) // random // 返回给定范围的随机值 var a = 10 var b = 20 // 返回 a 和 b 之间的一个整数 var r1 = _.random(a, b) console.log(&#x27;random r1&#x27;, r1) // 如果指定第三个参数为 true，这个参数的意思是指 floating // 那么返回的就是一个浮点数 var r2 = _.random(a, b, true) console.log(&#x27;random r2&#x27;, r2) // shuffle // 返回打乱顺序后的数组 var l = [1, 2, 3, 4,] const s = _.shuffle(l) console.log(&#x27;shuffle l&#x27;, s)&lt;/script&gt;&lt;/html&gt;","categories":[],"tags":[{"name":"js","slug":"js","permalink":"https://vlwq.github.io/tags/js/"}]},{"title":"ajax,Bom","slug":"2016/20161103","date":"2016-11-03T02:36:00.000Z","updated":"2017-07-05T11:09:13.614Z","comments":true,"path":"2016/11/03/2016/20161103/","link":"","permalink":"https://vlwq.github.io/2016/11/03/2016/20161103/","excerpt":"// 1, HTTP 协议(Hyper-Text Transportation Protocol)// 2, AJAX// 3, BOM (Browser Object Model 浏览器对象模型)//","text":"// 1, HTTP 协议(Hyper-Text Transportation Protocol)// 2, AJAX// 3, BOM (Browser Object Model 浏览器对象模型)// 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172173174175176177178179180181182183184185186187188189190191192193194195196197198199200201202203204205206207208209210211212213网址组成（四部分） 协议 http, https（https 是加密的 http） 主机 g.cn zhihu.com之类的网址 端口 HTTP 协议默认是 80，因此一般不用填写 路径 下面的「/」和「/question/31838184」都是路径http://www.zhihu.com:80/http://www.zhihu.com/question/3183818410101000168ASCIIa 97 01100001A 65 01000001电脑通信靠IP地址，IP地址记不住就发明了域名（domain name），然后电脑自动向DNS服务器（domain name server）查询域名对应的IP地址比如g.cn这样的网址，可以通过电脑的ping程序查出对应 IP 地址➜ ping g.cnPING g.cn (74.125.69.160): 56 data bytes端口是什么？一个比喻：用邮局互相写信的时候，ip相当于地址（也可以看做邮编，地址是域名）端口是收信人姓名（因为一个地址比如公司、家只有一个地址，但是却可能有很多收信人）端口就是一个标记收信人的数字。端口是一个 16 位(二进制的 位)的数字，所以范围是 0-65535（2**16）——HTTP协议——一个传输协议，协议就是双方都遵守的规范。为什么叫超文本传输协议呢，因为收发的是文本信息。1，浏览器（客户端）按照规定的格式发送文本数据（请求）到服务器2，服务器解析请求，按照规定的格式返回文本数据到浏览器3，浏览器解析得到的数据，并做相应处理请求和返回是一样的数据格式，分为4部分：1，请求行或者响应行2，Header（请求的 Header 中 Host 字段是必须的，其他都是可选）3，\\r\\n\\r\\n（连续两个换行回车符，用来分隔Header和Body）4，Body（可选）请求的格式，注意大小写（这是一个不包含Body的请求）：原始数据如下&#x27;GET / HTTP/1.1\\r\\nhost:g.cn\\r\\n\\r\\n&#x27;打印出来如下GET / HTTP/1.1Host: g.cn&#x27;GET / HTTP/1.1\\r\\nhost:www.qq.com\\r\\n\\r\\n&#x27;其中1， GET 是请求方法（还有POST等，这就是个标志字符串而已）2，/ 是请求的路径（这代表根路径）3，HTTP/1.1 中，1.1是版本号，通用了20年具体字符串是 &#x27;GET / HTTP/1.1\\r\\nhost:g.cn\\r\\n\\r\\n&#x27;返回的数据如下HTTP/1.1 301 Moved PermanentlyAlternate-Protocol: 80:quic,p=0,80:quic,p=0Cache-Control: private, max-age=2592000Content-Length: 218Content-Type: text/html; charset=UTF-8Date: Tue, 07 Jul 2015 02:57:59 GMTExpires: Tue, 07 Jul 2015 02:57:59 GMTLocation: http://www.google.cn/Server: gwsX-Frame-Options: SAMEORIGINX-XSS-Protection: 1; mode=blockBody部分太长，先不贴了其中响应行（第一行）：1，HTTP/1.1 是版本2，301 是「状态码」，参见文末链接3，Moved Permanently 是状态码的描述浏览器会自己解析Header部分，然后将Body显示成网页2xx 表示成功3xx 表示移动走了或者别的什么情况4xx 表示你发错了请求(比如你发的路径根本不存在 或者你发的请求是错的)5xx 表示服务器挂了, 各种原因挂了——前端掌握 HTTP 协议有什么用——可以用 JS 动态抓取内容构建页面比如动态评论、加载数据比如天气预报程序比如壁纸图片库浏览器提供了使用 HTTP 协议收发数据的接口，名为 AJAX这是一个重要的技术——浏览器安全问题——跨域请求问题和解决方案 1, 服务器设置 HTTP 协议头*/// ——AJAX 和使用方法——// ajax 就是浏览器提给的用 js 获取链接内容的 API// 你可以理解为发送网络请求的标准库//// 获取登录页面// 创建 AJAX 对象var r = new XMLHttpRequest()// 设置请求方法和请求地址, 第三个别管, 就写 truer.open(&#x27;GET&#x27;, &#x27;/login&#x27;, true)// 注册响应函数r.onreadystatechange = function() &#123; console.log(&#x27;onreadystatechange&#x27;, r.readyState, r.readyState == 4) if(r.readyState == 4) &#123; console.log(&#x27;state change&#x27;, r) &#125;&#125;// 发送请求r.send()// 发送登录数据// 创建 AJAX 对象var r = new XMLHttpRequest()// 设置请求方法和请求地址r.open(&#x27;POST&#x27;, &#x27;/login&#x27;, true)// 设置发送的数据的格式r.setRequestHeader(&#x27;Content-Type&#x27;, &#x27;application/json&#x27;)// 注册响应函数r.onreadystatechange = function() &#123; if (r.readyState == 4) &#123; console.log(&#x27;state change&#x27;, r, r.status, r.response) var response = JSON.parse(r.response) console.log(&#x27;response&#x27;, response) &#125; else &#123; console.log(&#x27;change&#x27;) &#125;&#125;// 发送请求var account = &#123; username: &#x27;gua&#x27;, password: &#x27;123&#x27;,&#125;var data = JSON.stringify(account)r.send(data)# 可以封装成这样的一个函数, 避免总监吃瘪var ajax = function(method, path, data, reseponseCallback) &#123; var r = new XMLHttpRequest() // 设置请求方法和请求地址 r.open(method, path, true) // 设置发送的数据的格式 r.setRequestHeader(&#x27;Content-Type&#x27;, &#x27;application/json&#x27;) // 注册响应函数 r.onreadystatechange = function() &#123; if (r.readyState == 4) &#123; // console.log(&#x27;state change&#x27;, r, r.status, r.response) reseponseCallback(r.response) // var response = JSON.parse(r.response) // console.log(&#x27;response&#x27;, response) &#125; else &#123; // console.log(&#x27;change&#x27;) &#125; &#125; // 发送请求 r.send(data)&#125;/*// BOMBOM(browser object model) 包含5个东西&gt;location 管理 URL&gt;navigator 管理浏览器&gt;history 管理历史记录&gt;screen 管理屏幕&gt;window 管理浏览器所有的东西location 对象是用来管理 URL 的, 下面是例子改变 href 属性就可以跳转页面hash: &quot;&quot;host: &quot;s.taobao.com&quot;hostname: &quot;s.taobao.com&quot;href: &quot;https://s.taobao.com/search?q=3ds&amp;imgfile=&amp;js=1&amp;stats_click=search_radio_all&amp;ie=utf8&quot;search: &quot;?q=3ds&amp;imgfile=&amp;js=1&amp;stats_click=search_radio_all&amp;ie=utf8&quot;origin: &quot;https://s.taobao.com&quot;pathname: &quot;/search&quot;port: &quot;&quot;protocol: &quot;https:&quot;reload: 函数, 刷新当前页面replace: 函数, 替换当前页面, 有参数navigator 对象是用来查询浏览器的信息的比如当前的操作系统平台, 浏览器型号厂商等等例如navigator.userAgent&quot;Mozilla/5.0 (Macintosh; Intel Mac OS X 10_11_6) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/54.0.2840.71 Safari/537.36&quot;navigator.platform&quot;MacIntel&quot;history 对象是用来处理历史纪录的在 HTML5 它增加了一些 API 使得它也可以做单页应用(SPA, single page app)history.length // 历史列表中的 url 数量history.back() // 相当于点击后退按钮history.forward() // 相当于点前进history.go(-2) // 相当于点击两次后退按钮// 下面是 HTML5 新函数history.pushState(null, &#x27;title&#x27;, &quot;/profile&quot;)三个参数分别是 自定义对象 新页面的标题, 但是现在还没有浏览器实现这个功能 新页面的地址var state = &#123; page: &quot;settings&quot;&#125;history.pushState(state, &quot;settings&quot;, &quot;/settings&quot;)用户点击 前进 后退 按钮的时候, 会触发 window 的 popstate 事件于是可以在这里操作window.addEventListener(&quot;popstate&quot;, function(e) &#123; var state = e.state; // state 就是 pushState 的第一个参数 console.log(&#x27;pop state&#x27;, state)&#125;)还有一个 replaceState 函数, 它的作用和 pushState 一样, 只是不生成一条历史纪录其他只能在相同域名下可以使用 queryString主要作用是来做 SPA(single page application 单页应用)*/+","categories":[],"tags":[{"name":"js","slug":"js","permalink":"https://vlwq.github.io/tags/js/"}]},{"title":"console的apply,call,bind","slug":"2016/20161102","date":"2016-11-02T02:36:00.000Z","updated":"2017-07-05T11:06:42.965Z","comments":true,"path":"2016/11/02/2016/20161102/","link":"","permalink":"https://vlwq.github.io/2016/11/02/2016/20161102/","excerpt":"console的apply,call,bind","text":"console的apply,call,bind 12345678910111213141516171819202122232425262728293031323334353637383940414243444546// apply call bind 是用来给函数指定 this 用的// 但是用法稍有区别, 以我们长久以来使用的 log 为例var log = function() &#123; // log 是一个函数 // js 中的函数是一个对象 // 所以函数可以有方法 // apply, call, bind 都是函数的方法, 用来指定 this // // apply 接受两个参数 // 第一个参数是函数里面的 this, 这里指定了是 console, 这样就相当于 console.log // 第二个参数是要传给函数的参数列表, 类型是 数组 // apply 会把数组拆成一个个的参数传给函数 // 假设你调用 log(1, 2, 3, 4) // 那么 arguments 是 [1, 2, 3, 4] 这样的一个数组 // (实际上 arguments 不是数组, 但是表现和数组一模一样, 你就暂时当它是一个数组) // 下面这句就相当于调用 console.log(1, 2, 3, 4) // console.log.apply(console, [1, 2, 3, 4]) console.log.apply(console, arguments) // call 和 apply 类似, 但是小有区别, 如下 // 第一个参数和 apply 一样 // 第 2, 3, 4, 5, ... 个参数会依次作为参数传给函数 console.log.call(console, 1, 2, 3, 4) // 相当于调用下面的函数, 区别在于参数的类型 // console.log.apply(console, [1, 2, 3, 4]) // 相当于调用 console.log(1, 2, 3, 4) // var print = console.log // print.call(console, 1, 2, 3)&#125;// bind 函数不直接调用, 而是返回一个函数让你来调用// 第一个参数是用来指定函数里面的 this, 和 apply call 一样// 用法就是这样, 返回一个指定了 this 的函数// 下面的例子中, bind 函数把 console 参数指定为 log 函数的 thisvar log = console.log.bind(console)log(&#x27;hello&#x27;, 1, 2, 3)// hello 1 2 3// bind 还可以有额外的参数, 效果如下// 给返回的函数加上部分参数var error = console.log.bind(console, &#x27;*** ERROR&#x27;)// 下面的调用相当于 console.log(&#x27;*** ERROR&#x27;, &#x27;错误&#x27;)error(&#x27;错误&#x27;)// *** ERROR 错误","categories":[],"tags":[{"name":"js","slug":"js","permalink":"https://vlwq.github.io/tags/js/"}]},{"title":"gua.js","slug":"2016/20161101","date":"2016-11-01T02:36:00.000Z","updated":"2017-07-05T11:06:06.753Z","comments":true,"path":"2016/11/01/2016/20161101/","link":"","permalink":"https://vlwq.github.io/2016/11/01/2016/20161101/","excerpt":"123456789101112var log = function() &#123; console.log.apply(console, arguments)&#125;var e = function(selector) &#123; return document.querySelector(selector)&#125;var es = function (selector) &#123; return document.querySelectorAll(selector)&#125;","text":"123456789101112var log = function() &#123; console.log.apply(console, arguments)&#125;var e = function(selector) &#123; return document.querySelector(selector)&#125;var es = function (selector) &#123; return document.querySelectorAll(selector)&#125; 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119var appendHtml = function(element, html) &#123; element.insertAdjacentHTML(&#x27;beforeend&#x27;, html)&#125;var bindEvent = function(element, eventName, callback) &#123; element.addEventListener(eventName, callback)&#125;var toggleClass = function(element, className) &#123; if (element.classList.contains(className)) &#123; element.classList.remove(className) &#125; else &#123; element.classList.add(className) &#125;&#125;var removeClassAll = function(className) &#123; var selector = &#x27;.&#x27; + className var elements = document.querySelectorAll(selector) for (var i = 0; i &lt; elements.length; i++) &#123; var e = elements[i] e.classList.remove(className) &#125;&#125;var bindAll = function(selector, eventName, callback) &#123; var elements = document.querySelectorAll(selector) for(var i = 0; i &lt; elements.length; i++) &#123; var e = elements[i] bindEvent(e, eventName, callback) &#125;&#125;// find 函数可以查找 element 的所有子元素var find = function(element, selector) &#123; return element.querySelector(selector)&#125;var closestClass = function(element, className) &#123; var e = element while (e != null) &#123; if (e.classList.contains(className)) &#123; return e &#125; else &#123; e = e.parentElement &#125; &#125;&#125;var closestId = function(element, idName)&#123; /* element 是一个 DOM 元素 idName 是一个 string 循环查找 element 的直系父元素 如果父元素拥有 idName 这个 id, 则返回这个父元素 如果找到 document 都还没有, 则返回 null */ var e = element while (e != null) &#123; // 判断 e 是否包含 idName 这个 id if (e.id == idName) &#123; return e &#125; else &#123; e = e.parentElement &#125; &#125;&#125;var closestTag = function(element, tagName)&#123; /* element 是一个 DOM 元素 tagName 是一个 string 循环查找 element 的直系父元素 如果父元素是一个 tagName 标签, 则返回这个父元素 如果找到 document 都还没有, 则返回 null tagName 是 &#x27;div&#x27; &#x27;p&#x27; &#x27;h1&#x27; 这样的标签名 获取一个 DOM 元素的标签名的方法如下 element.tagName 需要注意的是, tagName 属性返回的标签名是大写的 例如 &#x27;DIV&#x27; &#x27;H1&#x27; 所以你在比较的时候需要把 tagName 转换为大写字母 使用如下 js 标准库函数转换 tagName.toUpperCase() */ var e = element while (e != null) &#123; // 判断 e 是否和 tagName 相等 if (e.tagName.toUpperCase() == idName.toUpperCase()) &#123; return e &#125; else &#123; e = e.parentElement &#125; &#125;&#125;var closest = function(element, selector)&#123; /* element 是一个 DOM 元素 selector 是一个 string, 表示一个选择器 可能的值是 &#x27;div&#x27; &#x27;#id-div-gua&#x27; &#x27;.red&#x27; 这三种 循环查找 element 的直系父元素 如果父元素符合选择器, 则返回这个父元素 如果找到 document 都还没有, 则返回 null */ var flag = selector[0] if (flag == &#x27;.&#x27;) &#123; var className = selector.slice(1) return closestClass(element, className) &#125; else if (flag == &#x27;#&#x27;) &#123; var idName = selector.slice(1) return closestId(element, idName) &#125; else &#123; var tag = selector return closestId(element, tag) &#125;&#125;","categories":[],"tags":[{"name":"guagua","slug":"guagua","permalink":"https://vlwq.github.io/tags/guagua/"}]},{"title":"2017年房价?","slug":"2016/20161006","date":"2016-10-06T02:36:00.000Z","updated":"2017-08-27T05:55:17.234Z","comments":true,"path":"2016/10/06/2016/20161006/","link":"","permalink":"https://vlwq.github.io/2016/10/06/2016/20161006/","excerpt":"一苒说：2017年，房价的拐点是不是到了？ 首先声明，本文只是一个房地产业外人士的个人观点，很可能不够正确和严谨。其次声明，绝非房地产楼盘或者中介广告——没有广告文章里，是唱衰房价的。我也不会从Wind平台上拉一堆数据，或者引用一堆券商的PPT。整的看起来像那么回事，跟所有招摇撞骗的分析报告一样：形式严重大于内容，只有分析没有观点，只有人云亦云，没有对事物本质的思考。","text":"一苒说：2017年，房价的拐点是不是到了？ 首先声明，本文只是一个房地产业外人士的个人观点，很可能不够正确和严谨。其次声明，绝非房地产楼盘或者中介广告——没有广告文章里，是唱衰房价的。我也不会从Wind平台上拉一堆数据，或者引用一堆券商的PPT。整的看起来像那么回事，跟所有招摇撞骗的分析报告一样：形式严重大于内容，只有分析没有观点，只有人云亦云，没有对事物本质的思考。 写这篇文章的起因是上周末去看了一个楼盘：上海市普陀区内环边的XXXX三期。 按道理我不该去看这个楼盘。因为这种高端楼盘和我的气质虽然相配，但和钱包完全不配。 但是在路边“温柔热情”与我攀谈的中原地产的中介朋友，脸不红心不跳的用一个大幅低于真实价格的说辞，把我忽悠到了现场。他们后来口口声声跟我说：“如果不是我告诉你一个低价，你会来现场吗？如果你不来现场，你就错过了买入这样一个优质房产的机会！” 根据李嘉诚的地段论：紧贴内环，靠近地铁三四号线镇坪路站，还有7号线地铁。 根据产品的血统出身论：口碑开发商绿城打造，大资本家融创操盘 根据资源稀缺的程度论：内环边的新盘屈指可数，配套新建的上海理工实验小学 根据毛主席说的“实践才是硬道理”：我去看过盘了，觉得确实挺好的 听说脱离定价谈产品是耍流氓：价格真的不是很贵，销售吹风的价格是：150平米左右的三房，起步价在1350万，全屋精装修，拎包入住。折算下来，9万一平米起步，均价10万左右。 在“精装修”被彻底滥用的今天，很多号称精装修的房子装的都像狗屎一样。但这个楼盘的定位还是挺高级的，我这种没见过世面的人，首先硬装的质感都不错，虽然风格略显浮夸，不是我喜欢的极致简约美。看到一堆标配进口品牌家电，深感自己认识的商品Logo还是太不齐全。内嵌式的四开门大冰箱，最初被我误以为是衣柜——怎么可能有衣柜放在厨房里呢？我一度Show出自己的智商优越感，质疑开发商的专业性。 一定有人笑我装逼，9万一平米起步，还不算贵？房价就像篮球运动员的身高，说起来都是高个子，可是球迷就是会嫌广东宏远的布泽尔2米03的身高太矮——没办法，对面站着2米10的布拉切。 这个盘，作为知名开发商的高端全新住宅，真的不贵，附近的次新二手房。很多都在9万左右的单价了。 在价格接近的情况下，一手新房比二手房更值得购入 二手房需要承担的税和中介费，通常增加5%以上。 并且，因为建筑质量和水平在不断提升，新房拥有更好的设计和品质。 此外，购买新房是很多有车一族难得的拥有产权车位的机会。在上海太多太多住宅小区，有钱也无法买到车位。 有人觉得新房比二手房拥有更长的土地产权年限。但这个优势，我倒认为可以忽略不计。下面会具体说到。 新房和二手房比，真正的局限在于：新房是离散的点状分布，只有合适的时机（它开盘的时候，你恰好打算买），合适的地点（它开盘的位置，你恰好能接受），合适的户型、面积和配套资源（它的产品，正好适合你的需求），才会促成你的购买。 而二手房，是面状分布，海量供应。理论上，只要你有钱，你可以在任何时间、购买任何地段、任何类型的产品——前提是，你要符合政府的限购政策。 开发商为何不定价高一点？为何一手房比二手房的价差这么小？在正常的市场，新房和二手房本来不应该价差这么小。 如果房地产可以用《三体》中的乱纪元来形容，现在一定处于一个寒冷的时代。北上广深等大城市，由于严格的限购政策，需求端的潜力已经被封杀大半。 一手新房的背后站着开发商，他是用流动资金和融资来做的楼盘，既然造好了，到了时间就要卖的。恰好碰上限购，就算你倒霉。总不能捂盘到限购过去——巨大资金成本不允许。因此，只有随行就市，定一个理性的价格，尽快卖掉。 我看房的这个楼盘，由于地段好，单套房价的购买价格门槛很高，所以在限购的情况下，要快速捕获足够的客源是很难的。当然定价要老实一点。 同样是新房，目前上海郊区的新房，却很抢手，定价坚挺，销售顾问各个都非常牛逼，要求你爱看不看，尽快决定！如果要订，开盘后7天内付清首付，否则，哼哼，订金不退。 为什么限购限不住郊区呢？因为限购政策是差异化的，郊区的楼价和面积都相对低一些，总价较低，很多潜在的购买者，是没有名下房产和贷款记录的年轻人，他们基本不受限购政策的影响，依然可以用35%的较低首付和相对优惠的贷款利率，购买房产。 二手房的背后则是一位位普通的上海市民。老百姓的二手房子价格，是对标一手新房的。随着过去2年的高歌猛进，很多二手房的挂牌行情价都很高。 现在虽然市场转冷，但是二手房的反应并不会像新房那么灵敏——新房需要去库存，否则闲置的每一天都是利息。二手房不用。二手房的房东是稳坐钓鱼岛，只要不急着用钱，他永远可以等待一个更好的价格。 正因为以上的分析，在限购政策来临到时候，一手新房更容易定价理性，二手房在初期价格会偏高。需要限购政策持续相当长的时间，二手房的价格才会真正松动。 所以，如果你近期一定要在上海买房，我建议你多看看新房。实在不合适，再去看二手房。 这次限购政策会持续多久？为什么要限购？首先，根据惯例，一波限购往往在2-3年左右。时间不会太短。按照这个经验，2019年才是政策解冻、恢复正常时间秩序的时间窗口。 限购不是一个正常的市场秩序，政府是很明白的。但是在没有把机制理顺之前，在问题严重的时候，粗暴的行政干预，是一个相对有效的快速手段，即使有后遗症。任志强就说过：每次限购，都是名义上打压房价，实际上埋下了下一轮暴涨的祸根。 道理很简单：你打压需求端，短期内，交易量大幅下滑——&gt;价格不涨或者下跌一点点——&gt;但是开发商在限购期间，会选择现金流为王，尽量卖房，不再买地，不再开发新楼盘——&gt;2-3年后，能上市的楼盘会更少——&gt;这个时候政府宣布限购很成功，房价被控制住了，于是限购取消——&gt;因供应不足，限购期内压抑的部分需求需要释放，供需关系进一步恶化，房价新一楼的飞涨开始。看懂上面这段话，你就懂了任志强为什么经常是对的。 因为政府在说的东西，和在做的东西，很多时候是两回事。 不在“供给端”做文章的房价调控，对于供应紧缺的大都市，根本就是伪命题。 第二，为什么要限购？ 从政府的角度来分析，他们不希望一个市场过于火热，失去秩序，同时民愤漫天。 大中城市的房价在15-16年，再度暴涨，很多都翻倍了。 从这个角度来看，政府要限购，要降温。 这个逻辑，简单一看，似乎和以往的任何一次限购，差不多。 但我觉得实际上，从16年年中开始的新一轮限购，和以往有本质的不同： 1 以前每次限购之前，也经常是货币宽松，房价暴涨，但一直处于“人民币升值”的通道里。这次不是。这次我们大印钞票的同时，人民币兑美元出现了明显的贬值了。 这就意味着“如果我们继续大印钞票”，可能要面对人民币进一步贬值——这可能是国际贸易的对手们，无法接受的。 2 美国要退出QE，要加息，在17年，这是定局。这会影响我们的货币政策。如果我们不加息，那么资本相对来说，更可能回流美国。如果我们跟随加息，收紧货币，那么对于“前两年习惯了海量货币”的房地产，当然会有冲击。 3 前两年，货币的“水龙头”开的特别大，可以把整个田野都灌溉充分（流动性强，交易价格足够高），如果从17年开始，货币宽松结束，“水龙头”关上了，那么整个田野就会缺水——为了不引起房价大跌，就要把有限的水集中灌溉少量的田野，保持它的湿润，而其它部分的田野，休克锁死。 从这个角度来看，限购政策，并不是打压房价，而是对高房价的一种保护！大家要看透这一点。政府口里说的，和实际想做的，并不是一回事。 上海的房价到没有到拐点？我觉得这个问题，实在太难回答了。仅次于预测中国A股的拐点。 但我们不妨从一些角度来分析。 角度1：一线城市高房价的供需论 17年上海的房价，比起14年，同等地段，平均是大致翻倍的。 有人说上海北京深圳的房价高，归根结底是因为供需关系极为紧张。 但我想问了，17年供需紧张，难道14年就不紧张吗？难道17年的上海，比14年大幅增加了外地移民的数量吗？ 即使供需恶化了，人口增加了，这种变化的程度，是不足以带来房价的倍增的。 如果可以，那么在2000-2010年期间，上海的人口增速要快的多，可是当你的房价，并没有每2年翻一倍。 因此，供需论站不住脚。 还有人说“一线城市永远涨”，因为一线城市占据最优质的资源。 驳斥这种观点：优质资源可以推导出高居住价值，进而推导出高房价。你可以说上海的房价理应很高，10万一平米或者20万一平米，但是你无法推导出上海的房价应该永远上涨。 这就好比，姚明家里从小给他吃最优质的肉，这可以推导出姚明的身高很高，但不能推导出：姚明会永远长高。 实际上，自从姚明加入火箭队后，他根本就没有长高过。 这两年的暴涨，不是供需主导的，实际是货币增发主导的。既然是靠印钞票带来的暴增，那么泡沫很可能是存在的。 而上面说过了，中国的货币宽松，在17年要结束了。这是政府公开承认的事情。 角度2：国际化大都市的横向比较 在我有一定了解的国际大城市城市当中，目前上海的房价，已经大幅高于台北、多伦多、柏林，高于东京，和纽约、伦敦、洛杉矶相当，低于香港。 综合考虑到上海的自然环境、人口规模、GDP、GDP增长速度、经济活力、产业升级和创新能力、对全中国大陆的经济辐射能力，遍数亚洲乃至全球，比上海更有资本入围“全球高房价城市榜单”的城市，恐怕极为有限。 大家要特别注意GDP的增长速度和产业升级，因为这代表了潜力。 有个科技媒体朋友跟我说，他去纽约的时候，看到纽约的繁华，但是纽约的繁华景象，和5年前是一样的。而上海却不同，上海的很多繁华，是5年前完全没有的，可以想象的是，5年后的上海，会更上一层楼。 以我更熟悉的汽车和交通出行产业举例： 在2016年的上海，共享单车的创新模式大爆发，从这里走向世界（外国外地当然也有类似的，但是这个模式是首先在上海大规模验证的）。 在2017年的上海，或许更多的人会意识到，上汽车享投资的Evcard，目前的全球第一大分时租赁汽车服务提供商，正在做一件特别有前景的事情。 同样在2017年，曾经为上海贡献巨大的汽车代工和半代工产业（上汽大众、通用为代表），依然在持续发热，但新的增长点，上汽自主品牌乘用车（荣威和MG），开始借助电动车、智能化、车联网，大放异彩。 浦东的临港开发区，一直有传言，Tesla可能会在这里建设亚洲工厂。如果Tesla只要在全球建设两个大工厂，那么一个已经在加州，另一个必然在中国，有可能会放在上海。这就是成熟大都市和新兴大都市的区别！上海虽然已经成为全球最繁华都市之一，但潜力还远远没有用完呢。 一定有人会说，中国人均收入比发达国家低很多，房价不配跟别人直接比较！ 这种说法，完全没道理。 有点海外视野和独立思考能力的人，应该知道，房价从来就不必“跟当地人均收入挂钩”。莫斯科、孟买、平壤都是典型的负面案例，“房价相对很高，收入相对较低”。 道理很简单嘛，在一片给定的土地里，有100个人口和1000个人口时，单位土地资源的占有难度和价值是完全不同的。可见人口密度会极大的影响房价。 像加拿大、芬兰这种地广人稀的地方，即使人均收入很高，但因为人口密度太低，所以大部分的地方，房价可能比中国小县城还低。这不是中国政府心黑，这只是一个客观规律而已。 年轻人不要在“自己知识面有限的情况下”，轻易的在网上骂政府骂开发商骂炒房客骂别人，就是从来不检讨自己。毫无建设意义嘛。（虽然作为一名外地人，我在上海也买不起大房子，我有很多上海本地朋友，家里有多套值钱的房子，但我不觉得我应该抱怨。我本来就是上海的一名“移民”，我在家乡是可以随便买大房子的。你怎么不抱怨你在纽约没有房子呢？） 5年前、10年前，上海的房价在国际上来看，是完全不符合自己的江湖地位的。 任何看到中国目前在全球经济格局中重要地位和前景的同志们，应该有必要承认一个事实：就是北京上海深圳的房价，如果不加入“全球房价最高城市俱乐部”，这是不合理的。 从这个全球大都市横向比较的角度来看，积极的说，我觉得目前上海的房价，还算正常。 消极的说，上海已经超过东京，比肩纽约了，未来还能怎么涨呢？真的要涨到香港那么高吗？大家要知道香港的土地供应是如此的紧缺，普通市民的居住条件是如此的紧凑。如果不是这样去压榨老百姓，刻意收缩土地供应，香港的房价根本没道理那么高！ 还有一个因素，如果你考虑到，国外成熟市场有房产税，相当于每年你的房产都要被政府剥皮，房价被刻意的压抑了——而在中国不用交房产税，所以，某种程度上，上海的房价，还不算太离谱。 角度3：房产税的靴子，该何时落地？ 大家可以先看看17年两会和16年温州到期房子的处理问题。 两会期间总理谈70年土地产权到期怎么办 媒体：知情人士称土地使用权到期续费是肯定的 很可能与房产税结合 - 华尔街见闻 这种事情，官员不可能说的太明白——但是如果让我大胆猜测一下的话，70年产权也好，50年产权也好，最终都是无条件延期。 很简单，任何政府都要考虑征税成本。目前上海的老公房，很多老住户的物业费都征收不起来，还想在土地到期后，额外收大笔钱？收走老百姓的房子？这征税成本和民怨，很可能会超过征税的所得。 政府不会那么傻的。 税收的艺术在于“拔走最多的毛，听到最少的尖叫”。当然要想一个更好的办法。 或许“承认大家的私有住宅产权及其土地持有权为永久，和发达国家接轨”，或许是一个顺理成章推进房产税的办法。 既然你的房子和土地财产被明确了，那么征收一点保有环节的税，也是符合国际惯例的。 换一个角度看房产税：包括任志强老师也说过，房产税短期没戏，因为会打压房地产，进而影响土地出让金，这是很多地方政府绝对不能接受的。 所以说，地方政府其实不是怕房产税，而是怕失去收入。那如果房产税可以有效的替代土地出让金呢？ 我查了两个公开的宏观数据。目前，全国的房产价值总计在300万亿左右，而16年的全国土地出让金为3.56万亿。 做一个除法，1.2%。 也就是说，如果每年按照目前的房地产市场价值，征收年费率为1.2%的房产税，就可以圆满替代土地财政了。（实际上并不需要那么多，因为土地出让金不会一下变成0） 中国经过多年的建设，很多大城市的优质土地越来越少，未来土地出让金难以持续保持高位，是很正常的。那么适当的房产税，正好可以弥补土地出让金的缺口。 假设在2020年，土地出让金只剩下16年的70%的水平，那么只需要征收大概0.3%的房产税率，就足以稳住地方政府需要的收入。 0.3%的税率，比美国各州1%-3%左右的房地产税率比起来，已经足够具备“社会主义中国特色”了！ 简单这么一算，模型似乎是成立的。 唯一的问题是，真的房产税到来的话，很多空置、多余的房子，会加速进入市场流转，那么房价会恐慌性下跌20%甚至更多吗？ 这是一个政府需要非常严肃考虑的问题。 又有人说了，房产税征收，不会打压房价，因为有房的富人，只需要把房产税转移到房租里，让穷人交更多的租金，就可以了。 这种说法也是够蠢的，让我不得不感慨：我们首先需要搞清楚谁是自己的朋友，谁是自己的敌人。很多时候老百姓的数学并不好，他们会坚决反对“实际上对他们有利”的政策。 事实上，如果富人提高房租，穷人依然买单租房的话。他们不会浪费一分钟的，会立刻提价，根本不会等到政府征收房产税，才去做房租转移。资本家要是这么傻，还会做资本家吗？房租的定价跟成本毫无关系：10年前50万买入的上海市区2卧室住房，现在年租金达到10万很正常。你今天500万买入一套同样的房子，年租金也只是10万而已。我没法预测房产税什么时候到来。我只是感觉，根据粗浅的计算，2020年左右，或者再晚一点，房产税理论上，已经比较可行了。 逻辑很简单：前面这20年商品房改革，是一个做大蛋糕的过程，在这个过程里，可以不征税，重点是不断卖新房。等到所有的新房都变成了老房，以后新房需求大幅下降（这是必然的，因为计划生育，人口下降），新房的相关政府收入降低了，当然要在存量房里做文章。 角度4：中国的人口问题 很多分析中国人口的文章，都会谈到几个事实。 第一，中国的人口数量巅峰，可能就是16年，17年这两年。 第二，计划生育导致的老龄化问题，劳动力人口下降问题。 第三，中国的房子，最典型的销售场景是一个男人和一个女人要结婚的前后。那如果结婚的人数变少了呢？ 有人说，即使大多数地方人口下降，北上广深还是很牛逼的，因为这里的人口永远增加，有大量的移民。谁不想去一线城市？ 说这样的话的人，有脑子的。可惜只有一半。 他们还缺另一半脑子，去看到一个事实：移民去一线城市买房的典型情景是怎么样的？ 移民需要首先卖掉自己外地家中的房产，结合自己有限的存款，勉强付掉在北京上海的首付。 如果外地的人口都下滑了，房地产都不景气了，那么他们用来凑首付的钱，就大为缩水了。 一个个例的首付能力下降，只会带来他个人无法在上海买房的悲剧。 但是如果这是一个群体性现象，当所有的外地人首付能力普遍下降的时候，下一个需要下降的就是上海的房价了。这是很简单的道理。 角度5：房价的长周期特点 房价和股价不一样。后者的周期非常短，可以剧烈的频繁的波动。 但是房价常常有长周期的特点。经常持续上升十几年，而一旦下降，没有几年也是刹不住车的。 我想说：中国的这一波房价持续上涨，已经起码有15年了。 角度6：土地供应问题 北京最近宣布，2017年的土地供应，需要大幅提升。会数倍于之前几年。 印象中，之前的每一轮限购，从来没有在土地供应上，做实际的文章。 看起来，这一次，政府动真格的了。 大家自己想想，这是为什么。 这6个角度里，有对上海房价的支撑，也有不利好的因素存在。 总的来说，2017年到了，我有一些悲观。 于是我去中介挂牌，想把自己的郊区小房子卖了。 个人的10年房地产业余观察经验，全部浓缩在这篇文章里了。 本文来自一苒的知乎专栏：汽车讲谈社 发自我的华为手机","categories":[],"tags":[{"name":"乱七八糟","slug":"乱七八糟","permalink":"https://vlwq.github.io/tags/%E4%B9%B1%E4%B8%83%E5%85%AB%E7%B3%9F/"}]},{"title":"差距","slug":"2016/20161005","date":"2016-10-05T02:36:00.000Z","updated":"2017-08-27T05:52:15.885Z","comments":true,"path":"2016/10/05/2016/20161005/","link":"","permalink":"https://vlwq.github.io/2016/10/05/2016/20161005/","excerpt":"其实差别在上高中的时候就产生了。 到了高二文理分科的时候，其实就是一个人生的选择转折点。 因为从那个时候，摆在你面前的是一条又一条的十字路口。 前十几年不可改变的生活背景，教育方式和水平，以及生活重心慢慢发生改变。 人生的方向盘慢慢转交到了自己的手上。 那个时候还是一脸天真，未谙世事的学生。哪里知道以后生活的路呢？ 但是作为一个典型的危机主义者，对未来充满曙光的同时也就会有巨大的压力。 排解压力的方式也就是跟身边的好朋友谈想法谈未来。","text":"其实差别在上高中的时候就产生了。 到了高二文理分科的时候，其实就是一个人生的选择转折点。 因为从那个时候，摆在你面前的是一条又一条的十字路口。 前十几年不可改变的生活背景，教育方式和水平，以及生活重心慢慢发生改变。 人生的方向盘慢慢转交到了自己的手上。 那个时候还是一脸天真，未谙世事的学生。哪里知道以后生活的路呢？ 但是作为一个典型的危机主义者，对未来充满曙光的同时也就会有巨大的压力。 排解压力的方式也就是跟身边的好朋友谈想法谈未来。 慢慢发现人与人之间真的是有差别的。不同家庭条件的人之间是有差别的，相同家庭条件的人之间也是有差别的。 有的人读书是知道知识改变命运，有的人知道读书是为了让自己接触更高层次的人，有的人读书是为了在家庭聚会上作为长辈表扬自己的资本。 有的人以批判应试教育为理由作为自己不学习的借口，有的人明明很反对800字的八股文却还是研究如何写好。 有的人过一天算一天，有的人连大学生活都规划好了。 有的人开始学会自己搜集资料填报学校和专业，有的人高考结束将填报志愿的事情推给父母。 如果说高中是方向盘慢慢的交到自己手上，上了大学那就是方向盘完全交到了自己手上。 自由的时间多了，喝酒的机会也就多了，喝多了之后也会谈谈自己的想法和打算。 好朋友A一直强调他没有远大的志向，只想找个工作娶个媳妇不愁吃喝也就够了，想在所学的行当干干在做打算。每天干的就是打撸，所以人称外号小撸子。好朋友B是家里当地官二代，生性不羁，情商过人，却思维懒惰。大学后期家父心脏除了问题，做了搭桥手术，听了家里意见考了公务员。好朋友C 家里倾尽财力想让他去澳大利亚留学定居，为了省下学费，每天自学雅思。希望以后能在国外留学定居好朋友D 独来独往，每天准时早上六点左右起来独自一人去图书馆看书或者出去玩或者逛。很有自己的思想和见解。大学后期不喜欢土木，自己在网上投简历去上海实习转行it。 到了工作领域，接触的人也就慢慢不太一样，联系也就越来越少。但是情况却大致了解，未来的发展也大致能够估算的出来，人的感觉嘛都大致一样。 一个人的人生路程别人大致能看在眼里。 后来A还是在这个行业坚持干了下去，虽然委屈和难处很多，没有好的出路，迫于生活压力选择留守。也算努力工作。收入不高也没有用钱的地方，勉强维持生活。 B回家考了公务员，头两年生活还算潇洒，家里有房有车，经常换女朋友待在一起。后来发现自己工资还是一点点工资，而以前的同学都月薪上万了。心里开始不平衡了，也没有了出去的勇气。 C后来雅思考了七点几分，收到了澳大利亚第二好的学校的offer。努力也得到了回报，称为世界水平的高校研究生，并有定居的打算。 D转行之后，在上海也是慢慢顺手了，工作虽然辛苦却小有成就，成长的也很快。目前的月薪也是接近三万。 其实说了这么多，还就是想说明一点。 其实差别从高中的时候就开始了，从读大学的时候就开始了，从参加工作就开始了。你和任何人的差别，从你认识他的时候就开始了。只不过随着时间推移，形成了差距你才看到。 而这些差距就是你之前对于生活的的规划，和人生的摸索定位。 如今社会的发展速度只会越来越快，大城市和小城市的眼界差距也会越来越大。 千万不要在年轻的时候选择安逸的不奋斗，等哪一天发现跟身边人的差距时后悔也就来不及了。创建于 2017-02-02作者保留权利","categories":[],"tags":[{"name":"乱七八糟","slug":"乱七八糟","permalink":"https://vlwq.github.io/tags/%E4%B9%B1%E4%B8%83%E5%85%AB%E7%B3%9F/"}]},{"title":"能得到锻炼能力的机会","slug":"2016/20161001","date":"2016-10-01T02:36:00.000Z","updated":"2017-08-27T05:52:41.686Z","comments":true,"path":"2016/10/01/2016/20161001/","link":"","permalink":"https://vlwq.github.io/2016/10/01/2016/20161001/","excerpt":"“能得到锻炼能力的机会”本身就是一项极其稀缺的资源。没有锻炼的机会，你就算本身有天分也够努力，但没用，你得不到外界的营养，就会长得慢。 为什么有的宝宝长得强壮，有的宝宝长得孱弱？妈妈们会告诉你“营养摄入”的区别。为什么森林里有的树木长得高大，有的树木萎靡？因为有的树木得到了阳光，肥沃的土壤，有的树木得不到阳光，阳光被其他树木抢去了。","text":"“能得到锻炼能力的机会”本身就是一项极其稀缺的资源。没有锻炼的机会，你就算本身有天分也够努力，但没用，你得不到外界的营养，就会长得慢。 为什么有的宝宝长得强壮，有的宝宝长得孱弱？妈妈们会告诉你“营养摄入”的区别。为什么森林里有的树木长得高大，有的树木萎靡？因为有的树木得到了阳光，肥沃的土壤，有的树木得不到阳光，阳光被其他树木抢去了。 人的职业成长也一样。在中等以上资质的基础上，把你放到有阳光、有营养的岗位上，每天大量机会给你练手，你很快就能成长起来。但可惜，大部分人之所以能得到一份工作，因为那些占据着阳光营养的人，需要“打下手”、“做杂事”的人，而已。从一开始，就根本没打算让你成长。那些占据上位的人们，自己还要成长呢。当然，场面上的漂亮话还是要说的，什么帮助你成长之类，你听听就算了。 不过，就算环境这么恶劣，依然有大量年轻人能出头，他们怎么做到的？除了一部分家里人一开始就安排好阳光营养的岗位的，主要两个途径。一个是走运登上一条高速前进的大船，进去的时候还是小舢板，高速发展过程中涌进大量练手机会，巨鳄还没注意到以前，自己捞到了锻炼机会。第二条是自己摸索，不管是自己画画、做装置、写作、做生意，自己独自做事得到的锻炼机会是给人打工不能比的，但这条路比较苦痛，不建议承受能力差的人尝试。 工作这么多年，各种例子也见得很多，不过我有大量前领导同事也上知乎，具体例子就不说了。有些话，点到为止就好。成人世界之所以困难，是因为大量谎言包裹其中，“帮助你成长”即是其中之一。创建于 2016-12-29作者保留权利","categories":[],"tags":[{"name":"乱七八糟","slug":"乱七八糟","permalink":"https://vlwq.github.io/tags/%E4%B9%B1%E4%B8%83%E5%85%AB%E7%B3%9F/"}]},{"title":"毕业一年","slug":"2015/20150921","date":"2016-09-21T02:36:00.000Z","updated":"2017-08-27T05:10:39.508Z","comments":true,"path":"2016/09/21/2015/20150921/","link":"","permalink":"https://vlwq.github.io/2016/09/21/2015/20150921/","excerpt":"毕业接触社会是人生的又一次挑战。不论你的大学是如何度过的，成绩好坏，有无社会经验，是否准备充分以及是否愿意，在毕业的那一刻，你都将进入一个陌生的领域开始一段全新的人生旅程，并且你很可能再也回不到身后的象牙塔里去了。从此，无论前方是风霜雨雪，还是晴空暖阳，是陷阱沟壑，还是坦途平原，你都得坚持走下去。 希望你能有这样的心理准备：接下来要走的路，要打交道的人和组织、要经历的事以及评判你的标准，都将和你人生前20多年的经历完全不同，你将会亲眼目睹亲身体验这世界的现实和残酷，承担责任，接受挑战。 除非你有特殊的人生选择，否则进入社会将与未来要经历的择偶、结婚、生育等一样都是这辈子的大事。你得认真面对问题和处理事情，不能再稀里糊涂的混日子。如果你不是富二代或官二代，那以后的日子基本得靠你自己了。 这样挺好，你的人生终于开始动真格的了。","text":"毕业接触社会是人生的又一次挑战。不论你的大学是如何度过的，成绩好坏，有无社会经验，是否准备充分以及是否愿意，在毕业的那一刻，你都将进入一个陌生的领域开始一段全新的人生旅程，并且你很可能再也回不到身后的象牙塔里去了。从此，无论前方是风霜雨雪，还是晴空暖阳，是陷阱沟壑，还是坦途平原，你都得坚持走下去。 希望你能有这样的心理准备：接下来要走的路，要打交道的人和组织、要经历的事以及评判你的标准，都将和你人生前20多年的经历完全不同，你将会亲眼目睹亲身体验这世界的现实和残酷，承担责任，接受挑战。 除非你有特殊的人生选择，否则进入社会将与未来要经历的择偶、结婚、生育等一样都是这辈子的大事。你得认真面对问题和处理事情，不能再稀里糊涂的混日子。如果你不是富二代或官二代，那以后的日子基本得靠你自己了。 这样挺好，你的人生终于开始动真格的了。 首先，从毕业开始，你的身份就不再是学生了，从今以后不论成绩荣誉还是挫折委屈，都需要你以成年人的身份去承受。 这对所有大学生都是第一道关。过这一关没那么容易，很多人在工作了多年之后，依然没顺利通过，言谈举止思维方式为人处世依然像个学生。 这些人的问题通常在于没分清这些：过去在学校里取得的分数和学历，只是教育体制对你的考核、评判以及要求，你付了学费，所以学校要为你提供服务。而在进入社会之后，对你的评判标准是你为社会或所在的组织创造的价值，你得为别人创造价值才能实现自己的价值，而且无论自己创业还是进入组织，都是如此，你都得对自己的言行和造成的后果负责， 如果你希望自己能快速成长，希望早日通过这道关，就要学会承担责任，这是你的第一步。 还有，你也许很快就会发现，外界的人和事似乎都是不以你个人意志和喜好为转移的。不管你的主观意愿如何，事情都照常发生，很少有人在乎你的感受，就好比你用手指着太阳和月亮痛骂100年，也不会让它们的光辉减弱一丝一毫。甚至你会觉得自己很渺小，无依无靠。而这才是真实的世界。 你将逐渐体会到人在社会中生存的艰辛和不易，你会逐渐明白眼下所经历的这些也是很多人都经历过的，你得开始培养自己的韧劲和坚强，它们是你在社会上打拼所必备的意志品质。 其次，做事要认真，并且得有点激情，得有个年轻人的样子。 认真与韧劲和坚强一样，都是你最应该坚持的品质，从长远来看它能带给你最大的收益。认真的人往往会得到更多的信任和更大的机会，因为没有谁愿意把重要的任务和责任托付给不认真的人，尤其是不认真的年轻人。 这里说的激情，指的是做事情要抱有积极进取的态度。 初入社会，人的内心都会有些忐忑，对于未知的世界，都心里没底。但不管怎样，你已经“下水”了，除了尽快学会游泳，获得在社会中生存的能力，你别无选择。你慢慢发现，除了爹妈，没几个人会真正担心你会不会淹死、关心你将游向哪里、能游多远。你不扑腾，没人能替你扑腾。 年轻的优势在于能承受失败，敢于试错，敢于担当。认真和积极的态度会让你得到更多的机会，在初入社会时，别犯懒也别患得患失，看准了机会就出手。 或许你以前在性格上比较蔫，做事主动性也不强，但在进入社会之后得赶紧调整自己。这个时代的发展速度和竞争激烈程度很惊人，对人能力的要求远超过去，如果你的态度和行为不积极，很难在社会中快速找到自己的位置。 再次，在灰暗和处于低谷的日子里，你得坚定信心，培养自励的习惯。 我打赌，你们当中很快就会有人得知自己的薪资水平之后产生受挫感，会瞬间觉得理想，房子，车子和美好生活都离自己很远，每天早出晚归挤地铁坐公交的日子也会让自己觉得很渺小，甚至每个月的薪水在帝都魔都等大城市租个离公司近一点的房子都很吃力，毫无归属感。 这时候你只能坚定信心咬紧牙关继续向前，你要明白对于家境普通的孩子，眼下经历的这个阶段几乎是必须经历的。 这不是煲鸡汤，你得把这个阶段有意识地当成对你的磨砺。每个人都会遇到机会，难点在于在磨砺阶段你得在咬紧牙努力谋生的同时努力做好准备，努力去学习和积累抓住机会所要具备的知识和资源。在这个阶段，你更多的得靠自己给自己打气，自己鼓励自己。实话实说，这一关很考验人。 有很多人都说过很感谢当年处于低谷时的那个一直没放弃努力的自己，他们说的都是实话。 初入社会遇到挫折打击出现停滞或反复时，你要保持耐心。 人与人之间在认知水平、个人能力、反应速度和方法手段上都存在着差异，适应社会的速度也有快有慢。 年轻人常想迅速打开局面站稳脚跟实现价值成就理想，但这个过程的速度快慢，是要具备一定的条件，而且存在偶然性。这世界上很少有一帆风顺的事，万事开头难，能在最初阶段就做出成绩的年轻人不多，因为年轻人通常都欠缺做成事情的能力和资源。 可能没多久，你还会发现有些在学校里没怎么努力但家庭有背景关系硬的同学的起点会比你高很多，比你混得好。这时，你得摆正自己的心态，别轻易地做自我否定，或认同那些会导致你平庸的观点。 很多人会把进入社会看成一次全新的超越别人的机会，但别简单地把它当作一次比赛。你和其他人往往从事的不是同一个领域，而你自己在成长的过程中的不同阶段的目标也是不一样的，你只需做好你自己想做和该做的事，不要把眼光窄化到总盯着同学和同事的薪水和职位，踏踏实实地尽快提高你自己的能力和价值才是最应该做的事。 如果你出身于普通家庭，没背景没人脉没资金，那你除了个人努力，基本上别无选择。而且你还得记住这句话：雄心的一半是耐心。从一开始就要踏踏实实把基础打牢。就如同盖个大楼要先打地基，该挖多深，该用多少号的水泥，该采用什么材质的砖，该采用什么建筑标准，都不能含糊，不能自己糊弄自己。 学习和积累是你一进入社会就必须养成的习惯，而且应该变成长期的习惯，。 这两点的重要性无需多言，不管你在校园里是不是混日子过来的，也不管你在学校里正没正经学习，一旦进入社会参加工作，你都得快点长本事。能否在没有老师，没有考试的状态下养成学习和积累的习惯，而且是长期的习惯，对于需要快速学习大量学习各种知识，迅速成长的你来说非常重要。 如果有条件，可以买个电子阅读器，多看书，别把上下班路上的时间都花在手机上，如果每周能读一本书，每年就是50本，在注意记录和整理笔记，三五年下来，知识储备的底子就打下了，那时候你思考问题的方式和看待事物和社会的角度将有很大的提升。 PS：初入社会，在认真工作之余，超越别人的奥秘都在工作八小时之外，关键看你怎么利用时间。 进入社会和职场后的首要目标是早日令自己拥有不可替代性。 所谓不可替代性，通俗点讲就是什么事是只有你能做到而别人做不到的，什么工作是缺了你就玩不转的，什么技能是只有你会而别人不会的，什么资源是只有你有而别人没有的，什么角色是只有你能担当的而换别人就不行的。 即使在短期内你不能在行业范围内拥有不可替代性，也要努力在组织和公司内部拥有。越早具备不可替代性，你的价值就会实现得越早，薪资待遇就会与你的价值更匹配，在职场的竞争力就越强。 PS:一个判断自己价值的方法：工作几年后，是否会有猎头给你打电话给你推荐职位，这是个小信号。在此之前，基本上你的价值都很有限。 尽早做决定：自己究竟适不适合在大城市发展，究竟适不适合离开爹妈在北上广深等大城市做个单枪匹马的“兰博”。 这条算个小提醒吧，你要想清楚自己内心更看重的是什么，追求的是什么，并估算出你要付出的成本和代价。 如果你现在还不清楚的话，可以在大城市先折腾几年再做决定。人有梦想是好事，但不是每个人都适合做北上广深做“兰博”，幸福未必只有在大城市才能得到。 还有个提醒：有很多人在大城市努力了很久，却一直没有突破，这时要多反观自身的能力。有些人能做到的事，换个人未必也能做到。这世界并不是努力就有回报，而是能力、资源和运气都具备了，机会才有可能被你抓住。 千万别忽略自身具备的能力和资源，只怀着一颗热情执着的心与不切合实际的目标死磕。人的奋斗过程有些类似于上台阶，如果你经过长期努力但连最基础的台阶都上不去，那你就应该慎重考虑了。 再送剂预防针： 理想和现实是有差距的，刚毕业的大学生初步体验了社会之后，可能会多少有些失望，甚至更加迷茫，为自己的前途和处境上火、闹心、焦虑。这都是正常状态，说明你有进取心。其实，每个年轻人要面对的事和要学习的东西都很多，除非你是富二代，有爹妈帮着铺好了路，搞定了一切，否则作为普通家庭出身的你，如果天天都睡得着睡的香，什么也不合计，什么也不琢磨，未必是好事。 最后送一段话，特别送给那些在大学期间没认真学习，迷迷糊糊就毕业走进社会的年轻人： “我们常常有勇气改变，因为这只需要一个晚上的鸡汤。我们往往没能力改变，因为这真需要经年累月的苦干” 加油。创建于 2016-11-24作者保留权利 发自我的华为手机","categories":[],"tags":[{"name":"乱七八糟","slug":"乱七八糟","permalink":"https://vlwq.github.io/tags/%E4%B9%B1%E4%B8%83%E5%85%AB%E7%B3%9F/"}]},{"title":"结束了把","slug":"2016/20160920","date":"2016-09-20T02:36:00.000Z","updated":"2017-08-27T05:44:49.901Z","comments":true,"path":"2016/09/20/2016/20160920/","link":"","permalink":"https://vlwq.github.io/2016/09/20/2016/20160920/","excerpt":"金也空，银也空，死后何曾握手中。妻也空，子也空，黄泉路上不相逢。权也空，名也空，转眼荒郊土一封。田也空，屋也空，换了多少主人翁。爱也空，恨也空，人生陌路不相逢。喜也空，悲也空，无非都是在梦中。","text":"金也空，银也空，死后何曾握手中。妻也空，子也空，黄泉路上不相逢。权也空，名也空，转眼荒郊土一封。田也空，屋也空，换了多少主人翁。爱也空，恨也空，人生陌路不相逢。喜也空，悲也空，无非都是在梦中。 [cp]“ 有些事，就是不值得被原谅，跟大不大度没有关系。各有各的底线，做错了，就应该考虑为自己的错误付出代价。” 不是每个对不起，都能换回来一个没关系，珍惜！[/cp] [cp]不是每个人，在你后悔以后都还能站在原地等你。不是每个人，都能在被伤过后可以选择忘记，既往不咎。我不好，但只有一个。珍惜也好, 不珍惜也罢。如果哪天你把我弄丢了，我不再让你找到我。人的感情就像牙齿，掉了就没了，再装也是假的。友情也好，爱情也罢。我若离去，后会无期。[/cp] 三观真的很重要，比如两个人去买东西，买贵的还是便宜的，选实用性还是外观，两个人观点不一致就有吵架的可能性。“一个支配型的男人往往娶了一个依赖型的女人，一个喜欢控制的高调女人恰好嫁给了一个被动型、事事靠他人决定的低调丈夫。”我觉得这些就是情感中最重要的东西，并且很难改变，而其它的都是小问题，慢慢都能改变 门当户对很重要，尤其是精神世界。其实很多人都误解了门当户对的含义。老一辈总说门当户对，并不是说一定要社会地位和财产有多么相匹配，而是这样的两个家庭教育出来的孩子思想观念和大致的追求是不会差太多的。 父母作为过来人，作为一个对你的爱情非常了解的旁观者，他们要更加的有经验，更加的理智，看得更加清楚！当然父母也是人，是人就会有局限性，他们的眼光不一定都是准确的！但是对于大部分人来说，父母作为过来人，还是比你要有经验得多！看事情还是要更加准确一些的！为了少走弯路，少受伤害，听父母的真的是个不错的选择！我承认也有小部分人，受到父母的反对，最后过得很幸福的！但是这样的人毕竟属于少数，绝大部分的时候，父母非常反对的婚姻往往过得都不怎么幸福，这是事实！不要再那么的执迷不悟下去了！哪怕你不一定最终要听父母的，你也要尽可能的听进去父母说的话，好好的想一想、考察一下你眼前的这个人是不是你想要找的那个人，是不是值得你为他去做这一切！ [cp]他有多快爱上你，就有多快爱上别人。其实在感情之中，付出多的那个不一定就是失败的一方 ，对一个人好，即使没有回报，至少永远不会白费 ，若干年后突然想起 ，泪流满面的那个人，肯定不是你。[/cp] 脾气都是磨出来的，坏毛病都是惯出来的，治的了你脾气的是你爱的人，受的了你脾气的是爱你的人。每个人都有脾气，为你忍下所有的怒气，仅仅因为那个人比你更心疼你。每一段爱情都需要忍耐，如果有个人对你特别好，记得千万别把那个人弄丢了。 年轻时候恋爱，总是忍不住要去考验人家。其结果就是别人经受住了考验，她又怀疑是不是自己出的题不够难。她坚定地认为没经历过考验的感情是不可靠的，所以，没有麻烦，就制造麻烦。最后终于把人家弄服气了，只要她一愁眉苦脸，人家就知道她又要来这套，渐渐有些不耐烦——于是她终于找到了他不爱的证据。 唉。 你之所以去考验人家，就是因为不信任人家。你不信任人家，却要求人家死心塌地，天底下没有这样的好事。一旦有这样的好事，不合格的也不是人家，而是你自己。创 [cp]“没有人是天生脾气好啊 对你好真的是因为你很重要”[/cp] “小仙儿，真不明白么?我们两个人是一不小心才走到这一步的?你仔细想想，在一起这么多年，每次吵架，都是你把话说绝了，一个脏字都不带，杀伤力却大的让我想去撞墙一了百了，吵完之后，你心里舒服了，想没想过我的感受?每次都是我自己舔着脸跟狗一样自己找一个台阶下!你永远趾高气昂，站在原地一动不动。这一段楼梯，我已经灰头土脸的走到最下面了。你还站在最高的地方，我站在这下面，仰视你，仰视的我脖子都断了，可是你从来没想过，全天下的人，难道就只有你有自尊心么?我要不然就一辈子仰头看着你，或者干干脆脆的转过身带着我的自尊心接着往前走。你是变不了了，你那个庞大的自尊心，谁都抵抗不了;但我不一样，小仙儿，我得往前走。说这么多，你明白了么?” 沉浸在失恋伤痛中的人是没有资格判断自己是不是真的爱一个人的。很多人，根本不爱对方，也根本没有爱一个人的能力，只是因为自私，每天把爱挂在嘴边感动自己。 所有不经过深刻反省、抉择和改正的重修旧好，都是重蹈覆辙。 你只是一个被欲望操控的男人，不是一个能主宰自己的男人。 你是一个不太爱自己的男人。 因为你没有自己的生活，你居然可以为了一个刚认识的女孩就献出生活的全部？ 试问这样的男人有什么值得女孩儿喜欢的呢？ 其实不仅仅是男人，女人也一样，因为不爱自己，为了自己的情欲而忽略自己。 人是自己的镜子，你爱自己，自然会爱爱你的人。 一个不爱自己的人，是无法懂得感恩和回馈的。 [cp]@合衬暖男: 你所能够伤害的，只有爱你的人。因为爱你，会为你情绪波动而难过；因为爱你，会因你偏激的话语和行动而痛苦。 你所能够伤害的，只有爱你的人。因为你知道，什么样的语言最令他难堪，什么样的行为会令他失望；因为你知道，他爱着你，所以从来肆无忌惮。[/cp] 情感的本源是性需求，性需求是为了繁衍，是生物本能。人之所以为人，是因为人有理智，而极端的理智，就会产生爱。爱会尊重生物本能，尊重欲望。虽然很多人并不懂我说的什么，但这是真相。 巨蟹水瓶双鱼 德国啤酒，西班牙橄榄油 大手牵小手 乔治克鲁尼","categories":[],"tags":[{"name":"乱七八糟","slug":"乱七八糟","permalink":"https://vlwq.github.io/tags/%E4%B9%B1%E4%B8%83%E5%85%AB%E7%B3%9F/"}]},{"title":"实体凋敝，金融暴走","slug":"2015/20150901","date":"2016-09-01T02:36:00.000Z","updated":"2017-08-27T05:55:14.410Z","comments":true,"path":"2016/09/01/2015/20150901/","link":"","permalink":"https://vlwq.github.io/2016/09/01/2015/20150901/","excerpt":"作者：neo anderson链接：实体凋敝，金融暴走 - 卢瑟经济学 - 知乎专栏来源：知乎著作权归作者所有。商业转载请联系作者获得授权，非商业转载请注明出处。 今年年初写的一篇旧文，现在看基本都在按照预期运动。 （一）双重危机 如果以财富衡量，人类社会可能是唯一熵减的系统。市场经济中，唯一可以确定的是马太效应，即财富是单向汇聚的，一切经济问题由此产生。由于财富单向汇聚，社会形成金字塔结构。 这种结构注定对应大量产品滞销，大批债务无法偿还。 金子塔顶层拥有大量财富，撑的要吐，有能力消费没需求，消费不足。底层的收入被压到最低，饿得要死，有欲望需求没支付能力，也是消费不足。金字塔两端都消费不足，对应的必然是大量产品滞销，产能过剩。 产能过剩，对应大批工人的劳动力滞销。他们的产品没人要，他们的劳动力自然没人要。于是，企业处于破产、停产、半停产状态，他们处于失业、半失业、放长假的状态。 这是表现在产能和就业上的现象。 多说一句，一些企业靠贷款维持最基本的运转，这些企业就成了“僵尸企业”。这些企业的工人，被扣上懒汉的帽子。","text":"作者：neo anderson链接：实体凋敝，金融暴走 - 卢瑟经济学 - 知乎专栏来源：知乎著作权归作者所有。商业转载请联系作者获得授权，非商业转载请注明出处。 今年年初写的一篇旧文，现在看基本都在按照预期运动。 （一）双重危机 如果以财富衡量，人类社会可能是唯一熵减的系统。市场经济中，唯一可以确定的是马太效应，即财富是单向汇聚的，一切经济问题由此产生。由于财富单向汇聚，社会形成金字塔结构。 这种结构注定对应大量产品滞销，大批债务无法偿还。 金子塔顶层拥有大量财富，撑的要吐，有能力消费没需求，消费不足。底层的收入被压到最低，饿得要死，有欲望需求没支付能力，也是消费不足。金字塔两端都消费不足，对应的必然是大量产品滞销，产能过剩。 产能过剩，对应大批工人的劳动力滞销。他们的产品没人要，他们的劳动力自然没人要。于是，企业处于破产、停产、半停产状态，他们处于失业、半失业、放长假的状态。 这是表现在产能和就业上的现象。 多说一句，一些企业靠贷款维持最基本的运转，这些企业就成了“僵尸企业”。这些企业的工人，被扣上懒汉的帽子。 话题转回来。 金融是经济的血脉，抛开赌博投机不说（赌博投机的问题后面再说），货币流通是商品流通的逆运动。 主要货币是信用货币的时代，每一笔贷款对应两部分，获得贷款的企业或个人，同时拥有两样的东西，一笔钱和一笔债务。这笔钱，很快会被金字塔顶层吸走，而这笔债务却无法偿还——因为顶层已经撑的要吐，他们并不想购买底层提供的商品或劳务，或者，即使他们购买也非常有限。所以，社会顶层拥有大量利润的时候，必然对应社会中下层背负沉重的债务。 社会底层的债务到期无法偿还的时候，要么破产倒闭，要么申请贷款苟延残喘。底层破产倒闭时，顶层用积累的货币购买底层拍卖的财产，同时债务归零。不足的部分，银行承担。银行的自有资产承担不了，银行倒闭。储户的账户数字归零。这个过程很惨烈，有人一夜之间一无所有，上吊、跳楼，有人趁机从地板上捡战利品，就是金融危机。上吊自杀的是中下层，趁机捡战利品的是顶层。 金融危机和经济危机是一个硬币的两面，起因都是财富的单向汇聚。 货币淤积在顶层，商品流动就不会顺畅，债务也难以偿还。这个道理很简单。但是，要承认这个道理，就要承认社会财富的单向集中不利于经济顺利运转，并做出相应的经济政策调整。这就很困难了。 毕竟，不同的社会阶层对经济政策的影响力是完全不同的。金字塔社会，顶层的影响力远远大于社会底层——否则也不会形成金字塔型社会。 （二）药方选择 这种情况怎么解决，顶层可以要钱不要命，政府不能看着不管。不然失业率爆棚，那还得了？目前有四种解决方案，一是鼓励投资，二是增加出口，三是政府印钞购买这些产品，四是否定金字塔型的社会结构。 在产品全面滞销的时代，没有人会主动投资。 金字塔顶层不是傻子，现有的产品卖不掉，继续扩大产能，增加投资那不是犯傻吗？ 于是，有人提出创新。新产品出现了，原有的产能要被淘汰，为了更新换代，都要买新设备，内需不就上去了吗？ 话说回来，创新哪那么简单？蒸汽机替代人力、畜力、水力，内燃机、电动机替代蒸汽机，都需要科学界重大的理论突破，否则新产品与老产品之间很难有跨代性的突破，改一改外形设计，优化一下结构，增加点功能（许多功能还是华而不实的），这样的创新没多大意义。想想就明白，没有巨大的技术门槛，能创新早创出来了。 当年硅谷的奇迹，其实是美国政府和军方多年来大量投入产生的军用技术积累在短期内商业化的军转民的过程——巨大的势能早已具备，剩下的只是谁来推动，让这些势能释放出来。于是，释放这些势能的人，成了风口上的猪。站在台风口，一头猪都能飞起来。没有台风，猪还是猪，飞不起来。看不到台风，只看到猪在飞，以为自己像飞起来猪一样伸展四肢就能飞起来，那是猪的思维。 看不到当年理论突破支持的技术突破，看不到对应的美国政府和军方技术积累，只看到几个大学生，在硅谷租几间办公室就能创新，那是一叶障目不见台风。以为只要弄几个大学生，搞几栋写字楼，就能创新，就能再造一个硅谷，就能拉动经济，那就更愚蠢了。 如果出口情况不错，那么问题会好解决一些。顶层消费不了，底层消费不起的商品推出去，换成钞票回来。顶层继续赚钱，底层有饭吃，暂时皆大欢喜。 长期看，这也有问题：第一，这些钞票怎么用？钞票不是黄金，攒多了要贬值。（这些钞票不是没有用，后面谈用处。）第二，别的国家不乐意，你国内的就业解决了，我国内的产品滞销了，我的工人失业了，为了不让你的商品进来，我要用各种手段阻止你，包括检验检疫，包括配额，包括关税，包括各国产品标准等等。第三，别的国家遇到经济危机，不再要本国的商品怎么办？第四，就业高度依赖别国的市场，两国关系一闹翻，本国失业率马上爆棚。 本国政府不断购买商品，有两种方式。 一种是直接启动印钞机，这是中央政府的特权。政府印钞，购买商品，顶层聚敛财富，底层有活干。代价是通胀和泡沫不断上涨。一种是用政府使用贷款，这是地方政府常用的手段。代价是通胀和泡沫不断上涨，外加地方政府陷入债务危机。 如果不想本国通胀爆棚、泡沫破裂，地方政府破产，这种模式就不能一直玩下去。 把顶层多余的钱收上来，返还给底层，是最后一种模式。这种模式，顶层绝对不干。对顶层征税，那还了得？所以，也很难推动。 说来说去，四种模式或者不可行，或者有局限性，或者有长期的隐患，或者难以推行。 （三）开闸放水 对政府来说，只能死马当活马医。 增加廉价的贷款和劳动力供应，提高利润，促进资本增加投资。这就是缓解危机思路。 这种思路的来源是萨伊定律的供给创造需求，认为生产者可以完全不顾产品滞销，不断扩大投资，增加供给。 具体操作，首先是鼓励民间投资，鼓励互联网 ，减少审批，放松贷款。 先是年轻人创业。年轻人花光了爹娘饿储蓄以后，产品没有销路，只好该干什么干什么去。因为社会贫富差距太大，两端消费不足，全社会没有对应的消费能力，导致传统产业没有销路，现在加上互联网就有销路了？个别的有销路，因为着更多的滞销。 减少审批、加强监管，放管结合，放要放到位，管要管到位。说起来很容易，操作起来完全没有可操作性。如果车站、机场取消了安检，然后把维护安全的任务全部转嫁给乘警或空乘。那会是什么效果？想想就清楚。不在入口排出风险，在运转过程中就是搞人盯人，也盯不过来。再加上一句，法无禁止皆可行，那就更厉害了。还是车站、机场的例子，危险分子是把危险品带上交通工具了，但是只要他不点火，乘警或空乘就既不能随便搜他的行李，也不能把他怎么样。 有人问，如果危险分子点火造成重大事故呢？按照守土有责的原则，那就是乘警和空乘的失职了，要被严肃处理了。 所以，在这种情况下，各种金融骗子如雨后春笋一样层出不穷，各种金融案件造成几万、几十万人损失，那就是情理之中的了。 涉及健康的食品安全也成问题。放开食盐专营，结果各种假盐案迅速爆棚。 资本为了利润可以上断头台，诈骗造假，算什么？ 放松贷款，更可怕。 整个经济循环不是没有钱，而是钱聚集在少数人手里，不能顺利回流。这样一来，导致大量的贷款无法顺利偿还。现在继续放松贷款，现在经济循环中的钱更多了，债务也更多了。短期看，大量的债务可以通过直接或间接的借新还旧，暂时掩盖过去。长期看，必然是更大的窟窿。 那么能不能一直放贷款，不断借新还旧下去呢？不能。 截至目前，人类历史上，还没有在经济停滞期，天量放贷款不引起通货膨胀和资产泡沫的例子，也没有通胀不失控、泡沫不破裂的例子。 整个经济体内需不足的时候，注入这些货币也不会投入生产循环。但是，这些钱也不会闲着。社会顶层获得大量现金以后，必然投机，往往炒房、炒地、炒各种生产生活必需品，通过炒作而不是生产过程进一步聚拢财富。 滞涨沫崩，政府至少要选一个。不想选崩滞，向经济体内注入货币，就会出现涨沫。反之亦然。 （四）金融暴走 消费不足，产品滞销，工人失业，机器闲置，与之对应，资金自然也闲置。于是，经济体内部出现一个奇怪的现象，一面是货币总量不断上涨，一面是对应的债务不断增加。 大量货币失去投资方向，四处乱窜，寻找“价值洼地”。 这些货币冲进股市，就会造成股市疯牛。冲进楼市，会造成楼市疯涨。冲进生产生活必需品市场，就会导致物价疯涨。这些货币在国内的投资，与其说是投资，其实都是庞氏骗局式的投机。甲之损失，乙之收益。 还有高利贷，投资者惦记对方的利息，对方惦记他的本金。 这些现金在金融、投机过程中，不断汇聚集中，就是不进入实体经济。大量产品滞销，需要减价处理去库存的时候，只要思维正常，谁会主动增产？ 这些现金进入投机市场，却不会消亡在其中。某甲购买了某乙的房产，某甲申请贷款，背负债务，某乙获得现金。现金由某甲的手中流动到某乙手中。某甲失去了继续投机的能力，这个能力被某乙获得。某乙购买了某丙的股票，某乙失去继续投机的能力，某丙获得这种能力。 现金不消失，只是不断流转。 这些现金绝对不会去购买那些滞销的产品，只会投机，随时可能制造新的泡沫、通胀。所以，滞销的钢铁、煤炭的价格不断下降，住房、股票、食品的价格却可能猛涨。 那些在实体产业挣了点小钱，或者苦苦挣扎还没破产的中小企业主，也会变现资产，加入高利贷、投机的行业。于是，在整个实体经济萧条的时候，金融、投机却异常火爆。这种火爆，进一步压缩实体经济的资金来源。 这时，生产性行业和地区首先发生断崖式下跌。与此同时，金融投机行业和地区因为失业资本源源不断涌入，还保持虚假的繁荣。 实体产业变化不大的情况下，不能产生对应的利润。资产价格飞涨，如果不是对应通胀，就是泡沫。一般来说，这种建立在泡沫基础上的投机，源自甲之损失乙之收益，所有人都收益，只能源自源源不断的货币涌入，经济规模变化不大，货币远远涌入就酝酿溢出，通胀的风险。 投机从来都是不稳定的——即使有外来资金源源不断涌入，也是如此。 一方面，随着价格上涨，供给会大幅增加。任何商品的供给一旦大幅增加，就不再适合投机。股市上涨，必然吸引IPO。楼市上涨，必然会有大量新开发的楼盘上市。另一方面，随着投机品价格上涨，投机品持有者的其他选择也会出现。比如，出售国内房产，移民北美、欧洲。比如，出售房产，投机粮食等更紧俏生活必需品。 这些现金进入股市、楼市的时候，一片虚假的繁荣，离开的时候，一地鸡毛。那些跟风进入股市、楼市试图发财的人，他们如果没有及时找到接盘者，没来得及变现，就会成为股东、房东，没挣到钱，大多数还欠了一屁股债。因此，发生过投机的领域，不易产生新的投机。因为很多人损失惨重成为房东、股东，获得利润大资本不会轻易买回他们手中的筹码，解放他们。 （五）债务转移 投机如同赌场，甲之损失，乙之收益。除非偿还贷款，否则这些货币不会主动消失，这些钱哪里去了？这些钱大多成为社会顶层的战利品，成为他们的利润。或者，为他们偿还债务。 由于经济周期的不可预测的性，任何使用的融资手段的社会成员都可能在危机时期负债，社会顶层也不例外。 但是，不同的社会成员陷入债务危机之后的处境是绝对不同的。大多数企业不断借新还旧，自然背上越来越沉重的债务包袱。 全社会产品滞销，希望销售商品不断盈利，偿还债务，基本没有可能——除非产品是长生不老药。不过，以目前的科技，类似让顶层有无限需求的产品还没有生产出来。 那些获得利润的债权人，也不会无偿地用自己的利润，填平债务人的债务，除非廉价收购债务人的资产。正常情况下，企业或个人的债务只会不断增加，不会下降。社会中下层陷入债务危机，一般难逃倒闭破产。 黄世仁不让杨白劳破产，怎么能霸占喜儿？不让房奴破产，怎么能收回他们的房子？不把一些潜在的利润丰厚的企业逼上绝路，怎么能用地板价收购？ 不过，与社会中下层不同，社会顶层有影响国家决策的能力，可以通过调整国家政策，把债务转嫁出去，转嫁给接盘侠。至于金融资本，则更是王中王，如果陷入债务危机，比如在股市套牢，甚至可能由国家，也就是全民接盘。 何况，即使负债的社会顶层破产，他们的财产也不会分散到社会底层，而是会由其它社会顶层瓜分。经过这种瓜分，财富进一步汇聚。 把债务流转出去，让别人帮自己背锅。资金会流转，债务也会流转。 地方政府贷款修铁公基，卖地还债。开发商贷款卖地盖楼，卖楼还债。地、楼，卖不掉的时候，地方政府和开发商会不断借新还旧。 这时，央行会放松利率，让他们活下去。直到他们找到接盘侠。 顶层不会承担地方政府和开发商的债务，这些债务必然设法转嫁给社会中下层。 比如，取消房屋限购，取消私人房产总量限制和持有年限的限制，降低转手交易税费，让房产变成类似股票的投机品。比如，国家出政策，鼓励散户借钱炒股。那些借钱炒股的散户最终难免背上债务，但是他们的损失成为别人的收益。再比如，在某些利益集团陷入债务期间，降低利率。降低利率有三个目的：第一减轻利息负担；第二推高投机品的价格，吸引接盘侠；第三有利于接盘侠贷款接盘。 经过疯狂的投机，许多兴冲冲冲进投机市场的社会中下层，成为接盘侠。他们交出现金，接过别人抛出的投机品，成为房东、股东。 一旦这些接盘侠用自己的债务置换地方政府和开发商的债务之后，央行就没有那么多顾忌，也没有必要降低利率了。那时，如果形势需要，比如物价失控，比如本币面临巨大的贬值压力，可以开始加息了。 上吊自杀是接盘侠的事，市场有风险，入市须谨慎。谁让接盘侠当初不谨慎？ 经过这债务转移的过程，绝大多数人都会破产。最终，土豪死于股权信托、中产死于非标理财、屌丝死于P2P。虽然他们破产，他们的财富不会消失，而是会集中到少数人手中，或者替少数人偿还债务。 （六）实体凋敝 相比地产和金融，资源、生产型企业往往就没这么幸运了。 它们正在遭受多重挤压，苦苦挣扎，随时面临破产倒闭的风险。 首先，因为有效需求不足，导致产品滞销。既然产品滞销，那就是产能过剩，要关停并转去产能。一大批工人正在或即将处于失业、半失业的状态。大规模失业，进一步压缩有效需求。由于社会经济规模受制于有效需求，压低有效需求，社会经济规模也必然下降。其次，为了避免投机资金把外汇当成价值洼地，宁可消耗巨额外汇储备，也要维持强硬货币的形象。这必然导致商品倒灌。 如此一来，国际市场上，原有的产品价格优势不再，已经不再具备物美价廉，性价比高的优点。原有的出口订单，急剧下降。粮食、水果、乳类、肉类等食品，煤炭等原材料的商品倒灌必然对国内的食品生产、加工行业和煤炭等原材料行业产生了毁灭性的影响。商品倒灌进一步压缩本来就严重不足的有限的内需。（另外，商品倒灌严重影响外贸盈余，外贸盈余下降，外储增量下降。外储是维持本币汇率稳定的最重要的资源。一旦外汇下降到一定程度，本币的汇率就无法保证。） 再次，各种投机，尤其是房地产投机，难免推高生产企业成本，挤掉最后一点可怜的利润。每一样商品都包含地租。地租无处不在。房价上涨，房租上涨，工人要求涨工资。房价上涨，零售商品价格上涨，工人需要涨工资。房价上涨，人工成本上涨，原材料价格上涨。房价上涨，厂房租金上涨，生产成本上涨。只要房价上涨，人工、原材料、厂房租金会全部上涨。还有，各种投机使财富迅速集中，社会金字塔更加尖锐，顶层聚敛越来越多的财富，底层不断套牢。内需更加不足。 最后，由于投机加剧，资金源源不断地流出，债务负担越来越重，面临被瓜分的风险。既然干几年实业，不如稳稳当当炒房，那么盈利的企业必然不再增加订单，而是减少投资，甚至逐步压缩现有生产规模，把富余资金投入投机之中。全社会生产规模下降，亏损的企业，更加难以盈利，只能不断借新还旧，最终被利息压垮，难以脱身。 企业的困境，加剧当地的困境。生产性行业不断凋蔽，资金不断流向金融投机行业。生产性地区经济全面下滑，当地财政陷入困境。在实体凋蔽时期，同样是金融投机，生产性地区的房产往往很难成为投机目标。这时，甚至有人抛售生产性地区的房产，去金融业为主的地区买房。 经济崩溃的地区，难以就业，无法生存，是当地社会底层迁徙的原因。经济崩溃地区的房产难以升值，没有利润，大量失业人口聚集，社会治安下降，是当地社会顶层迁徙的原因。于是，这些地区人口净流出的地区。 经济萧条，地方政府财政收入必然下跌。 这时如果推行税制改革，便可能使生产性省份的税收进一步下降，因为不同税种的所属不同，有些税种的全部或大部分税款要上缴中央政府，而不是留给地方政府。 对这些地区来说，祸不单行。经济下滑，税基下降；税制改革；税收大部上缴中央政府；本地土地投机不旺，无法炒作土地获利。 实体凋蔽，金融暴走的时期，生产性地区的财政危机，几乎是难以避免的。这时，地方政府会想尽办法筹钱，一般来说，主要包括砸锅卖铁、挖地三尺、沿门托钵。如果这三招不太好使，上级政府又不愿意伸出援手，当地基本难免财政破产。 失业人口怎么就业？全民创业是不靠谱的。大家都修自行车，卖早点，摆小吃摊，开杂货铺，且不说城管管不管，哪有那么多自行车可修，那么多人买早点，吃小吃，买百货？多数人只能向金融投机地区移民。 维护治安也好，赈济灾民也好，都需要钱。地方政府偏偏没钱。 （七）致富良机 地方政府挖地三尺，必然激化社会矛盾，所以必然尽量采取其他相对温和的手段。极少数人等的就是这些地区的地方政府沿门托钵、砸锅卖铁。 规模较小的企业任其自生自灭，规模较大的企业则要完成化公为私的过程。 陷入债务危机的企业，不会由国家出政策获得去库存的机会，它们被划为僵尸企业，被描述成拖垮全国经济的包袱——却没有人分析，既然有亏损就有盈利，那么这些僵尸企业的亏损哪里去了，成了谁家的盈利。至于没有陷入债务危机的企业，被描述成阻碍全国复苏的障碍。 其实，按照这个标准，房地产企业基本都可以算是僵尸企业。 社会顶层在刺激经济，投机、转移债务的过程中获得了大量的利润，免去了大量的债务，这些利润干什么用？自然是用于产权扩张，瓜分肥肉。 债务不能被减免往往被划为僵尸企业，将被强行停止借新还旧的过程。然后，通过各种手段化公为私。 这一方面是因为他们没有影响决策的能力，一方面是一部分社会顶层渴望在它们陷入债务危机时期，以极低的价格廉价收购它们，或者让他们化公为私。 有些时候，原先的管理层也希望推动这个过程。因为许多时候，私有化之后的管理层就是原先的管理层，唯一的变化，是这些人从企业的经营者，变成了企业的所有者。 这些企业经过这样的过程，真的提高了效率了吗？只有天知道了。 不过，可以确定的是，这必然导致工人命运的转折。他们和管理层的命运从此分道扬镳，从此进入金字塔基，难以翻身。 当年东北的大下岗，便是一个失控的化公为私的过程。大量财富在一夜之间化为私有。占据这些财富的原领导层知道这些财富来路不正。所以，他们迅速变现。这个过程，通俗地说，是拆毁大楼卖钢筋。 他们并没有投资实体产业，搞再生产，而是把变现的资金用于购买房产或者金融产品，然后去当寓公。头类富豪移民海外，二等富豪移民北京、上海，三类富豪移民大连。他们都成了食利者。 那些失业的劳动者，丧失了工作的机会。他们就是开个小店都没有消费者，搞三产增加就业只是一句空话。于是，只好全国各地打工。对这些劳动者来讲，他们没有资本，只有廉价劳动力，不外出打工，又能怎么样？ 于是，富豪和穷光蛋都出来了。 东北的经济，只能靠残存的一些国企和政府的支出维持。有这些最基本的企业生产、政府支出和对应的消费，才能有少得可怜的有效需求，支持规模有限的二产 发自我的华为手机","categories":[],"tags":[{"name":"乱七八糟","slug":"乱七八糟","permalink":"https://vlwq.github.io/tags/%E4%B9%B1%E4%B8%83%E5%85%AB%E7%B3%9F/"}]},{"title":"注重生活体验，着眼点放在你自己的内心","slug":"2016/20160823","date":"2016-08-23T02:36:00.000Z","updated":"2017-10-13T15:28:19.856Z","comments":true,"path":"2016/08/23/2016/20160823/","link":"","permalink":"https://vlwq.github.io/2016/08/23/2016/20160823/","excerpt":"我跳槽，不是因为待遇，而是：1、受不了银行这类国企的气氛；2、不喜欢银行IT的工作，太死板，太没有成就感；3、进了银行，往上升很大程度上不取决于自己的技能了，有太多其他因素；还是喜欢靠本事吃饭，虽然很可能只是粗茶淡饭。 虽然业务能力得到了很大提升，但思维模式得到了固化，做事更多的开始依赖过往的“经验”，而不去思考它的其他可能性。","text":"我跳槽，不是因为待遇，而是：1、受不了银行这类国企的气氛；2、不喜欢银行IT的工作，太死板，太没有成就感；3、进了银行，往上升很大程度上不取决于自己的技能了，有太多其他因素；还是喜欢靠本事吃饭，虽然很可能只是粗茶淡饭。 虽然业务能力得到了很大提升，但思维模式得到了固化，做事更多的开始依赖过往的“经验”，而不去思考它的其他可能性。 很多年轻人因为阅历的关系，其实不明白一个道理：人的欲望是无限的，你得到原来想要的，还会想得到更多，就像某些人没有iPhone的时候，做梦都想要，等用到一段时间之后，也就觉得就那么回事，一个手机而已（仅仅举个例子，什么豪宅，跑车，名表，名包，美女都那么回事，时间长了兴奋感都会消失），如果一个人的人生是欲望驱动的，那必然非常看重输赢，如果是这样的价值观，感受到的快乐也就全都来自于赢的一瞬间，不会长久，甚至很多人会为了赢做很多不喜欢的事情，反而本末倒置，不少所谓的成功人士的抑郁症就是这么来的。 可能有人就问了，那怎样才能快乐呢？注重生活体验，着眼点放在你自己的内心，热爱生活，享受生活，不在乎输赢，而在乎做一件事的体验，在乎自己的成长，不要太在意外部强加的价值观，是的，这样，你可能不会成为外人眼里成功的人，得不到令人艳羡的目光，但你活的踏实，真实，平稳，而且最重要的，你活出真实的你自己，你有底气露出自信，满足，真实的微笑（这个答案肯定有很多人看不懂，我不要求每个人都懂）。 dudu$ apt-get update$ apt-get install python-pip$ pip install setuptools$ pip install shadowsocks$ nano /etc/shadowsocks.json{ “server”: “${ip}”, “server_port”: ${port}, “local_address”: “127.0.0.1”, “local_port”: 1080, “password”: “password”, “method”: “aes-256-cfb”, “fast_open”: true, “timeout”:300}$ ssserver -c /etc/shadowsocks.json -d stop$ ssserver -c /etc/shadowsocks.json -d start","categories":[],"tags":[{"name":"乱七八糟","slug":"乱七八糟","permalink":"https://vlwq.github.io/tags/%E4%B9%B1%E4%B8%83%E5%85%AB%E7%B3%9F/"}]},{"title":"别给自己找借口","slug":"2015/20150823","date":"2016-08-23T02:36:00.000Z","updated":"2017-08-27T05:10:34.248Z","comments":true,"path":"2016/08/23/2015/20150823/","link":"","permalink":"https://vlwq.github.io/2016/08/23/2015/20150823/","excerpt":"我经常能收到各种回复、提问、私信，有五种我不会回答，有这五种思维的人在现实生活中，我也会尽量远离，这是我爸活着的时候教我的。后来我一位广东朋友跟我说，这不是我爸一个人悟出来的，这是一种在他们那边流传很久的智慧，用广东话讲“费神教会你”。","text":"我经常能收到各种回复、提问、私信，有五种我不会回答，有这五种思维的人在现实生活中，我也会尽量远离，这是我爸活着的时候教我的。后来我一位广东朋友跟我说，这不是我爸一个人悟出来的，这是一种在他们那边流传很久的智慧，用广东话讲“费神教会你”。 给自己找借口 我收到很多人抱怨自己特别有天赋，被家庭环境所耽误，有些人的确是，这我不否认。但是如果你继续在抱怨的泥潭里，谁也帮不了你。你必须行动起来，改变这一切，大多数时候，尤其是你成年以后，很少有人能干涉你的生活，除了你自己，只有你自己同意。 有位姑娘抱怨“我视野不够是被家庭条件所限，父母没有钱让我环游世界，开拓眼界，所以我发展一直不好。我该怎么办？” 我爸妈也没给我钱让我环游世界去，不光如此我和妹妹还都是大学家里就不再给钱了，我和妹妹的大学假期都是在打工中度过的。可我妹妹在大学就帮助瑞士老师做过设计展。 开拓视野，真的只有环游世界这一个办法吗？你不思考总结，你环游了世界又怎么样。人生开拓视野读书、见人、行路、历事都可以，没钱环游世界，读书不就行了？没钱买书，大学图书馆又不收费，多读点书不就行了。为什么《认识商业》《沟通的艺术：看入人里，看出人外》《成功心理学：发现工作与生活的意义》在开头章节都通过总结、评测进行自我认知。我们必须了解自己，正视自己，学会承担责任，为自己的决定负责。你自己被家庭条件阻碍，视野不够，又有几个人的父母资助他们的孩子环游世界去了？你如果不正视自己之前的错误决策，继续为自己找借口，那就只能被困在原地。 大学没有利用好，那毕业后就好好努力呗！为自己找了借口，是舒服了，心理安慰了。潜意识，也会觉得反正不是我的错，那我就继续这样呗。这种思维方式何谈改变呀？！ 偷换概念 这种人更可怕，我们北京俗语说“干什么不吆喝什么”，“你说前门楼子，他说胯骨肘子”。 比如我们如果想吸粉成为大号，那就充分搜集信息，找到渠道、学习写作技巧。大家聊天也是围绕这个，可是善于偷换概念的人，他思维是跳跃的，他不围绕这个。 有个人问抱怨他文章浏览量低，我说你提高文章质量看的人就多了。他说你是红人，所以浏览量高。 他问你怎么能在短时间内让微信公众号粉丝多起来。我给了他几个平台，建议他写完文章都发发。他说“你怎么这么浮躁。” 有个姑娘单身，问我怎么能够建立亲密关系，我给她推荐《沟通的艺术：看入人里，看出人外》里关于亲密关系的章节。她说“跟男朋友耍心机，感情得不到好结果。”你跟你妈不讲沟通技巧，你妈都讨厌你，别说跟男朋友了。讲沟通技巧怎么就变成耍心机了？你跟他保持亲密关系，进行语言和非语言沟通就变成耍心机了？ 不要觉得这是个例，大家可以看看我浏览量几十万的《如何通过爱好赚钱》那篇文章，有几十个回复都是“做自己喜欢的事赚不到钱”，你赚不到钱是能力不行，跟做自己喜欢的事有什么关系？我一直做自己喜欢的事、特立独行的猫一直做自己喜欢的事，我们没有比别人赚钱少呀？赚钱这个事，跟你的能力、思维逻辑有直接关系，跟你喜欢不喜欢你的工作，没什么关系。三百六十行，行行出状元。《理解未来的7个原则：如何看到不可见，做到不可能》用整本书讲如何赚钱，明确提出周期性和线性的决定性作用：周期性变化告诉我们许多种不同的确定性。人类已经找出300个显著的周期，可以在某种程度上精确的预测未来。莎士比亚说：世间事，也有涨潮时节，及时把握，终可功成名就。 这种偷换概念的思维方式、沟通方式，是最好的拒绝别人分享的方式。因为沟通太累，大多数人都会闭嘴，有这种思维的人因为沟通效率差、做事效率低、抓不住重点会被处处受限。 看什么都是“鸡汤” 直接上个截图当例子，大家就明白了。 正常我们的逻辑，我会问怎么当上旅行体验师？这个工作前景如何？薪水如何？需要什么技能？工作内容是什么？ 逻辑思维的关键是“学会提问”，以开放式的心态，学会提问，你学习知识的途径就是一个立体的 ，随时随地都在接受信息，都在吸收知识，这也被称为“淘金式”思维。 相反，截图里的这个例子，是封闭式思维的学习方式。想有孩子，以后会做家长的人千万要注意，教育孩子一定要确认孩子的思维方式，在上学前，教会孩子开放式的思维方式，让孩子学会主动摄取知识，这样孩子学习轻松成绩好。封闭式学习思维的孩子尽管很用功，很努力成绩也总是不尽如人意，尤其是在中学以后，他们在学习上会更痛苦。 行动前，先给自己设置障碍，然后放弃 我经常会收到，问我如何写作的，我写过很多关于基础写作的文章，帮助他们。可是他们总会说“这太难了。” 还有人问我什么样的读书类文章会受欢迎，我说横向或者纵向阅读的主题书单，然后他说正常人根本就没有这种阅读量。然后我给他推荐《沟通圣经：听说读写全方位沟通技巧》第12章增进阅读速度，第13章提高阅读效率，然后他说“还得先学阅读，这工程太浩大了。” 有人说我不喜欢现在工作，怎么能找到喜欢的工作并且赚到钱。我的建议只需要评估自己、树立自己想要的目标、了解实现目标需要的技能、学习和提高自身能力、努力实现目标。他们通常会说“可是怎么开始呢？” 他们在行动前，就被自己抛出的问题吓到了，然后就没有然后了。他们会说自己拖延症、选择恐惧症。 通过片面信息、以点概面的否定 逻辑分析的首要条件是什么？“充分占有信息”。盲目的通过片面信息否定，有时候很可笑。 比如有人看了我的便签说“字如其人，看这字就是个生活混乱的男人。”难道我两个孩子都是你生的？你给喂的奶？ 我还收到过“第三行打了两个句号，作者是个浮躁的人。” 我鼓励大家无论男女都要经济独立，马上有人说“满身铜臭，就知道钱。” 我总是做工具书总结，有人说“你应该多读名著陶冶情操，就不会这么世俗了。”我上学的时候，一直担任班里的图书管理员，在初中、高中的假期协助图书馆老师完成了两个学校的图书馆电子化录入，就是把书读完，把主要内容录入到电脑里，方便检索。学校给学生选的书，大家可以想想算不算名著。我个人分析我世俗应该跟读不读名著没什么关系。 我分享理财攻略，马上有人说“这个人充满物欲。”你父母生病，住院办给你打电话跟你说“单间自费，1000元每天，您预定吗？”的时候，咱们可以再来聊这个话题。 写了这么多，希望能帮到大家。改变对话的方式，传递真正想说的信息，而不是表达攻击。 向鼹鼠的土豆","categories":[],"tags":[{"name":"乱七八糟","slug":"乱七八糟","permalink":"https://vlwq.github.io/tags/%E4%B9%B1%E4%B8%83%E5%85%AB%E7%B3%9F/"}]},{"title":"自我同一性","slug":"2015/20150808","date":"2016-08-01T02:36:00.000Z","updated":"2017-08-27T05:46:21.971Z","comments":true,"path":"2016/08/01/2015/20150808/","link":"","permalink":"https://vlwq.github.io/2016/08/01/2015/20150808/","excerpt":"谢谢邀请！也借此谈谈自我同一性的话题。 据记载，二十多岁的时候，教士马丁路德行为古怪。修道院集体唱经时，他会突然跌倒在地面，像是被某个人附体，用公牛般的声音咆哮：“这不是我！这不是我！” 马丁路德生于神圣罗马帝国艾斯莱本，父亲是当地的小矿主兼市议会议员。在严格和善意的父亲的要求下，他接受了当时优质的启蒙教育，进入爱尔福特大学学习哲学、法律。父亲原本期望他精通法律，在皇宫谋一个差事。然而，马丁路德却背离了家庭为他规划的合理蓝图，不顾父亲的雷霆大怒，进入修道院做了一个教士。 马丁路德成为教士的原因是，无论在家庭中还是在学校中，他越来越找不到自己的感觉。他陷入忧郁停滞的状态中，无法完成家庭赋予的学业、事业和婚姻的目标。此时此刻，一次电闪雷鸣的暴风雨，让他的生活彻底失去平衡。他产生极度的焦虑和不安。他感到自己的生活没有头绪，完全被困住一堵无形的墙中。他的面前只有一条路，就是抛弃原先的世俗目标，步入寻求救赎和永恒的宗教。于是，他成为了修道院中的“面壁者”，为了精神世界的出路苦苦求索。","text":"谢谢邀请！也借此谈谈自我同一性的话题。 据记载，二十多岁的时候，教士马丁路德行为古怪。修道院集体唱经时，他会突然跌倒在地面，像是被某个人附体，用公牛般的声音咆哮：“这不是我！这不是我！” 马丁路德生于神圣罗马帝国艾斯莱本，父亲是当地的小矿主兼市议会议员。在严格和善意的父亲的要求下，他接受了当时优质的启蒙教育，进入爱尔福特大学学习哲学、法律。父亲原本期望他精通法律，在皇宫谋一个差事。然而，马丁路德却背离了家庭为他规划的合理蓝图，不顾父亲的雷霆大怒，进入修道院做了一个教士。 马丁路德成为教士的原因是，无论在家庭中还是在学校中，他越来越找不到自己的感觉。他陷入忧郁停滞的状态中，无法完成家庭赋予的学业、事业和婚姻的目标。此时此刻，一次电闪雷鸣的暴风雨，让他的生活彻底失去平衡。他产生极度的焦虑和不安。他感到自己的生活没有头绪，完全被困住一堵无形的墙中。他的面前只有一条路，就是抛弃原先的世俗目标，步入寻求救赎和永恒的宗教。于是，他成为了修道院中的“面壁者”，为了精神世界的出路苦苦求索。 进入修道院后，宗教给了他暂时的平静和神圣感。但他很快发现，当时日益刻板腐化的教规，并不能给他渴望的出路。他很快又陷入忧郁和不安的情绪交替中。在修道院集体唱经时，他常有令人吃惊的行为，就像开头的场景一样。修道院上下私下议论着，认为魔鬼控制了马丁路德。不过，在心理学家埃里克森眼里，马丁路德正处在自我同一性危机。为了逃避家庭与社会的压力，他选择走进远离世俗的修道院，可教会陈腐的教规继续压迫着他。他的自我现在冲支离破碎，试图整合却面临极大的压力，自我同一性的冲突在他身上凸显。 什么是自我同一性？ 自我同一性要回答两个问题，一个是我是谁，另一个是我在世界上的位置是什么。前者指向自我的个体身份，后者指向自我的社会角色。埃里克森认为，自我同一性的丰富内涵中，包括个体对自己的核心认识，对自我人生的方向感；包括对过去经历的总结，对未来道路的展望；包括个体看待自我的方式，对家庭社会期待的认识，两者要维持有意义的平衡。而两者的失衡和冲突，就会导致同一性危机。身处社会世俗期待和精神生活探索的尖锐冲突中，确立自我同一性成了马丁路德艰难的任务。 自我同一性不是新鲜的概念。18世纪英国经验主义哲学家洛克，曾郑重讨论过这个问题。在《人类理智研究》中，他讨论了人格同一性。他认为，人格同一性，就是自我同一性。我们的感觉想法无时不在变化，但我们依旧能感到自我的存在，自我意识保持着相当的稳定。而维系人格同一性（即自我同一性）的方式，来自我们对过去的记忆。我们通过过去的记忆认识过去的自己，同时把过去和现在的自己联系起来。于是，记忆就成了自我同一性的关键。我们要理解自我同一性，就要从分析记忆叙述开始。 现在，心理学家分析自我同一性，也从记忆叙述的一致性着手。一致的记忆叙述，除了记忆事件的明确时间，还有特定的因果关系，和具体的主题。这构成记忆叙述的因果一致性和主题一致性，因果一致性是指，记忆叙述中怎么解释生活事件如何发生，如何发展，如何转变，如何解决，自己又从中获得什么收获和意义。主题一致性是指，记忆叙述中怎么解释生活各阶段背后的统一主题、价值观和法则，自己如何借此告诉别人我是谁，我的生活是什么样的。因果一致性和主题一致性之外，记忆叙述还遵循所在文化的特定目标，告诉我们该做什么，朝那些方向努力。 如果记忆叙述在因果一致性、主题一致性上出现问题，或在文化目标方面严重冲突，记忆叙述就缺乏一致性，自我同一性还未完成。自我同一未完成的外在表现，是丰富生动的情绪体验。同一性冲突最尖锐的时候，就是强烈的焦虑情绪。就像马丁路德怪异行为的背后，是同一性危机下的焦虑情绪。他们的记忆叙述是未完成的，记忆是支离破碎的碎片，彼此缺少联系、模糊、难以理解。他们的内部体验也是碎片化的，描述体验时经常会停顿中断。对于生活事件的细节和原因，他们也会困惑、无法确定。他们试图理解，生活经历的原因和意义，却又还没找到出路。 如何完成自我同一性，形成整合完整的自我？这个问题，没有人能给你明确的指南。因为个人的记忆叙述，只有自己才能建构和处理。其实，人一生都在发展自己的记忆叙述，试图构建自己的生命故事。在自己的生命故事中，有自我主观叙述的自我建构，也有想象的未来蓝图。生命故事不是编年史，更像是一个个人神话。神话里有人物、情节、主题、场景，里面的英雄就是主人公自己。另外，生命故事不是简单的记忆总结，也是我们现在和未来的行动指南。这意味着，我们的生命故事，也要接受实践的检验，与社会环境互动协调。 马丁路德的自我同一性，也是这样完成的。在世俗要求下，他找不到自我的目标，在教会生活中，他也未完成自我的整合。他日夜忏悔渴望得到上帝的怜悯，但始终无法得到心灵的安慰。在孤独的苦思冥想中，他最后找到的自我出路，就是抛开教会的中介，直接与上帝沟通。他向公众宣称，上帝的永久正义是怜悯的赠礼，只要人相信耶稣基督，他就可以获得这份赠礼，信仰与苦修是救赎的要义，而教会本身是无能无用的。这也意味他反抗教会陈规，开始了宗教改革运动。这样，马丁路德解决同一性危机的方式，也引发一场深远重大的社会变革。 类似的同一性危机，在中国背景下也有。那就是王阳明的心学运动。在读书中举的世俗功利面前，年轻的王阳明却萌生做圣贤的愿望。这意味他想从社会期待之外，找一条遵从自我的个性道路。他从朱子学中间寻找圣贤之道。王阳明曾经花大力气，昼夜不免试图参悟竹子之理，让自己和竹林世界融为一体。然而他失败了，生了一场大病。这场大病也是精神危机，告诫他自我成圣道路走不通。病愈之后，他暂时放弃圣贤的理想，循规蹈矩科举做官。和马丁路德相反，王阳明顺从世俗目标，悬置了个人志向。 但朝廷的昏暗，让他的官路坎坷。王阳明因为得罪刘谨，被贬官流放贵州。现在，他又面临相同的境地，身处偏远闭塞的山区，周围是冰冷的洞穴，社会期待已经崩塌，自我理想充满困惑，他又陷入自我的冲突中。思索圣人自处之道，不再是年少曾经的理想，而是严酷环境的应对手段。这个时候他日夜思索，昼夜不宁，终于在半睡半醒时，听到自己的心声：圣人之道，吾性自足，何须外求（更详细描述可看什么叫做内心强大？怎样变成一个内心强大的人？ - 罗林的回答）。于是轰轰烈烈的心学运动，就从认识自己的本心开始，冲击当时僵化教条的朱子学，成为影响整个东亚的社会思潮。 马丁路德和王阳明，两人自我同一性的整合，是在巨大压力下，表现出极强的自我韧性。当然，不是所有人的自我同一性整合，都像他们两人那样曲折重大。他们面临的压力，表现出的韧性，也不是一般人能承受和实施的。来访者自我同一性的探索，也可通过心理咨询的协助。从心理咨询师的角度，来访者的自我同一性是自我探索，自发产生的。心理咨询师要做的，就是在他们探索发展的过程中，给予足够的支持和反馈。这些支持和反馈包括，澄清来访者探索的目标，理解和匹配来访者的需求，与来访者保持合作包容的关系，保持他们探索过程的延续稳定性。 自我同一性探索的过程，就好比化蛹为蝶的过程。咨询师要扮演的角色，就像幼虫蜕变时的茧壳，在他们心灵最脆弱的时候给予安全的环境，让它一点点分解、变形，孕育出更美丽的生命。","categories":[],"tags":[{"name":"乱七八糟","slug":"乱七八糟","permalink":"https://vlwq.github.io/tags/%E4%B9%B1%E4%B8%83%E5%85%AB%E7%B3%9F/"}]},{"title":"25岁前你必须要做完的7件事","slug":"2016/20160822","date":"2016-07-25T02:36:00.000Z","updated":"2017-08-27T05:50:41.412Z","comments":true,"path":"2016/07/25/2016/20160822/","link":"","permalink":"https://vlwq.github.io/2016/07/25/2016/20160822/","excerpt":"人生中有很多要做的事情，也一定会有更多的缺憾，无论你怎么拼了命去做，都会留下遗憾。 我知道你我都会活得没那么容易，我愿你是活得潇洒精彩的人，别沦落到中年时热血已凉，回忆年少轻狂的梦，没一件做成，心酸又心凉。 趁你在还可以犯错的年纪，趁你在犯错还可以挽回的岁月，趁你还没有太多牵挂时，做完这7件事。","text":"人生中有很多要做的事情，也一定会有更多的缺憾，无论你怎么拼了命去做，都会留下遗憾。 我知道你我都会活得没那么容易，我愿你是活得潇洒精彩的人，别沦落到中年时热血已凉，回忆年少轻狂的梦，没一件做成，心酸又心凉。 趁你在还可以犯错的年纪，趁你在犯错还可以挽回的岁月，趁你还没有太多牵挂时，做完这7件事。 25岁前你必须要做完的7件事 我不愿你有一场不管个人安危说走就走的旅行，也不要你接受什么大学没挂过科没谈过恋爱就不完整这种烂鸡汤，更不希望你还没拥有过人的实力前就学名人们退学。 人生中有很多要做的事情，也一定会有更多的缺憾，无论你怎么拼了命去做，都会留下遗憾。 我知道你我都会活得没那么容易，我愿你是活得潇洒精彩的人，别沦落到中年时热血已凉，回忆年少轻狂的梦，没一件做成，心酸又心凉。 趁你在还可以犯错的年纪，趁你在犯错还可以挽回的岁月，趁你还没有太多牵挂时，做完这7件事。 过了25岁，你的人生不会再是你一个人的了。 好自为之。 第一件事：要有个一辈子都喜欢的爱好人可以为很多东西活，为名利活，为自由活，为自己活，为别人活。 在我大学快毕业时，我终于醒悟：无论哪一种活法，都不可能真正自由。 每一种活法，都有它迷人的地方，更有它无奈的地方。无论你选择了哪一种活法，你都有一个一辈子都喜欢的爱好，它不一定给你带来名，带来利，它只会在你疲惫不堪时，做起它时，你会笑，你也会哭。 笑得开心，哭得解忧。 你要有这样的爱好。 第二件事：有一份足够养活你的工作过了25岁，你不可以再跑到父母怀里又哭又闹了，你更应该去照顾他们。 你的人生中当然会遇到很多很多愿意照顾你的人，可是啊，你也要学会照顾别人，照顾自己。 我知道你想任性，任性之前先让自己有任性的资本与能力吧。有一份足够养活你的工作，并且是你喜欢的事情。 不要和我说没办法做自己喜欢的事情，要知道，只有做自己喜欢的事情才更有可能获得更大收益。 这一份让你能够想吃什么就吃什么想去哪里就去哪里的工作，是你任性的底气，最最基础最最普通的底气。 第三件事：有一个可能要花几十年才能完成的目标当你有了可以爱一辈子的爱好，和一份让你足够养活自己的工作后，你不可以就此满足了。 要知道，人总是在满足中变得平庸的，你不可以只待在舒适区。 你要明白，呼唤你每早起床的最大动力是什么，不要告诉我是为了赚吃饭租房的钱，那不该是你人生的最后归宿。 你要有一个可能要花几十年才能完成的目标，哪怕它看起来有多疯狂，你也要不断朝着它迈进，不管你最后有没有成功，这个目标都是你在25岁前要找到的。 就像你的梦想是触及星辰，我们都明白，穷极一生你也摸不到它，可你为了摸到它，站在了少人可及的最高峰。 第四件事 完成一件你中学时期的梦想很多人说：莫欺少年穷。 你有多少少年时的梦，都随着年纪增长搁置到一旁了？你是不是偶尔想起时，还会自嘲，摇摇头不再去想。 你对得起年少的你吗？那时候的梦，真的有那么难实现吗？ 去做吧，中学时期的你或许有100个梦，碎了99个梦又如何，在你还没有真正老去的年纪，就不要学着真正老去的人倚老卖老，去做，去做，去做啊。 当你完成了一件少年时的梦后，你永远也不会老去。 第五件事：看完100本好书在日渐浮躁的如今，我仍想将生活过成诗。 无视那群鼓吹“读书无用论”的愤青吧，没用的人做什么都无用，强悍的人喝鸡汤都能成就一番事业，读书从来不是让你功成名就，读书是教会你如何更轻松更有趣地活。 绝大多数人的人生，活得都过于疲惫，过于无趣了。 不要带有功利性去读书，更不要读那些毫无意义的书，在25岁前，慢慢读，认真读，读100本真正经典的书。 那时候的你，会更知道你为什么活。 第六件事：独自走过10座城市你之所以活得狭隘无知，是因为你不知道世界是什么样子的。 哪怕你活在信息爆炸的互联网时代，你在书上了解的，你在视频里看见的，你听阅历丰富人说的，都不代表你真的明白世界上其他地方的人的生活。 你不会知道千里之外的城市街头会有怎样的风景，更不会知道某个咖啡屋里正认真画图的女孩也许和你志同道合，你永远都不可能知道，你为何和他们不同，你为何和他们相同，除非，你走出去。 不要穷游，我从来不赞成所谓的穷游。 第七件事：不要因为寂寞恋爱，遇上正确的人就立刻爱爱情与婚姻或许是生命中的必需品，但不是作业题，更不可以着急。 在25岁前，不要因为寂寞谈恋爱，你会浪费了自己的感情，糟蹋了别人的时间，最好的感情本应该留给最好的人。 如果没有遇见合适的人，不要因为身边的人怂恿，去谈一场无疾而终甚至因不爱也生恨的恋情，太不值得。 如果遇见正确的人，不要想以后，不要考虑现实，人生中已有无数错过，你真甘心难得心动的人在你面前远去？ 哪怕最后的结果不尽人意，你也要奋不顾身去爱这个来之不易的人。 说不定，到最后，她会是陪你走过一生的人。 25岁前，你要做完这7件事。 有些事，你不做，真的来不及了，你的青春，比昙花都还要短暂。","categories":[],"tags":[{"name":"乱七八糟","slug":"乱七八糟","permalink":"https://vlwq.github.io/tags/%E4%B9%B1%E4%B8%83%E5%85%AB%E7%B3%9F/"}]},{"title":"房价","slug":"2016/20160623","date":"2016-06-23T02:36:00.000Z","updated":"2017-08-27T05:55:14.376Z","comments":true,"path":"2016/06/23/2016/20160623/","link":"","permalink":"https://vlwq.github.io/2016/06/23/2016/20160623/","excerpt":"谢邀，先说结论，这个问题从头到尾没有一个字是对的…… 首先我们要定义“涨成这样”究竟是什么样，全国各地房价收入比差异很大，房价的涨幅特别是2008年后的涨幅差异更大，不能一概而论。在我看来，当地城镇年平均收入与住宅每平米单价的比值超过5的就不必惊呼“涨成这样”，达到8-10的就更谈不上高价。在我国这个租房市场不健全、传统上缺乏长期租房居住观念的国家，房产的需求端比国外更凶猛是必然的，那么如果一个平均水平收入的居民家庭能够在工作的5-10年内攒够一套刚性需求型住房（70至90平）的首付，就是很正常的一件事情。如果当地人口没有明显的流出趋势，这个价格就有很强的支撑基础。所以“涨成这样”这个说法就不存在……","text":"谢邀，先说结论，这个问题从头到尾没有一个字是对的…… 首先我们要定义“涨成这样”究竟是什么样，全国各地房价收入比差异很大，房价的涨幅特别是2008年后的涨幅差异更大，不能一概而论。在我看来，当地城镇年平均收入与住宅每平米单价的比值超过5的就不必惊呼“涨成这样”，达到8-10的就更谈不上高价。在我国这个租房市场不健全、传统上缺乏长期租房居住观念的国家，房产的需求端比国外更凶猛是必然的，那么如果一个平均水平收入的居民家庭能够在工作的5-10年内攒够一套刚性需求型住房（70至90平）的首付，就是很正常的一件事情。如果当地人口没有明显的流出趋势，这个价格就有很强的支撑基础。所以“涨成这样”这个说法就不存在…… 其次，中国的住房上面绑定了以户口为核心的一系列附加品，这些东西的价格跟住房本身的价格一样，同样是越发达的地区越供不应求、越昂贵，从而产生了一个乘数效应，即经济发展水平越高的地区、在地区内地段越好的房子，其价格一旦进入上涨通道，上涨速度将大大超越一般房产的速度。事实上，居民平均收入与住房均价之比小于5，甚至只有1-3的地方，基本上都是经济发达的一二线城市，也就是乘数效果最明显的地方。北京西城区的一套旧房子的一堆钢筋水泥当然不值一平米十几万、二十万，但是这套房子上面附属的重点小学的入学资格，如果放到市场上，你觉得值多少钱？学区房的制度其实是个掩耳盗铃的机制，不过是把西方国家优质教育资源（多数为私立学校）的价格，前置到了买房阶段，避免了“公立学校收费高”的尴尬。因为我国的私立学校其实没有完全放开，优质教育资源其实还没有实现市场化的自由配置，大部分还留在公立体系内，又不足以给所有人享受，事实上存在一个“公立学校教育资源不得不按供求关系定价分配”的问题，所以就走到了这一步。一味地脱离这个大背景来指责发达地区住房价格虚高、泡沫大，我觉得也是不合理的。“买房其实是买住房+配套资源”的这个逻辑如果建立起来，你会觉得其实这个价格的所谓“泡沫”下面，支撑基础还是很坚固的。哪天配套资源解绑了，房价肯定会降下来不少，但我猜打算在北京定居的群众嘴里说的“居有定所”表面上没教育什么事儿，但实际上是有这层意思的，那其实解绑不解绑，总花费是下不来的……所以价格高未必就全是炒起来的泡沫。 第三，国内金融市场发展不健全、个人投资选择不多，个人财富出国受限等因素，也对房价的高涨有促进作用，没得选嘛。 综上，一二线城市及部分三线城市的房价这么高是不是问题？是。畸形不畸形？畸形。但这是个结构性（牵扯到社会文化、政治制度和财政制度）的问题，与历史上多次发生的证券市场资产泡沫是有本质差别的（完全脱离经济社会发展基本情况的涨跌）。只要房价下面的经济结构不倒，单从房价上面去预测经济危机是没有意义的。经济危机跟少数地区的二手房价格高不高、涨不涨，没有必然联系，这个问题就问错了。 再扯四点闲篇儿就是： 1、真正关心一二线城市以及部分三线城市房价的人，毕竟是少数（不要拿这些城市的常住居民数字来吓唬人，有购房决心或手握住房的人，才是关心房价的人），不要把一个少数人的问题放大成全国型的问题，一个人干一年挣不出3平米心仪的房产的事情，不是全国的普遍情况，不要把自己看得太高，你对全国经济没这么大影响。 2、企业投资房产是受限的，很多企业玩的也不是净利润而是现金流，就算玩净利润，做账把净利润做低也不是什么匪夷所思的事情，没必要津津乐道于多少上市公司利润增幅比不上北上房产，那还有房产涨幅比不上上市公司利润增幅的城市呢，你们查查我大呼和浩特、大鄂尔多斯这几年房价涨没涨……这俩地方即使不算发达地区，大概也不算穷的当裤子的地方。 3、关于拆迁户和收租食利阶层，不谈一夜暴富的运气也是人生的一部分，手握多套房产、资产几千万甚至上亿，还收着一年1%-2%的房租过日子，这种大爷大妈是为经济社会稳定做出了巨大贡献的好吧……你们还嫌弃人家文化低，文化高早就把这些资产玩出花儿来了，大概也轮不到各位北漂海漂租着住。恰恰是他们文化水平低，才不得不指着资产收益率如此之低的房租过日子，没有搞出其他大新闻来。你们呀，还是把自己太当回事了，凡是不是按照自己的人生轨迹走上康庄大道的，都是食利阶层，都要打倒，怎么不上天呢…… 4、越发达的城市，新盘数量和交易量越有限，越是二手房市场活跃，你说这种市场的房价对水泥、钢铁等基础材料有多大的牵连效应，我觉得不存在的……倒是银行信贷结构上，确实是个大风险，但跟各位想的不一样，如果整顿银行信贷，调整业务结构，避免对房市依赖度过高，那一定是打击刚需，因为如果不考虑违规民间借贷，光是征信系统查得到的借贷行为，杠杆率最高、偿债能力最差的买房居民，恰恰就是刚需……而2016年10月份开始的调控，至少北京，基本上就是在抽刚需的脸……这好像又不符合各位的利益了…… 创建于 2017-03-10作者保留权利","categories":[],"tags":[{"name":"乱七八糟","slug":"乱七八糟","permalink":"https://vlwq.github.io/tags/%E4%B9%B1%E4%B8%83%E5%85%AB%E7%B3%9F/"}]},{"title":"这个世界上根本没有、也不可能有什么“一定能XX”的模版","slug":"2016/20160602","date":"2016-06-02T02:36:00.000Z","updated":"2017-08-27T05:52:15.817Z","comments":true,"path":"2016/06/02/2016/20160602/","link":"","permalink":"https://vlwq.github.io/2016/06/02/2016/20160602/","excerpt":"一切所谓的提点和建议无论如何都会有强烈的个人经验主义，要强调的是，这个世界上根本没有、也不可能有什么“一定能成功”的模版或者路径，如果真的有，那岂不是所有人都“成功”了，所以以下提到的建议，仅供参考，饭还得自己一口一口吃，路还得自己一步一步走。答主在今天已经差不多毕业10年，开了自己的公司，做互联网市场运营教学，以下列出来10点有必要一说的地方，希望有所帮助。","text":"一切所谓的提点和建议无论如何都会有强烈的个人经验主义，要强调的是，这个世界上根本没有、也不可能有什么“一定能成功”的模版或者路径，如果真的有，那岂不是所有人都“成功”了，所以以下提到的建议，仅供参考，饭还得自己一口一口吃，路还得自己一步一步走。答主在今天已经差不多毕业10年，开了自己的公司，做互联网市场运营教学，以下列出来10点有必要一说的地方，希望有所帮助。 1.动手做，执行力 有人会问这样的问题，“如何才能很好的规划人生”，这种问题背后是一个脆弱的人在寻求安慰剂。真实情况是，刚刚接触社会的大学生，往往并没有能力去制定合理有效的计划。持续在进步的人经历相同的过程：逐步熟悉、小心摸索、失败、再失败，认真反思、卷土重来，直至成功。在最初我们对任务连基本的认知都没有的时候，制定出来的计划很可能是空谈，办法就是动手做，只要动手做，就一定会越到困难，遇到困难就是真正的进步，没遇到困难不叫进步，叫做原地打转。只要动手，就会有反馈，有反馈就有进步。 2.不要拿“要深造”、学历来逃避现实了 我非常认可人要学习，要深造。问题是：深造和深造是不一样的。如果你在工作和生活中，你清楚的知道要用到什么技能，然后去主动学习，这种学习意识非常可贵；另一边，如果你根本不知道为什么要去学，就去学习，原因只可能是：你根本不思考，思维被体制化了，或者你在逃避现实。我身边有这样的例子，名牌大学，找不到工作，很焦虑。人一焦虑就要做些事情缓解焦虑，于是比大自然还自然的，认为自己需要“深造”，这样做根本上，是在堂而皇之的延缓自己接触社会的时间线，强行把死刑改成死缓。 3.选行业超级重要，大学专业和工作职位没有直接关系 从大学走进社会，就像从安全的城堡里走向战场。步入社会选择职业对于个人选择来说，是一个分界点。在大学之前，包括选择大学专业，都是在靠家庭安排或脑补自己的职业发展来做选择。步入社会之后，你开始真正自己来做选择。从来都没有一个必然的路径说，你大学学的化学，进入社会就必须天天以做化学实验为职业。选行业、选职位要认真思考，要做有理有据的分析，要结合自己的兴趣和擅长点，才能做的好，做的持久。我们网址的同学里，有一个同学是化学硕士转行到新媒体运营的，在今天她已经从月薪3.5k，升至月薪8k，她的转行故事在此： 互联网0经验小白，成功拿下月薪8K新媒体运营 另外，关于如何选行业和职位，可以参考我的另一个回答，比较清楚了对行业进行分类，对职位进行分类的思维逻辑 大学生如何在毕业前准备好未来的职业发展方向？ - 踏浪100张君的回答 - 知乎 4.从现在开始，做对个人进步有反馈的事情 反馈也可以称之为结果，你做任何事情都得有个结果。没有结果就没有反馈，没有反馈就没有进步。还有，我从来都不相信坚持这两个字，如果做一个事情，没结果，为什么我还做呢。当然还要强调的是，如果做的事情是公益、是有社会价值的事情，不求结果我也会做，不能以偏概全的说只要没结果就不做，这样就太功利了。这里提到的反馈，再规范一下定义，应该说是，对于个人进步而言，需要有反馈。如果你是一个做内容、做运营的人，你写了一篇文章，你需要知道这篇文章可以给你的网站带来多少引流，而不是为了写文章而写。当数据反馈变多的时候，你知道什么类型的文章引流效果最好，这样你就会依据数据调整你的工作，你就会进步。 5.不要做螺丝钉工作，你会死 螺丝钉工作简单说就是那种每天重复体力劳动的工作，没有任何歧视的意思，举例公交售票员，高速路收费员，工厂加工一个固定的零件，这些都是螺丝钉工作，螺丝钉意味着，你可以随时被替代。做螺丝钉工作，你干1个月和干20年，在知识增长上没有任何的区别。更要命的问题是你的头脑会僵化，你就会沮丧，在这样一个很实际的社会，你离期望越远，你就会越沮丧。就会进入一个负能量循环。要知道收入水平和知识水平是成正比的。当然仍然不能以偏概全，没人说一定就不能做螺丝钉，当然有可能，有人就很适合做螺丝钉，也并不希望有多高的个人发展，一样可以过得很幸福。 6.在一开始就养成在自己身上找问题的好习惯 很简单，在自己身上找问题，是在找解决方法，看中的是个人的进步；在别人身上找问题，是在找借口。在自己身上找问题，找到的是事情发生的原理，你看到的是“为什么会这样”，你有了自己的思考，所以下次会避免重复问题的发生，这时候你就在进步。在别人身上找问题，找到的是事情发生的部分外因，你把所有问题推给了别人，看似问题解决了，实际上问题还存在。你不仅不会进步，你还很可能会变成一个怨天尤人的无能者。 7.逃离舒适圈，你要习惯遇到挫折 舒适圈指的是你熟悉的环境。在一个环境呆久了，就会对这个环境产生习惯，在习惯的环境人人会放松。而面临新的环境和工作人会紧张。所以人会躲避新环境，目的是躲避恐惧和不安。真实情况是，只要你想进步，你就一定会遇到挫折，因为你不可能对新事物做“准备”。因为经过准备的就不再是问题，而真正遇到的问题个个都是之前不曾想象抑或无法想象，接受惩罚往往是积累经验的起点。你要做的事情就是习惯遇到挫折，逃离舒适圈。 8.如果你误入是非之地，马上离开 一个人的能量是有限的，为什么公司会有是非，因为人的能量发泄不出去，发泄不出去人就会找事做，就会搞公司政治。所以一个公司是否快速向前，看这个公司是否有办公室政治，也能看出来。相对的，如果这家公司是一个做事的公司，工作已经把每个人的精力耗完了，哪里有人有空搞什么办公室政治。如果你在是非之地，马上走。 9.设置个人远的目标，但是要脚踏实地 你现在每一步的努力，都是在为未来做努力，所以不要关注现在的薪水而已，你要关注的是知识的积累和增长。何况天朝这个通货膨胀和物价增长的速度，你在乎那几百几千块钱有个毛用。多想想自己40岁想过着什么样的生活，为了达到这个生活状态，你思考需要做哪些事，需要学哪些技能。如果你的目标是学习，你的财富会随之而来；反之，你的目标很短，你眼里看的是公司能不能给你涨薪1000块，这样你的眼光会放在涨薪这件事本身上，你就不会进步，代替学习的会是无所事事的度过一天又一天，你只会很费解，为什么你和“很厉害”的人差距这么大。 10.你的感情生活超级重要 上面聊过了每个人的精力都是有限的，如果说可能存在的办公室政治会耗费精力，那更可能耗费精力的就是情感问题。如果你的另一半，每天你们见面都是闷闷不乐，见面就是负能量，各种相互不理解，甭管是吵架还是冷战事实上都巨耗费精力，两个人都笼罩在一种莫名的烦恼之中，势必会影响到正常的工作，在这样的牵绊中一个人根本没精力学习和进步。反过来你的另一半超好，你见到她完全没压力，见面就高兴，正能量满满，你人少还多了非常正向的目标，你有爱的人去努力去奋斗，你在工作中的进步速度会加倍，再苦再累你愿意，因为你有那么好的另一半。这就是区别。 最后再强调的一次：一切所谓的提点和建议无论如何都会有强烈的个人经验主义。大道理听了都觉得对，执行起来又是另一回事。印在自己心里并实际行动反馈回结果的，才是你的。","categories":[],"tags":[{"name":"乱七八糟","slug":"乱七八糟","permalink":"https://vlwq.github.io/tags/%E4%B9%B1%E4%B8%83%E5%85%AB%E7%B3%9F/"}]},{"title":"执行力","slug":"2016/20160304","date":"2016-03-04T02:36:00.000Z","updated":"2017-08-27T05:52:15.833Z","comments":true,"path":"2016/03/04/2016/20160304/","link":"","permalink":"https://vlwq.github.io/2016/03/04/2016/20160304/","excerpt":"前几天和一位初中好友一起吃饭，我和他的友谊，从那个时候开始，至今都没有中断过，经常出来喝喝酒，拉拉家常，谈谈人生理想。 吃饭的期间，他跟我说，再过一个月，自己就要辞职出来创业了。 我第一次听到这个消息时，说实话，还是挺惊讶的，毕竟他才刚刚毕业两年多，按照常理来说，现在工作应该才步入正轨，怎么就要出来创业了呢？ 那天和他聊完，再到后来和一些跑得比较快的同龄人聊过之后，我才发现，毕业三年，混得好的同学，其实已经和其他的人，拉开了越来越大的差距。 有的月薪过两万，有的出来创业，有的组建了自己的小团队，各有各的精彩。 其实我关心的不是差距的大小，而是那些跑得快的人，他们究竟是怎么做到的？","text":"前几天和一位初中好友一起吃饭，我和他的友谊，从那个时候开始，至今都没有中断过，经常出来喝喝酒，拉拉家常，谈谈人生理想。 吃饭的期间，他跟我说，再过一个月，自己就要辞职出来创业了。 我第一次听到这个消息时，说实话，还是挺惊讶的，毕竟他才刚刚毕业两年多，按照常理来说，现在工作应该才步入正轨，怎么就要出来创业了呢？ 那天和他聊完，再到后来和一些跑得比较快的同龄人聊过之后，我才发现，毕业三年，混得好的同学，其实已经和其他的人，拉开了越来越大的差距。 有的月薪过两万，有的出来创业，有的组建了自己的小团队，各有各的精彩。 其实我关心的不是差距的大小，而是那些跑得快的人，他们究竟是怎么做到的？ 1， 行业和平台很重要。 不知道是谁曾经说过：站在风口上，猪都能飞起来，这里的风口，你可以理解为平台的意思。 前不久咪蒙助理月薪过五万的消息，刷爆了朋友圈，我一位做传统行业的朋友，看得十分眼红，直呼凭什么。 同样都是在打工，同样都是在付出劳动，同样都是刚出社会不久，为什么有人就可以做到日入2千，有些人拼死拼活，每个月都还要掐着手指来过日子？ 说到底，都是行业和平台的不同，造就了这样的一种局面。 试想一下，同样都是一个专业出来的大学生，一个毕业之后去了传统的商业地产行业，一个毕业之后去了腾讯或者华为，两三年后，哪个同学的发展会更好一点？ 我想，你应该能猜出来是哪个。 因为资本，人才，信息不断地往新兴的行业靠拢，导致这些行业的发展极为快速，而传统行业，不仅有时候千年不变，上升通道极为狭窄，而且所属的行业，还不断下滑萎缩。 那些毕业两三年，就实现自己巨大跨越的同学，无不是依托于高速发展的行业和平台：电商，移动互联网，游戏，金融，等等。 在这些行业里，只要你足够努力，就能获得超额的回报，而在传统的行业里，无论你怎么努力，怎么奋斗，都不可能与整体衰败的外部环境相抗衡。 和我经常来往的初中同学，大学学的是食品检测，毕业之后，经过仔细地分析，认为电商会持续不断地发展，于是全身心投入到电商公司里面去，几乎可以说是All—In的状态，经过这两三年的努力和积累，不仅实现了月入过5万，还有底气出来创业单干。 这是很多人在传统行业里，想都不敢去想的事情。 2， 努力，努力，再努力。 其实我和他在初中认识的时候，他的身上，就有一种韧劲。 每次考试，都会拼尽全力，就为了多拿多几分；每次背单词，都会比设定的目标，多背几个；每次做数学习题，不单单只要求自己掌握一种解题方法，而且还不断地向别人，老师请教其他的解题思路。 这样的一种努力和勤奋，一直延续到了大学，紧接着跟随他步入了职场。 有人常会说：努力会成为一种习惯。 这种从小养成的努力状态，可以让你节省很多的意志力资源。 因为每次当你需要更加努力地投入到工作当中去的时候，你会自然而然地去用力，去沉浸其中，而不是次次都还没有开始做的时候，就表示自己做不到，不想做，或者干脆逃避。 像我的初中同学，从一开始，就保持着努力的习惯，所以，对他来说，多干一点活，多做一点事情，多学一点知识，这些所谓的“超额”，都是理所当然的，都是名正言顺的，都是可以理解和接受的。 反观有些人，在还没有努力的时候，就觉得自己已经用尽全力的样子，为公司，为部门多做一点事情，就觉得整个人被欺负了一样，业余的时候，根本就不想怎么去提高自己的技能，也不琢磨如何才能变得更好，更加优秀。 想要得到什么，你就得拿东西出来置换，这个道理，是亘古不变的。 如果你甘于平庸，那就不要做什么英雄梦，如果你总觉得自己的理想还有抱负没有实现，那就打起精神来，穿上铠甲，去战斗，去屠龙。 不要每次都说自己这样不行，那样不想要，试试转变下自己的思维方式，面对美好的事物时，多问问自己： 我怎么样才能得到它？ 每一次的内心消极对话，无疑都是在慢性自杀，而只有正视自己内心的声音和力量，才能激励你不断地往前走。 一个是让你后退不止，一个是让你不断前行，你应该知道怎么做选择。 3， 不是光想不做，而是有强大的执行力。 如果我现在跟你讲一个非常好的idea，大概有50%的人听进去了，在这50%的人里面，有40%的人有去做思考，在这40%的人里面，只有不到10%的人会去执行。 实际上，这个世界从来不缺乏好的想法，只是大道理谁都懂，但却没有人真的想要去执行。 谁都知道早起早睡身体好，谁都知道坚持健身，可以让你保持身体匀称协调，谁都知道无论多忙，都要挤出时间来进行自我增值和提升。 但有谁真正去做了？又有谁真正做了，还不间断地坚持了下去？ 每个人都想按照自己最为舒服的状态来过日子，谁都不想逼着自己去走出自己的舒适圈，所以，在面对外部环境带来的巨大不安全感时，很多人宁愿选择口头上的宣誓，也不愿意动起身体，去立刻执行。 口头上的宣誓，可以让自己的内心，得到抚慰，可以自己给自己营造一种假象：“我做到了”，而行动呢，却带有更大的不确定性，因为你不知道现在行动了，究竟能不能给你带来收益，于是看似理想的选择，其实让你次次成为思想上的巨人，行动上的侏儒。 我的初中同学，有一次在和部门经理开会的时候，因为有一份紧急的文件需要去处理，但部门经理又分身乏术，忙不过来，这时候，我同学主动请缨，接下了这个任务，连夜加班将这份文件给出色地完成好。 大部分人，都是在晚上睡觉前，信誓旦旦地对自己说： 我要这个，我要那个。 明天早上起来，依旧是按照自己的老路走到底，你叫他去做，去改变，去追求梦想，比登天还难。 想了不做，等于白想。 希望对你们有所启发。 感谢阅读。","categories":[],"tags":[{"name":"乱七八糟","slug":"乱七八糟","permalink":"https://vlwq.github.io/tags/%E4%B9%B1%E4%B8%83%E5%85%AB%E7%B3%9F/"}]},{"title":"中国合伙人","slug":"2016/20160303","date":"2016-03-03T02:36:00.000Z","updated":"2017-08-27T05:52:15.902Z","comments":true,"path":"2016/03/03/2016/20160303/","link":"","permalink":"https://vlwq.github.io/2016/03/03/2016/20160303/","excerpt":"中国合伙人有一个被删减的片段，我想很多人是知道的，那就是黄晓明供了那么多年的女神，出国之后被一个美国屌丝出租车司机随便带到野外去就给日了。 《中国合伙人》被删减片段 女神与老外滚草地 删这段的理由可以想见，黄暴而且丢脸，但是你们造吗？这样的事才不是什么女方碧池的小概率事件，更不是导演神经病乱加的，这种事，很真实，而且到处都在发生。 有一对外国屌丝，屌丝到名字都很大街，一个大卫一个阿雷克斯，这俩人辞职前从未坐过飞机，跳到亚洲之后，以穷逼屌丝无业之身，在亚洲旅行把妹，拍成了纪录片，整整十六个月，推人无数。 撩妹狂魔！老外花16个月亚洲猎艳竟还拍了纪录片","text":"中国合伙人有一个被删减的片段，我想很多人是知道的，那就是黄晓明供了那么多年的女神，出国之后被一个美国屌丝出租车司机随便带到野外去就给日了。 《中国合伙人》被删减片段 女神与老外滚草地 删这段的理由可以想见，黄暴而且丢脸，但是你们造吗？这样的事才不是什么女方碧池的小概率事件，更不是导演神经病乱加的，这种事，很真实，而且到处都在发生。 有一对外国屌丝，屌丝到名字都很大街，一个大卫一个阿雷克斯，这俩人辞职前从未坐过飞机，跳到亚洲之后，以穷逼屌丝无业之身，在亚洲旅行把妹，拍成了纪录片，整整十六个月，推人无数。 撩妹狂魔！老外花16个月亚洲猎艳竟还拍了纪录片 后来他去教人怎么泡妞，讲各国女人讲了一堆，然后讲到亚洲女性的时候，他是这么说的：对亚洲女人，你不需要什么技巧，只需要把她的头摁在JB上就可以了。 而事实上他就是这么做的。 他们两个在香港，当街抢走了别人的女朋友，然后当场和那女人舌吻。 他凭什么？ 一张白种人的脸而已。 早上醒来看了一眼评论区，挺多人在捂着耳朵大喊“我不管我不管，这新闻一定是假的！一定是那些女人骚浪贱，一定是她们傻逼没文化！” 然后我就准备找个帖子给你们看，也是知乎上的，大意是某女子，处女，保守，高学历，来问，一个刚认识的外国人对他表白了，还说了很多出格的话，怎么办啊，好突然呀，是不是歪果仁的文化就是这样啊，好羞涩好紧张啊。 那个歪果仁说的几句英文翻译成中文后的意思是：“哦！你好漂亮你好美丽做我女朋友吧，我好希望你来舔我的大JB，把你摁在墙上狠狠插！” 一个中国人说这些话已经报警了…… 但是呢，我尴尬的发现我找不到这个帖子了，你们猜猜是为什么呢？ 来，现在把搜索框打开，在顶上搜索“外国人 表白”，然后从上到下慢慢看，有一个算一个，这些女人的态度如何，自己品味品味。 她们骚浪贱？她们没脑子？ 不是，她们只是普通而已。 普通所以接受大多数人的价值观，普通所以被一些潜移默化的暗示影响，正如评论区所说的，亚男找白女就会被人觉得很厉害，而不管这个白女是不是东欧穷国出来的。 我们，这几代人，都被一种自卑感所压住了，我们既是受害者，也是加害者，我们营造了一种崇洋媚外的氛围，而她们则在这种氛围的影响下默认了白皮肤等于高价值，这是一种印在骨头里的自卑。 这种自卑感潜移默化的影响着我们，让我们无比渴望得到白人老爷的认同，一旦听说白人老爷们喜欢中国，爱中国菜，爱中国文化，他们就会兴奋的像自己做出了伟大的事业一样。 95后活在一个好时代，中国强大了，但是还是不够强，还有一些上个时代的余荫，可能要再来个十年二十年，大概到10后的时代，这种自卑感才能被淡化吧。 而现在，这就是令人绝望而恶心的现实，不管你承不承认，就是这样。 其实这个话题我之前谈过一次，我觉得可以回答一些评论区的女权分子，所以我就直接粘过来了。 我本来很爱我男朋友的，但是自从被一个老外告白后，我陷入了前所未有的迷茫中，我该怎么办？ - 知乎用户的回答 - 知乎 很多人问过我，你身为一个文艺工作者竟然爱国是不是精分？我说其实以前我也是不爱国的，看《河殇》，读柏杨，黑起天朝不遗余力。但是有一天我发现一件事。一个外国屌丝，在中国，都可以满街随意约炮，注意是满街，他们甚至可以直接把姑娘从她们的男朋友身边拉走，而姑娘竟然会顺从。她们不是不知道老外根本不会要自己，只是想玩自己，但就是会从。你说她们图什么呢？后来我学习感情方面的东西，学“吸引力”的来源，学到一个词，叫”高价值”，然后我灵光一闪，突然就明白了。正是过去的我那种人，还有我们受欺负的历史，在中国人心中刻下了一个“低等”的思想钢印。当她们遇到一个外国屌丝的时候，那张白种人的脸，已经在灵魂深处默认就是高价值的象征，这张脸代表着“强者”。这种感官无关车、钱、房、腹肌、大屌，只是一种朦胧的感觉，那就是对方是“强大的”。而这种朦胧感觉，搭配上异国文化的神秘感，将让对方的“吸引力”，瞬间翻十倍。当你以为自己是在服从自己的内心的所谓“感觉”时候，其实你只不过是在听从自己基因深处寻求高价值配偶的本能。然而实际上，那所谓的高价值，只是一个幻觉而已。而为了这个虚假的幻觉，多少女人就这样不清不楚的飞蛾扑火？过去的我，是可憎的。从那以后，我非常爱国，因为我们始终改变不了我们的基因，我们的肤色。既然如此，我不希望我的孩子，我的朋友，我身边的人，会因为这些所谓的“自省言论”，而活在一种低劣感中。然后如题主一般，被一种虚假的低劣感欺骗，还要对自己说是因为“感觉”。创建于 2017-02-14作者保留权利","categories":[],"tags":[{"name":"乱七八糟","slug":"乱七八糟","permalink":"https://vlwq.github.io/tags/%E4%B9%B1%E4%B8%83%E5%85%AB%E7%B3%9F/"}]},{"title":"目标-三十而立","slug":"2016/20160301","date":"2016-03-01T02:36:00.000Z","updated":"2017-08-27T05:52:15.786Z","comments":true,"path":"2016/03/01/2016/20160301/","link":"","permalink":"https://vlwq.github.io/2016/03/01/2016/20160301/","excerpt":"我今年41岁了，古人说三十而立，四十不惑。不敢妄称“不惑”。职业生涯几经起落，最终走上了创业的道理。家有两个调皮的女儿。成家立业的立算是做到了。 这里的“立”，我的理解，并不是指事业或者家庭，而是一种承担责任的能力。 这种能力，并不是随着年龄的增长就能获得，它需要你转变自己的思维模式，去不断挑战自己，训练自己，最终才能得到真正的成长。","text":"我今年41岁了，古人说三十而立，四十不惑。不敢妄称“不惑”。职业生涯几经起落，最终走上了创业的道理。家有两个调皮的女儿。成家立业的立算是做到了。 这里的“立”，我的理解，并不是指事业或者家庭，而是一种承担责任的能力。 这种能力，并不是随着年龄的增长就能获得，它需要你转变自己的思维模式，去不断挑战自己，训练自己，最终才能得到真正的成长。 你问我：你经历过哪些思维上的转变？ 一个让我获益良多的改变是： 我意识到，很多时候我们停止成长，是因为一时的成绩让我们骄傲和固执，使得我们不再去探索更多可能性。只有怀着空杯心态，我们才能获得更多的成长。 这里，我想讲讲自己的故事。 刚毕业那会儿，由于很想做市场营销，所以辞去了收入更高的记者的工作，去做了最底层的销售代表。 由于什么都不懂，所以一切对我来说都是困难的。但同时，一切对我来说，又是新鲜的。 譬如，有一次批发客户“发难”，说半年前进的一批卫生巾的背胶粘不牢，要退货。按照规定，半年前的产品是不能做退货处理的。好说歹说，客户就是坚持要退。 那时候我不知道该怎么办，就去请教了一些经验更丰富的“老”销售，但他们也说这事也没有太多很好的办法，说要不就退了呗。 但作为初生牛犊的我，并不觉得有什么事是不可能的，一定有解决的办法。 可能是比较楞的缘故，最后我决定亲自试验这批卫生巾，身为大老爷们的我把一片卫生巾贴在自己的内裤上，之后一天走街串巷，下班后还打了一场篮球，并没有出现脱胶现象。第二天和颜悦色地跟批发商说，大姐这批卫生巾我亲测过，粘得很牢。批发商又好笑又好气，也就不再提退货的事了。 功不唐捐，半年后，我成了正式员工，之后，更是成功转岗，到了品牌部门。 但是，当我在公司呆了几年之后，在不知不觉中，变成了当初请教的那些“老员工”那样。 虽然业务能力得到了很大提升，但思维模式得到了固化，做事更多的开始依赖过往的“经验”，而不去思考它的其他可能性。 我再也没有像当初那样，把卫生巾贴自己内裤上，跑一天试验它到底粘不粘的牢。 换言之，我封闭了自己成长的边界，停止了进一步的成长。 有一次，我接到了一个非常棘手的项目，出于经验，我判断很多地方是不可能做到的，所以当时就在反驳，一条条说明，哪些地方是不可能的，因为什么什么。 的确，在业务水平方面，我是当时全组最强的，所以当我听到一些不太合理的要求，我都是嗤之以鼻的，觉得领导很外行，很傻比，一定要反驳。 但那时候新进来的几个新人，却一直在努力思考，尝试着各种可能性。 后来，我就没管了，跟进了其他的项目，并觉得那几个新人都是在做无用功。几天之后，我惊讶的发现，那几个实习生做出了我以前从没想过的方案，而且所有问题都得到了巧妙的解决。 我十分震惊，并且羞愧。 我震惊于他们的成功，我羞愧于我的轻慢。看到他们，我仿佛看到了当年的自己。 “我以前不也是那样的吗？怎么现在变成了这副模样。” 痛定思痛，我开始有意识的让自己不再去轻易说“不可能”，我收掉了自己的傲慢，而是积极探索一切可能性。 之后的几年，我的成长速度非常快，而且开始领悟到工作的真谛—— 工作并不是生活的对立面，它是生活的一部分，不能享受工作的人，也无法真正享受生活。 没有思想上的转变，我之后也不会几次离开较高的职位、选择在新的岗位、公司从零做起（这些经历可以写一篇新的回答了，敬请期待）。 在2015年离开宝洁前，我曾任年薪百万的市场总监职务，负责过几十亿年销售额的国民洗发水品牌的营销工作。之后我还是走上了创立自己的氨基酸洗发水品牌的道路。我们这个月刚完成了数千万的A轮融资，天猫双十一也做到了美发护发类目的第11名。妄论成功现在还太早，这在资本寒冬的当下也算是不容易了。 现在，我有了自己的公司和一起奋斗的小伙伴们。我能看到像当初刚工作时的我那么拼的，但也能看到像工作了几年以后的我的那种年轻人，我能看到他眼神里对工作的痛苦和煎熬。 每当这个时候，我就会跟他讲我的故事，告诉他，我也是这么过来的。做为公司的创始人，我最希望看到小伙伴眼里闪着的光芒。41岁的我还充满着激情和梦想呢。20多岁的人不要跟我说你已经没有激情和学习的动力了。 Stay hungry and stay foolish！ 最后，我想啰嗦几句提一些具体的建议： 1，不要轻易说不：工作、生活中遇到问题，不要轻易放弃，不要轻易说“不可能”，而是积极去思考它的可能性。这里面，蕴含着宝贵的成长机会。 2，不要轻易跳槽：工作里遇到问题，往往可能是你自己的问题，虽然跳槽之后，你因为新的环境，一开始会打开自己的边界，积极学习，但一旦熟悉了业务模式后，你又会变成那个故步自封的人，新的问题又会接踵而来。所以不要轻易跳槽，而是去想自己的问题在哪里。 3，不要天天熬夜：熬夜并不意味着工作时间的增多，它只能让你的工作效率下降。而且年轻的时候觉得熬夜没什么，但要知道，你25岁要是继续熬夜，熬到30岁，很大可能你会变秃。 4，不要忽略家人：家人比任何事情都重要，25岁以后往往会因为工作繁忙，很少有时间能与自己的家人在一起。但你至少需要多去和他们沟通，聊聊自己的生活，不要多年以后去悲叹“子欲养而亲不待”，后悔自己年轻的时候什么都没做。","categories":[],"tags":[{"name":"乱七八糟","slug":"乱七八糟","permalink":"https://vlwq.github.io/tags/%E4%B9%B1%E4%B8%83%E5%85%AB%E7%B3%9F/"}]},{"title":"出国","slug":"2016/20160228","date":"2016-02-28T02:36:00.000Z","updated":"2017-08-27T05:45:05.943Z","comments":true,"path":"2016/02/28/2016/20160228/","link":"","permalink":"https://vlwq.github.io/2016/02/28/2016/20160228/","excerpt":"我觉得出国回来，最大的不同，就是能让自己抽离出去这个太过熟悉的环境。 人在一个地方待太久，一切的好处坏处，都会习以为常。很多好的坏的，都不能感受到了。 出去工作生活几年，越来越少的中国朋友，感觉真的按照美国人的思维方式，生活了一段时间。然后再回国，那种突如其来的文化冲击，也是感觉很震撼。 对于个人的变化，我觉得第一就是那种思维方式，会更加国际化。你去过不一样的地方，按照不同的思维习惯去考虑问题，审视世界。回来之后，你看见一个问题，很容易的就会以另外一个视角去考虑一下。然后自己的内心也能更加的淡定。因为你可以理解人与人之间巨大的不同，所以也就不再对让所以人懂你，那么的执着。感觉生活就是不停磨砺自己本心的旅程，能做自己觉得对的事，有坚持，就已经很难得。","text":"我觉得出国回来，最大的不同，就是能让自己抽离出去这个太过熟悉的环境。 人在一个地方待太久，一切的好处坏处，都会习以为常。很多好的坏的，都不能感受到了。 出去工作生活几年，越来越少的中国朋友，感觉真的按照美国人的思维方式，生活了一段时间。然后再回国，那种突如其来的文化冲击，也是感觉很震撼。 对于个人的变化，我觉得第一就是那种思维方式，会更加国际化。你去过不一样的地方，按照不同的思维习惯去考虑问题，审视世界。回来之后，你看见一个问题，很容易的就会以另外一个视角去考虑一下。然后自己的内心也能更加的淡定。因为你可以理解人与人之间巨大的不同，所以也就不再对让所以人懂你，那么的执着。感觉生活就是不停磨砺自己本心的旅程，能做自己觉得对的事，有坚持，就已经很难得。 然后再说一些回归后的个人感想。 首先说说不习惯的，第一点当然就是空气，环境，肯定还是差很多。也理解了为什么老外来中国会很想一直戴口罩。但过了两个月也就这样了，反而觉得雨后的上海，还是有股淡淡的桂花香。 第二就是一下子感觉突然世界挤了很多倍。那里都是人，那里都是不守规矩的人。确实是素质是比以前有很多的提高的。但人口基数在那里，就算只有百分之一的人不守规矩，那每天看见的就是很多很多人。 第三就是生活的节奏，特别的快。感觉每个人每时每刻都在赶路，任何事情都怕自己慢了一秒。我们的城市和人，就好像没有刹车的高速列车，一路狂奔，不愿意为任何人，任何事来做停留。 第四呢，就感觉这两年，舆论，海关，都好像更紧了，连上海感觉都没有以前那么的多元化了。这个也谈不上好或者坏，只是习惯了的那些app，网站，现在都要翻墙才能用，翻墙也越来越麻烦，所以老外来了感觉言论不自由，也是有理由的。 说了不好的，又说说好的。第一就是手机支付真的太便利了。回来这么久，几乎就没用到现金或者卡。无纸币的城市，真的已经在发生。电动车在上海也是越来越普及，滴滴打的就几乎全是电动车。 第二就是外卖真的方便。无时无刻，都可以点。但是心里还是会担心食品的安全问题。所以也是尽量不点一些没有实体店的网店。 第三就是国内公司的发展，真的很快，很多东西，转眼之间，已经可以和美国巨头们同场较量。那些外派来中国的高管什么的也越来越少。外企也没有以前那么吃香了。 第四就是国内城市的发展速度，真的日新月异，今年去成都，重庆，遵义，贵阳，都感觉每一个城市都是在大搞健设。每一次回去，都有新的高楼大厦在出现。而且走在城市的交界，也很多新的农村的好看的房子出现。设计感也在走入新农村。 第五就是交通的快捷。高铁是真的太方便了。虽然还是很挤，但是这个速度，真的方便。 我是感觉中国现在就是站在凤凰涅槃的关卡，有很多的问题，但也有很多的机遇，感觉一下秒，也许会功亏一篑，但我更相信，我们会真的强势突围，迎来新的世界。 很高兴，可以来见证这些变革。 毕竟说不定我们是最后的人类了。AI，机器人，肯定会替代现在的人类，以一种新的生命形式出现。希望那时候，我们还有这些自我意识，可以这样互相喷来喷去","categories":[],"tags":[{"name":"乱七八糟","slug":"乱七八糟","permalink":"https://vlwq.github.io/tags/%E4%B9%B1%E4%B8%83%E5%85%AB%E7%B3%9F/"}]},{"title":"gua5700","slug":"2016/20160215","date":"2016-02-15T02:36:00.000Z","updated":"2017-08-27T05:59:23.221Z","comments":true,"path":"2016/02/15/2016/20160215/","link":"","permalink":"https://vlwq.github.io/2016/02/15/2016/20160215/","excerpt":"#5700奥义","text":"#5700奥义 FE部分123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172173174175176177178179180181182183184185186187188189190191192193194195196197198199200201202203204205206207208209210211212213214215216217218219220221222223224225226227228229230231232233234235236237238239240241242243244245246247248249250251252253254255256257258259260261262263264265266267268269270271272273274275276277278279280281282283284285286287288289290291292293294295296297298299300301302303304305306307308309310311312313314315316317318319320321322323324325326327328329330331332333334335HTML 部分localStorage 和 cookies// localStorage、 sessionStorage 与 cookies 的区别// localStorage 用于多页面通信FormData// 上传文件需要用到这个对象File API// 预览图片使用CSS 部分floatpositiondisplay flex (用 flexbox froggy 或者阮一峰的博客去学)水平居中 inline 的水平居中 block 的水平居中垂直居中 有完整的套路 父节点为 position: relative 自己为 position: absolute top: 50% transform: translateY(-50%)响应式设计移动开发 主要是微信网页开发JS 部分值类型与引用类型//var a = &#123; v: 1&#125;var b = aconsole.log(b.v)// 1a.v = 2console.log(b.v)// 2a = &#123; v: 3&#125;console.log(b.v)// 2// 变量声明提升(这是一个特性)// 这段代码console.log(a)var a = 1// 相当于var aconsole.log(a)a = 1// 所有以 function 函数名() &#123;&#125; 方式定义的函数都相当于提前定义了一遍// 这段代码console.log(b())function b() &#123; return 2&#125;// 相当于var b = function() &#123; return 2&#125;console.log(b())// 这段代码console.log(c())var c = function() &#123; return 3&#125;// 相当于var cconsole.log(c())c = function() &#123; return 3&#125;// 所以 console.log 会报错, 因为 c 在那个时候还不是一个函数, 只是 undefined// 注意，let 或者 const 声明的变量不具备 变量声明提升 的特性console.log(d)let d = 4// this//var x = 0function test() &#123; console.log(this.x)&#125;var o = &#123;&#125;o.x = 1o.m = testo.m()o[&#x27;m&#x27;]()o.m.apply()// apply 请看 apply bind call this 那节课// this + argumentsvar gua = &#x27;name 001&#x27;var foo = function()&#123; // arguments 并不是数组, 只是行为恰好和数组一样, 一般称为奇异数组 // 这个函数的 this 是 arguments console.log(arguments[&#x27;0&#x27;]()) // console.log(arguments[0]())&#125;var o = &#123;&#125;o.gua = &#x27;name 000&#x27;o.func = fooo.func(function()&#123; return this.gua&#125;)o.func2 = function()&#123; arguments.gua = &#x27;gua&#x27; // 这个函数的 this 是 arguments, 所以输出是 &#x27;gua&#x27; console.log(arguments[0]())&#125;o.func2(function()&#123; return this.gua&#125;)// prototype// 原型链//function Foo() &#123; this.name = &#x27;a&#x27;&#125;var f1 = new Foo()f1.name = &#x27;b&#x27;console.log(f1.name)var f2 = new Foo()console.log(f2.name)arguments//(function() &#123; return typeof arguments&#125;)()(function() &#123; console.log(arguments)&#125;)(1, 2, 3)(function(...args) &#123; console.log(args)&#125;)(1, 2, 3)call, apply, bind// call, apply 和 bind 的区别setTimeout 和 setInterval// 两者的区别setTimeout 与循环结合// 下面的输出全是 5, 因为引用的是 i 这个变量// 注意超时时间是 1000// 引用的 i 可以在函数内部访问到这件事称之为 闭包for(var i = 0; i &lt; 5; i++) &#123; setTimeout(function() &#123; console.log(new Date(), i) &#125;, 1000)&#125;console.log(new Date(), i)// 皇帝的闭包问题// 这根本不是闭包的问题// 因为 setTimeout 即便第二个参数是 0 也会在循环结束之后才执行函数// 所以 5 个输出都是 5for (var i = 0; i &lt; 5; i++) &#123; setTimeout(function() &#123; console.log(new Date(), i) &#125;, 0)&#125;for (let i = 0; i &lt; 5; i++) &#123; setTimeout(function() &#123; console.log(new Date(), i) &#125;, 0)&#125;let i = 0for (; i &lt; 5; i++) &#123; setTimeout(function() &#123; console.log(new Date(), i) &#125;, 0)&#125;事件冒泡, 事件捕获, 事件委托// 讲清楚这三个概念闭包// 所谓经典的闭包面试题(上面讲过的皇帝的闭包)// 使用闭包实现如下程序// 函数每调用一次，该函数的返回值加 1var foo = function()&#123; var i = 0 return function()&#123; i++ return i &#125;&#125;var a = foo()a()a()clone 和 deepClone// 实现 clone 和 deepClone 函数// 用 JSON.stringify 和 JSON.parse 实现 deepClone 是一个很有新意的方式// 具体实现会在 面试大全 里ajax（可能需要手写原生的 ajax）// 实现原生的 ajax 函数// readyState 0 1 2 3 4 各代表什么含义HTTP 请求方法, 常见状态码, 头部常见字段// HTTP 有哪些常见请求方法 GET POST PUT PATCH DELETE// HTTP 常见状态码有哪些 200 301 302 403 404 500 502// HTTP 头部常见字段有哪些 Content-Type Content-Length跨域 （jsonp, postMessage, cors, 用服务器(比如 node)转发请求和响应）// 跨域有哪些常见的解决方式网络安全: xss, csrf// xss 和 csrf 的原理是什么DOM 操作（查找, 添加, 删除, 修改）// DOM 查找/添加/删除/修改对应的 API 是什么jQuery 常见 API// jQuery 常见 API数据结构数组对象队列栈数组、对象、字符串的想换转化比如 a=1&amp;b=2&amp;c=3 怎样转成对象, 复习基础课程的作业就可以// 有这样一个 url： http://vip.qq.com/a.java?a=1&amp;b=2&amp;c=3&amp;d=xxx&amp;e// 写一段 JS 程序将 url 的参数转成对象的形式&#123; a: 1, b: 2, c: 3, d: &#x27;xxx&#x27;, e: &#x27;&#x27;,&#125;ES6ES6 的面试题一般是概念性质的, 所以清楚下面的概念就可以了let 和 const, 有一个 TDZ （暂时性死区的概念，了解下即可）箭头函数解构剩余参数(扩展符号)Promise, 可能会附带 async awaitclassSet// 用解构来简化参数列表var gua = function(&#123;name, height&#125;)&#123; console.log(name, height)&#125;var gua2 = function(info)&#123; console.log(info.name, info.height)&#125;var info = &#123; name: &#x27;gua&#x27;, height: 169,&#125;gua(info)React// React 也是概念性质的题目为主, 基本上不会考察写代码React Angular 这 2 个一般只会一个就可以的, 所以这里只说 React 的情况react 的广告virtual domdiff 算法的原理state 和 props组件生命周期组件通信：父组件 -&gt; 子组件, 子组件 -&gt; 父组件, A 组件 -&gt; B 组件React Router（react 路由）Redux/MobXreact ui 有两套很流行: Material UI 和 Ant Design, 国内流行的是 Ant Design 职业规划123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142写简历 个人基本信息(姓名 邮箱 手机) 技能 项目 教育经历 工作经验投简历 拉勾(假公司比较多, 100 中 5 差不多, 用小号投) boss 直聘, 野鸡比较多(100 中 5) 智联/51job(小城市) 原则是海投海面 不要有感情 注意不要被培训公司诈骗面试 记录面试情况, 有问题来找我反馈 反馈的时候要提供以下信息 1, 所在城市 2, 投递的简历数量 3, 面试次数 4, 面试遇到的问题特殊情况, 来找我私聊工作1, 工作之后的规划 1) 规划跳槽, 从第一天起 规划好自己半年/一年后的状态 规划好达到那个状态需要做的计划 不要对公司/老板有盲目的感恩之心，互利双赢才能长久 要以自己的规划为主 2) 要设定职业规划, 探索职业方向 要照顾到自己的喜好, 做喜欢的事情 要保护好自己的热情(做喜欢的事情, 尽量避免被公司业务污染) 要符合自己的意义 公务员的工作有意义，但是你不认同也会做着痛苦 3) 认清自己的地位 你做了自己的选择，并不只是运气好 你只是一个流水线工人 一个公司相当于一个作坊, 由 前端/后端/设计/产品/测试 合作完成一个东西 资深工人 多工种工人 4) 个人增值的方式 把某个技术做精, 变成专家级流水工 坏处就是万一被淘汰就跪了 还有就是鸡蛋放到一个篮子里面了 选择的空间也少, 比如 nokia 和 moto 被裁员的员工 为了避免这个窘况, 大家要做流行性高/通用性强的方向 ios 安卓 就不行 web 更长青 编程能力是最重要的，切换语言很简单 市场如果有需求，一夜之间千万 xx 语言码农就出来了 横跨多个领域, 做复合型掏粪工 比如全栈, 就是典型的复合型掏粪工( node.js ) 掏得越多越好 越快越好 node 是趋势 前端没理由去接触别的语言 比如技术和其他领域的结合 软件 + 医疗 互联网 +2, 学习的计划 合理正确的规划方式 时间不要贪多, 以自己能接受为前提, 从小到大慢慢提高 计划太多学不完 学不完有负罪感 然后就炸了 所以要慢慢来，遵循客观规律 不要妄自菲薄（我自控力差，我做不好事） 目标要细化, 最好是把事情分解为 20 分钟甚至 10 分钟能解决的程度 目标大了就会拖，拖了就做不完 把目标写下来 一条条做 要合理看待不能完成的任务, 要有标准化的预案 比如超过设定的极限时间不能解决就提问 避免买包出斧心理 买包就是试图付出 xx 资源来得到 yy 好处（无视客观规律） 出斧就是情绪驱动，不按照客观规律做事 不要试图通过去学一些奇怪的东西来提高能力 我要看原版书，我看原版书，得到原汁原味的知识 有些东西英语就是英语，用中文是无法表达的 我要学 java 我要学人工智能 我要学底层（什么是底层？） 不要被情绪驱动, 要按照计划来做事/学习 不能说今晚做不出就不睡 不能说我一定要自己想出来才是我的，该问就问3, 前端知识点的聚合 react grunt gulp webpack babel es6 less sass 这些都是花哨的名词而已 都可以通过 阮一峰 的网站来了解 仅限于阮一峰的网站中介绍的内容，其他一概忽略 最重要的还是 js 编程能力 比如不断地练习写程序来提高 比如通过阅读《代码大全》这样的经典书籍来提高 这本书可以随机读自己喜欢的章节 编程能力在不同语言之间是互通的 其次是 html 和 css 的运用能力 多写 多抄 多看书 任何工具都只是帮助你更好更方便地构建网站, 本质还是写网页4, 其他 倍速视频 节约时间 集中精力 论坛提问的表格具有很高的价值, 要善加利用 比提问的智慧简单很多 是长期实践中归纳总结出来的方法 怎样选择要读的书(不限于技术书) 绝大部分书都是垃圾 即便是好书, 大部分内容很可能也没什么用 粗读, 不要精读 绝不要去读原版 这些是我长期实践的总结，仅供参考 更多的训练项目 electron 视频播放器 天气应用 计算器 浏览器插件（GIF ZhiHu） 爬虫 爬虫结果的图表化数据分析（数据可视化、数据分析） markdown 编辑器 美味便签 小游戏(phaser.js 网站上学习) HTTP 协议(主要用在 AJAX 上) 用到再学 改键位和快捷键 https://zhuanlan.zhihu.com/p/24020977 KISS keep it simple stupid 要把事情做得简单(一个函数简短 并且完成一个功能) DRY dont repeat yourself 不要写重复代码*/","categories":[],"tags":[{"name":"guagua","slug":"guagua","permalink":"https://vlwq.github.io/tags/guagua/"}]},{"title":"问题","slug":"2016/20160205","date":"2016-02-05T02:36:00.000Z","updated":"2017-08-27T05:45:11.280Z","comments":true,"path":"2016/02/05/2016/20160205/","link":"","permalink":"https://vlwq.github.io/2016/02/05/2016/20160205/","excerpt":"问题一：你们为什么要招聘这个职位？Q1: Why are you currently recruiting for this position?这个问题会使得面试官开始谈论当前的项目，或者谈论前一位离职人员。无论哪种情况，都会让你了解，一些与你最密切相关的公司情况。","text":"问题一：你们为什么要招聘这个职位？Q1: Why are you currently recruiting for this position?这个问题会使得面试官开始谈论当前的项目，或者谈论前一位离职人员。无论哪种情况，都会让你了解，一些与你最密切相关的公司情况。 问题二：你们的新员工多吗？Q2: Do you have many new staffs?这个问题起一个过渡作用，使得谈话导向公司内部的情况。但是，它本身也能说明一些问题。如果公司成立已经超过四年，又没有新项目，但是新员工却很多，这往往说明公司文化不是很健康。问题三：你们公司（团队）目前面临的最大挑战是什么？Q3: What are the biggest challenges your team are facing right now?如果面试官开始谈论一些具体的技术问题，这很好；如果他的回答是项目时间紧迫，或者需要更多的资金，那你就要小心一点了，公司管理上面可能有问题。问题四：什么新技术（编程语言）是你们未来希望采用的？Q4: What technologies/languages would you like to see your team adapt to that aren’t currently being utilised?如果你申请的是技术职位，面试官恰巧又是技术负责人，那么这个问题将会非常合适。你会对公司的技术路线有所了解和准备，一旦入职，就能更好地适应公司的需要。问题五：在业务方面，有没有什么地方是你们不满意的，未来想要改进的？Q5: Few companies, if any, are 100% satisfied with the way their business is operating. If you could simply flick a switch to fix it, what one thing would you change?很少有公司，会百分之百满意自身的现状，即使那些状况很良好的公司也是如此。这个问题可以让你对公司管理层的关注重点和担忧之处，有所了解。问题六：我申请的这个职位，对公司的业务有何影响？Q6: If you struggle to fill the position I have applied for, what impact would that have on the business?这个问题会让你了解自己在公司的角色，以及你的岗位对公司是否重要。","categories":[],"tags":[{"name":"乱七八糟","slug":"乱七八糟","permalink":"https://vlwq.github.io/tags/%E4%B9%B1%E4%B8%83%E5%85%AB%E7%B3%9F/"}]},{"title":"颈椎病","slug":"2016/20160203","date":"2016-02-03T02:36:00.000Z","updated":"2017-07-05T10:59:55.367Z","comments":true,"path":"2016/02/03/2016/20160203/","link":"","permalink":"https://vlwq.github.io/2016/02/03/2016/20160203/","excerpt":"本文内容包括：症状，诊断方式，治疗方式，三部分。 01 我是在2015年5月，才知道自己得了颈椎病。 可笑的是，在这之前的N年里，虽然有一堆症状，我却对颈椎病一无所知。能够确诊，也是因为偶然。 当知道了颈椎病后，才发现，原来身边的人，只要常办公室，或是常对着电脑手机的人，竟然都有颈椎病症状……何其可怕…… 医生说， 曾经在他的课本中，老年后才会高发的病症，却因为手机IPAD电脑的普及，开始有越来越多二十一二岁的病人。","text":"本文内容包括：症状，诊断方式，治疗方式，三部分。 01 我是在2015年5月，才知道自己得了颈椎病。 可笑的是，在这之前的N年里，虽然有一堆症状，我却对颈椎病一无所知。能够确诊，也是因为偶然。 当知道了颈椎病后，才发现，原来身边的人，只要常办公室，或是常对着电脑手机的人，竟然都有颈椎病症状……何其可怕…… 医生说， 曾经在他的课本中，老年后才会高发的病症，却因为手机IPAD电脑的普及，开始有越来越多二十一二岁的病人。 02 颈椎病会有很多看似不关联的症状，然而细究其原因，还是能得出一些端倪的。 因为连接大脑，而大脑又掌管全身，当颈椎出问题时，最大的影响是——大脑。 想象一下，颈椎动脉是一根粗水管。水管在弯折扭曲的时候，会受到挤压——我们小时候应该都玩过呲水的游戏，当挤压水管时，水管变细，能通过的水流量变小了，但水管内的压力更大，水花呲得更远了。 对颈椎动脉来说，也是如此。 颈椎变型，动脉受到挤压。结果是，一方面，流向大脑的血液变少了，另一方面，血流的速度也更快了。 这两个状态，导致了很多问题的出现。 大脑供血减少时，最先出现的症状是——记忆力减退、易困嗜睡。长期脑供血不足，会引起大脑的损伤。大脑为了避免这种结果，会命令心脏更加积极地供血，于是又出现了心跳过快的症状。 血流的速度更快时，对血管的冲击力也变大了。血管不断承受着高频次的冲击，于是产生了头痛问题。 在年轻时，血管弹性较好，不会出现较大的危险。然而，随着年龄增长，血管弹性降低，面对冲击时，最可怕的后果，是脑部血管爆裂，颅内出血……（当时医生为了让我重视问题，把后果说得很严重）。 头供血不足，脸上皮肤差，脸色不好，这都算小事。更难受的是干眼症。 可能因为眼部都是毛细血管，毕竟血液都优先供脑了，眼睛顾不上吧，于是眼疲劳来得很快，渐渐的泪液也分泌得越来越少。眼皮内侧，其实是一堆鸡皮疙瘩似的不光滑的平面，平时全靠泪液润滑。当没有泪液时，每眨眼一次，眼皮内侧都像刀片一样刮眼，疼痛难忍…… 心脏长期快速跳动的时候，人也很容易疲惫，经常觉得累，做什么都需要一会一歇息。 当心脏加速供血，还脑部缺血时，人体会有应激反应——呕吐、眩晕，无法直立，必须躺倒休息。到这一步时，其实颈椎病已经进入的非常严重的地步了。 还有的症状，还包括手脚麻等症状（然而原理未知，我忘问医生了） 我的症状出现的很早，持续了不少年。 进入2015年时，已经非常严重了 。当时每天都在头疼，脑门随手一捏，就出来一道道紫色印子。平时静止状态的心跳一直在110以上，下班回家15分钟的步行路程，也需要中途休息个两三次。 再后来，频繁地头痛呕吐，开始影响到工作了。那段时间，又遇到个同行加班后突然猝死的新闻，导致我心理压力也很大，于是终于不敢再拖延，开始了治病岁月。 03 上面说的，都是自己很容易观察到的表面症状。 确诊的话，确切地说，需要到骨科做两项检查：颈椎X光片，和TCD脑血流检测。同时也建议挂一下心内科，检查一下心脏。 骨科的检测，类似下图这种。（我在2014年底就拍了X光片显示颈椎变直，然而当时的医生却没重视，后来重复走了很多冤枉路，所以碰上一个好医生也是不容易……） TCD检查，学名叫经颅多普勒检查，原理就是检查脑部血液流速。流速过快的话，结果会显示“动脉痉挛”，最多的结果，好像就是3个部位痉挛吧。 （我拿着3个部位痉挛的结果时，医生很震惊，说这是他当时见过的最严重的病人……） 然而我却从14年12月一直到15年的5月间，无数次的波折。跑过N家医院，内科，外科，脑病科，骨科，肺病科（当时肺也不好，不戴口罩就咳），眼科（因为干眼症），针灸科，挨个科室，轮流挂号。就是这么两个检查，就能确诊的结果。 脑部拍过核磁共振，吃过癌症止痛的药，做了很多检查，却听了太多的医生说“无法解释头疼的原因”。 后来一个信任的内科医生随口说，颈椎也会引起头疼，建议去骨科做个检查。然后我才决定，再去一次骨科。 先挂了一个号，随机碰了个医生。我说头疼，不知是不是颈椎的问题，医生看了我一眼，什么话也没说，直接开了两盒膏药，就让我去付费。 我顿时觉得被唬弄了。于是又去重新挂了个号，换了个医生，这次的医生叫汤俊，终于被重视了。 做完TCD检查，他又解释一遍原理，症状和原因一对照，我顿时拔开迷雾，豁然开朗了。 后来我的颈椎病能治好，也是亏了这个医生。 （一直想给他送个锦旗，然而因为人懒……如果汤医生能看到这篇文章，很想说，汤俊，谢谢你治好我！） 04 前面说了外部症状、确诊的检查方式。 然而谈到治疗，就不得不先说，为什么会得。 医生解释说，无论是颈椎病还是腰椎病，本质上都是肌肉无力，肌肉不能分担受力，就会造成骨头受力太大，从而在弯曲后，无法再恢复到初始状态。 治疗方式上，推拿、牵引、包括后面我要说到的颈椎枕，都是属于用外力，强行将骨头复位。然而这种方式，治标不治本，还会复发。 最根本的方式，其实是加强自身的肌肉力量，强有力的肌肉，会自己将骨头推回原位，并在后续的时间里，帮骨骼分担压力，从而防止复发。 上海中医医院（汤医生在的医院）的治疗方法，其实就是刺激肌肉生长。 针灸颈部的四个穴位，针上连着电线（电池供电），然后用微弱的电流，刺激穴位周围肌肉纤维的生长。 治疗的过程中，确实能感受到变化。最初针灸时，针扎入皮肤，没几分钟就掉出来了，然后就得召唤医生来补针。一个小时的治疗，需要叫四五次医生。 医生也很无奈，解释说，针扎到皮下，肌肉纤维会包裹住针。所以，如果肌肉萎缩，纤维无力，裹不住针的，就会掉出来。 治疗一段时间后，最明显的变化是，针终于不掉了。医生看了也很高兴，说你肌肉纤维终于有点力量了，扎针时也终于能感觉到有弹性了，不像刚来时，扎进肉里感觉像扎到纸里似的。 我还是每一个多月去做一次TCD检测。到了11月时，X光片也显示正常了。 从确诊颈椎病，直到治疗结束，历时5个多月，这期间每周两次去医院治疗。05 然而我知道，这种治疗方式，不是所有人都能够接受。一方面，不是每家医院都能治，另一方面，长时间的请假也不是所有人都能接受的（比如我那年的升职加薪年终奖，就统统消失了……）。 所以如果无法医院治疗的话，就只能自己锻炼肌肉了。 再补充几个我自己的经验： 1、当剧烈头痛爆发时（甚至开始呕吐时）：这是大脑的应激状态开始了，只能立即平躺休息了，再强忍着做各种事，很可能会造成脑损伤。不过我在亲身检测中，发现《藿香正气口服液》能很快缓解症状。（原因未知。我一度怀疑，是不是因为其中含有酒精，从而使血液循化加快，进而缓解了脑供血不足） 2、当长期头痛，身体虚弱时，可以考虑颈椎枕（外力方式）。颈椎枕就是一个圆柱型的枕头，睡觉时垫在颈部。可以淘宝买，也可以自己用杂志卷一个筒，外面包上毛巾。但需要注意的是，这种外力改变颈椎弧度的方式，是短期治标不治本的方法，该锻炼仍要锻炼。 3、长远来看，最终的方式仍是肌肉的恢复。比如，打羽毛球，放风筝，游泳 有一个从老中医处讨来的颈椎运动偏方，也满有效。 这个方法，用一句话描述就是：用下巴画最大的圆弧。下巴前伸，然后向下，再向后尽力缩，再向上尽力仰。（做的时候要小心，正常人做是没问题的，然而肌肉无力的颈椎病人做，会听见骨头咔咔作响的声音……） 写在最后，帮毛毛同学做个推荐。 她是关注我很久的粉丝了。 6月5日， 她将开一个免费直播， 会有专业的健身教练来分享 如何改善肩颈问题。 http://weixin.qq.com/r/dirL0zTE5WmarXCw939k (二维码自动识别) 蜜圈小课堂第1期｜不良坐姿会导致圆肩驼背？教你如何缓解肩颈不适，远离不良体态。欢迎点击链接，报名参加。","categories":[],"tags":[{"name":"健康","slug":"健康","permalink":"https://vlwq.github.io/tags/%E5%81%A5%E5%BA%B7/"}]},{"title":"赚客","slug":"2016/20160202","date":"2016-02-02T02:36:00.000Z","updated":"2017-08-27T05:44:55.473Z","comments":true,"path":"2016/02/02/2016/20160202/","link":"","permalink":"https://vlwq.github.io/2016/02/02/2016/20160202/","excerpt":"【本文适合上班狗学生党家里蹲等社会闲散人士食用】把高赞答主分享的都浏览了遍，发现居然没人分享这个方法！！从大学里开始就网赚的我必须要回答这题！ 那就是 “做调查!” OK，可以终结此题了…为什么呢 因为这个是真·无门槛的啊！只要点开就能做，而且做完就能看到收益，不用等什么结算balabala，分分钟解决学生党月底吃土的燃眉之急好吗！！ 先上个图","text":"【本文适合上班狗学生党家里蹲等社会闲散人士食用】把高赞答主分享的都浏览了遍，发现居然没人分享这个方法！！从大学里开始就网赚的我必须要回答这题！ 那就是 “做调查!” OK，可以终结此题了…为什么呢 因为这个是真·无门槛的啊！只要点开就能做，而且做完就能看到收益，不用等什么结算balabala，分分钟解决学生党月底吃土的燃眉之急好吗！！ 先上个图 这是最近上班空暇时候做的(答主金融公司打杂，巨忙) 一个调查5~15分钟左右 下面附上【详细攻略】 —————————————————攻略不长，食用时间5分钟—————————————— 先给没做过，不清楚的小伙伴简单科普一下 做什么调查：来自世界各地(包括国内)正规企业的市场调查。我做过迪士尼、宝马、美团、壳牌、民生银行、万事通卡、微软等等…是不是有种不明觉厉?哈哈,你也可以为什么能赚钱：这些问卷都是由以上这些生产商服务商等为了提高产品和服务的质量所面向客户做的，它们把这些问卷外包出去，通过这些调查网站务，匹配到调查的人群，我们去帮他们完成调查 ，算是互惠互利啦~接下来分享几个我认为比较好做的调查网： 爱调查 推荐指数☆☆☆☆爱调查-中国在线调查网|让市场调查变得更高效、更轻松、更专业这个无敌推荐！因为光只做这一个网站，一天收益也差不多有小几十了~ 看日期很多都是新鲜出炉的调查，100积分=1块一般一个调查 300500积分， 做成功率高一点的很容易过唷。 2、集思网 推荐指数☆☆☆ 加入集思网，今天就开始赚取奖励！这个是个国际挺有名的调查公司，给钱非常粗暴，直接支付宝，科科我就喜欢这么财大气粗的。 一个问卷45~250积分不等(我做过一次400积分的问卷棒呆)，1000积分=50RMB 它一般的问卷比较少，不过只要符合调查条件能做的可以过，通过率是最高的，大概有70~80%吧 必做之一~推荐！ 3、Globaltestmarket 推荐指数☆☆☆☆ http://cn.globaltestmarket.com/myprofile.php 这是个国际调研公司，也灰常财大气粗唷！缺点就是刚开始注册的个人情况调查填写比较麻烦，不过填写好资料后就等着开始做调查收钱吧 ~ 一个问卷7001800积分不等 每天推送36个问卷 3800兑换价值50元亚马逊电子证书 比较坑的是这个网不能换现金！！所以每次答主都要去淘宝折价卖掉好心痛！！！ 4、Toluna - Opinions for all 推荐指数☆☆ 这也是个国际公司，不过相比楼上几个网站，这个要抠门的多了。。。。 界面看着很高端有没有？蓝鹅他们兑换规则是这样的。。。。 40000积分=50RMB/// 一个问卷大概1200~3000积分 搞这么大的数字假装自己很大方吗？？((微笑脸 而且问卷巨长，我有次50分钟还没做完，最后凭着我的执着硬是完成了，然后给我两块五… :-D 5、Paid Surveys 推荐指数☆☆☆ 这个叫做美国网，是个历史满悠久又信誉良好的公司，拥有260万个独立ip注册用户，Alexa综合排名全球432位，每个月向会员支付360万美金的广告费用。厉害了。。。 可以说这个公司的实力应该能吊打楼上所有了。。。 要什么积分？做完成调查直接给你美金！！现在汇率1刀=6.8RMB 咖喱给给 每天推312个调查(浮动就是这么大，任性！) 你要是全做完了，稳定收入69刀不等 但是！ 什么都有个但是 美国网虽然看起来给钱最豪迈，但是调查也是最需要技巧的，因为它的调查会有截止人数，结束就没法做了，但是还会显示出来，所以很多套路啊！ 不过话虽这么说，答主还是靠着丰富做调查的经验赚了小几十美金，（嘚瑟脸 总之建议想尝试做美国网的小伙伴可以先去做做国内的网站熟悉一下套路~ 答主先分享这么多了，关于美国网的详细攻略参考我的另一个回答， 附上链接： 怎么在空闲时间用网络赚钱且收入不低于50? - 知乎鉴于篇幅关系，关于这道题答主先分享这么多，还有一些攻略，比如做调查应该绕开哪些陷阱题提高通过率，还有美国网注册步骤，以及怎么重复做一个调查，答主会陆陆续续更新在公众号里，欢迎想要 赚零花钱的上班族关注，科科 领取攻略：洗干净小手 关注”小咸鱼君网了个赚” 回复”我很可爱”即可领取 http://weixin.qq.com/r/0jhnfz3EU2AsrXkc923A (二维码自动识别) 从明天开始定时更新关于调查网赚钱攻略方法，详细步骤，闭坑秘籍~ 我们的口号是：0投入，0付出 不花时间，挣点小钱 觉得有帮助的话点个赞吧~笔芯 只收藏的观众老爷们！！球球你们再抬一下你们高贵小手，戳一下赞吧！我哭了","categories":[],"tags":[{"name":"乱七八糟","slug":"乱七八糟","permalink":"https://vlwq.github.io/tags/%E4%B9%B1%E4%B8%83%E5%85%AB%E7%B3%9F/"}]},{"title":"很难很难","slug":"2016/20160102","date":"2016-01-02T02:36:00.000Z","updated":"2017-08-27T05:45:16.365Z","comments":true,"path":"2016/01/02/2016/20160102/","link":"","permalink":"https://vlwq.github.io/2016/01/02/2016/20160102/","excerpt":"比如。其实我没那么喜欢你，除了喜欢你以外，我还喜欢很多人，跟你说过的话跟很多人都说过。我知道很多固定的套路，比如送了我礼物会频繁的表示感谢，生活里会频繁的表示想念。但其实并不想你。见你之前为了看起来身材好不会吃饭，拒绝跟你开房的原因五次里有五次是因为没带卸妆和化妆品。我知道对你来说什么礼物性价比最高，因为不同的礼物送过很多人已经送出了经验。我知道什么姿势你会忍不住想抱住我，我知道什么样的表情你会看见了忍不住摸我的头。我知道你会突然增加对我关爱的点，就是我因为受委屈自己哭，然后假装乐观坚强嘻嘻哈哈的时候。你不知道的最大秘密就是你以为已经了解了我的一切，但是却不知道一切都是伪装。想想会觉得你挺惨，但是仔细思考我才是最惨的那个，连喜欢一个人都不敢。想想还是我比较惨吧。","text":"比如。其实我没那么喜欢你，除了喜欢你以外，我还喜欢很多人，跟你说过的话跟很多人都说过。我知道很多固定的套路，比如送了我礼物会频繁的表示感谢，生活里会频繁的表示想念。但其实并不想你。见你之前为了看起来身材好不会吃饭，拒绝跟你开房的原因五次里有五次是因为没带卸妆和化妆品。我知道对你来说什么礼物性价比最高，因为不同的礼物送过很多人已经送出了经验。我知道什么姿势你会忍不住想抱住我，我知道什么样的表情你会看见了忍不住摸我的头。我知道你会突然增加对我关爱的点，就是我因为受委屈自己哭，然后假装乐观坚强嘻嘻哈哈的时候。你不知道的最大秘密就是你以为已经了解了我的一切，但是却不知道一切都是伪装。想想会觉得你挺惨，但是仔细思考我才是最惨的那个，连喜欢一个人都不敢。想想还是我比较惨吧。 ——————更新线评论区估计是有的没有看懂的，讲真。如果有这样一个妹子：会控制自己的身材偷偷减肥，不见你的时候不怎么吃，跟你在一起的时候吃什么都行一点都不矫情。吃饭会主动买单，看电影知道主动买小食，收到了礼物都会记得回礼，而且都是你想要但是自己可能舍不得买的东西。收到了男生的礼物再小的东西都会表示感谢，并且在未来几天里都会感慨这个东西多么多么好，自己多么喜欢。不会限制你玩游戏，跟你吵架不会要你哄，自己过一会儿就好了。能自己做的事情不会麻烦你，不能自己做的事情尽量用钱摆平。床上会满足你的喜好不断提高。一段关系里不用花很多的心思就可以享受到一个相对高质量没负担的恋情，作为男生的你会不会喜欢呢？你会觉得对方出门独立在家对你小鸟依人，但其实她的心里你永远都进不去，因为谈恋爱多了，总会经历一些故事，心里总会装着一些人。同样流程都很熟悉怎么搭讪怎么吃饭怎么制造气氛怎么维持长久的关系怎么样结束不伤害对方。这样的妹子没有天生的。妹子一开始都是占有欲极强、经常会要求陪伴有些事情看起来会做的很幼稚，当初我也是这样的，但是也是我爱的最深的时候。之后的一切偶尔会觉得愉悦，但是很难会走心，不会有什么是不能割舍难以放弃的。而经历过这么多最终变成这样的妹子，就很难很难去喜欢甚至爱一个人了。同样我也是。创建于 2016-10-25作者保留权利","categories":[],"tags":[{"name":"乱七八糟","slug":"乱七八糟","permalink":"https://vlwq.github.io/tags/%E4%B9%B1%E4%B8%83%E5%85%AB%E7%B3%9F/"}]},{"title":"别给自己设定界限","slug":"2016/20160101","date":"2016-01-01T02:36:00.000Z","updated":"2017-08-27T05:51:57.902Z","comments":true,"path":"2016/01/01/2016/20160101/","link":"","permalink":"https://vlwq.github.io/2016/01/01/2016/20160101/","excerpt":"你会发现，大部分人对事物的理解多为道听途说，他们会告诉你“你做不到”，不是因为“他们知道你做不到”也不是因为“他们自己做不到”而是因为:“他们听别人说做不到”。","text":"你会发现，大部分人对事物的理解多为道听途说，他们会告诉你“你做不到”，不是因为“他们知道你做不到”也不是因为“他们自己做不到”而是因为:“他们听别人说做不到”。 就这个问题，答主在MIT的时候，问过自己的一位老师，诺贝尔物理学奖得主，夸克的发现人，弗里德曼。 在这里，答主要揭示一个关键的逻辑，这个关键的逻辑，诅咒着99%的人。 这个逻辑是什么呢？ 请紧跟下面对话，不要快速阅读，要慢慢看，一句一句地看： 弗里德曼：地球是圆的吗？ 答主：是的。 弗里德曼：你知道地球是圆的吗？ 答主：知道。 弗里德曼：但是，你知道地球是圆的，说明你很厉害吗？ 答主：不。 弗里德曼：你知道一个很重要的实事，而且你是对的，为什么不能证明你很厉害？ 答主：因为：这个事情已经得到大家的认同了！ 弗里德曼：是啊。只要是大家都已经认同的东西，你再对，也没有意义了。 其实，任何个人的成就，特别是在学科领域，都是在大家不知道、不同意，甚至强烈反对的时候，你坚持，并且发现你是对的之后，才产生的。也就是说，想要做出成就，最主要的就是：不能做大家都已经认同的事情。也就是，要出众，则不能从众。在这方面，中国的学生是最差的。 答主认为，这才是“钱学森之问”真正的答案。","categories":[],"tags":[{"name":"乱七八糟","slug":"乱七八糟","permalink":"https://vlwq.github.io/tags/%E4%B9%B1%E4%B8%83%E5%85%AB%E7%B3%9F/"}]},{"title":"鸡汤","slug":"2015/20151001","date":"2016-01-01T02:36:00.000Z","updated":"2017-08-27T05:47:16.806Z","comments":true,"path":"2016/01/01/2015/20151001/","link":"","permalink":"https://vlwq.github.io/2016/01/01/2015/20151001/","excerpt":"看完文章，你就知道如何月入10万。达到了月入10万，那么白手起家月入100万，就更加的容易了。 现在的中国，进入了更高层次的“资本经济”的时代。 什么是“资本经济”时代呢？简而言之，它就是在市场经济的基础上加了一根“杠杆”，在物理学上“杠杆”的作用是利用“力臂”将“力量”放大，从而可以翘起更大质量物体。经济上多了这一根杠杆，其活动空间和灵活性都大大增强，这也叫“资本思维”。今后的中国人必须深刻理解和运用“资本思维”这个工具。 资本思维","text":"看完文章，你就知道如何月入10万。达到了月入10万，那么白手起家月入100万，就更加的容易了。 现在的中国，进入了更高层次的“资本经济”的时代。 什么是“资本经济”时代呢？简而言之，它就是在市场经济的基础上加了一根“杠杆”，在物理学上“杠杆”的作用是利用“力臂”将“力量”放大，从而可以翘起更大质量物体。经济上多了这一根杠杆，其活动空间和灵活性都大大增强，这也叫“资本思维”。今后的中国人必须深刻理解和运用“资本思维”这个工具。 资本思维 要想学会“资本思维”，必须先来深刻理解一下什么是“资本”。“资本”仅仅是指钱吗？不是。资本是对资源的“支配权”，通过资源支配带来更多的支配权叫“资本运作”，通过“资本运作”优化和配置社会财富，实现社会效率的最大化就是“资本运作”的社会价值。 因为资本有趋利性和增值性，追求利润最大化。这就会促使社会资源的配置朝着效率、效益最大化的方向上行。社会资源将依次流入最有效率的国家和地区、最有效率的产业、最有效率的企业、最有效率的项目、最有效率的个人。资本的逐利促进资源的优化，资源的优化顺势产生新的资本，并且不断产生新的机会，如此一边循环一边膨胀。 比如，在物理学上，石墨和金刚石是同素异型体，它们都属于碳元素形成的单质，但是物理性质大不相同，价值也天壤之别，就是因为他们的组成结构不同而已。 所以资本思维的精髓是结构重组。即对资源的分子进行时空和结构上的调整，从而产生由“石墨”到“金刚石”的增值效果。宏观方面的资本运作是对全社会的资源重组，比如中国的国企重组，将大大改变中国经济的结构，提升整个社会的运作效率。而当一个社会经济依靠“资本运作”来运转时，就步入了“资本经济”时代。 这里强调一点，我所说的并不是什么危言损听，或者是什么不靠谱，而是很多的现象都证明了，如果说你有具体的不懂，或者细节问题的话，可以加入我个人的创业交流群：四九四零四九七八九，验证码：知乎创业。欢迎一起探讨，共同创业，好了我继续分享。 从经济层面讲，今后社会上只有三类人 第一，资源者。他们是资源的最直接拥有者，依靠出卖自己的资源生存，比如农民靠耕地、工人靠体力、医生靠技能、作家靠写作，还有老师律师等等。 第二，配置者。资源是谁的不重要，关键要有资源配置权。这类人依靠配置资源挣钱，从事资源的投入-整合-运营-产出工作，以企业家为主，创业者也属于此类。 第三，资本家/投资人。他们离资源最远，但是所有资源却统统归他们掌控，他们只躲在幕后玩操作游戏。风险投资者就属于此类人，比如孙正义投资马云，阿里巴巴上市使他大获成功。资本家无国界，他们可以控制全球资源流向；可以通过金融体系支配大量别人的资产。 所以，资源名义上都是资源者的，实际上都是资本家的。看一个人能量多大，关键是他能配置多少资源。 按照这三种不同性质的角色扮演，今后的个人如何获得财富？无非只有三条渠道：出售资源、配置资源、掌握资本。 1、资源者（普通人） “资源者”通过出售自己资源生存，也就是资源者的技能，即：时间+体力，这也是社会上分布最多的人群。 所以一般普通人只能找一家企业工作，出售自己本身换来财富。然而普通人的时间、体力都是相差无几的，他们能够出售的资源都是差不多的，于是为了让自己的资源卖上好价钱，就只能提升自己的技能水平和熟练水平。 这时一个普遍的做法就是读书，这就是为什么父母们都希望自己的孩子好好读书，为什么清华北大的毕业生一般会比没有文化的人起薪高一些。 但是现在文凭带来的技能差距差别越来越小，一个普通的一本学生与二本学生已经没有什么本质的差别，反而不如蓝翔挖掘机学的好的人附加价值高，这是因为前者数量多，后者数量少，而且后者更加注重实践，供需关系决定了资源的价格，因此读书无用论早就开始流行。 所以，如果你只是一个普通人，要么通过读书获得更高、更稀罕的的技能价值；要么通过爱思考、会做人、大量实践提高自己实践能力。 另外，对于“资源者”来说，还有天生稀罕资源，比如外貌。长的好看的普通人，可以在日常的婚配、工作、生活中获得很多额外的财富；如果长的好看再加上运气好就可以进入演艺圈，成为明星之后自己的资源就成了稀缺资源，资源的价格远远高于一般人！ 但是外貌在一般情况下难以改变“资源者”的本质处境，只能略微提升。王宝强就算是健身+保养+专业造型设计，也是无法从外貌上超越刘德华的，所以他是傻根，华仔是神偷。而且外貌这种资源不一定是越漂亮越好，王宝强和黄渤的外貌特质也是他们成功不可或缺的一部分。 所有的普通工人、白领、职业经理人、甚至到当年的“打工皇帝”唐骏、各大明星，都属于“资源者”。这种人的特点是，其获得财富是有限的。 他们有时辛苦了一辈子，但是遇到家人生一场大病几乎就会崩溃，有的为了供养孩子、病人需要打三份工，这是非常心酸的。职业经理人赚的再多也是有数的、过气的明星过的不如普通人等。 当然，有的人天生就拥有稀缺资源。比如富二代，生下来就可以继承一批遗产这种稀缺资源。再比如明星的孩子，天生就获得了媒体关注的稀缺资源；再比如某人住在市中心的破院子里，只要拆迁就可以获得一大笔财富；天生获得了位置的稀缺资源，或者你运气非常好，买彩票中了奖，也是享受到了“好运”的稀缺资源。 这类财富，可遇而不可求，只能靠运气。而且这些好运的“资源者”往往不懂如何经营资源，他们的财富不具可持续性，不能增值扩张，甚至往往是被浪费的，明星和富二代寂寞了会吸毒，遗产会坐吃山空，大奖也会挥霍完毕，拆迁款往往用于赌博…… 当然还有最后一条没有说，就是出售风险，如果愿意承担坐牢、死亡的风险，去偷、去抢、去骗，曾经看到一篇新闻，某人通过抢银行获得了数百万巨款，然后潜逃、隐姓埋名，做起了房地产生意，几年后家产过亿，同事也东窗事发。因此如果通过这种渠道赚钱，你获取的财富也会增加，但是承担的风险也会增加，最后还是不划算。 2. 配置者（企业主） 这种人不是资源的直接拥有者，他们往往通过脑力去设计资源的配置，通过优化资源去赚钱，企业家就属于这一类。 在奴隶社会最重要的生产力要素是“人力”（即：奴隶）；封建时代的最重要的生产力要素是“土地”，而资本时代最重要的生产力要素是“资本”，资本的本质就是资源的配置。 从定义上来讲，企业家是从事资源的组织、管理并承担经营风险的人。企业家的收入跟他配置的效率成正比，上不设限。但同时也要为自己的资源配置承担风险，下限就是破产。 为什么很多人想去创业呢？就是因为他们想从第一类人努力攀爬到第二类人。一旦从“资源者”升级到“配置者”，就意味着不用再出卖自己的技能，而是开始经营自己的思想和智慧，人身和经济都实现了自由，从而实现人格上的自由。 但是并不是所有的“资源者”都适合去创业。他们要具备一定的文化、眼光、魄力、创新力、机遇和资本。配置者是一个社会最重要的群体，他们的素质和数量决定了一个社会的资源配置效率，代表了生产力水平。配置者非常需要创新精神，所谓创新就是他们对新产品、新市场、新的生产方式、新组织的开拓以及新的原材料来源的控制调配。 这里我们需要提到中国企业家的更新换代。30多年前，中国开始第一次改革开放，那时整个中国百废俱兴，当时的大环境就是最好的机遇，只要大胆出来闯荡的人，即使没有文化、没有见识，都成了企业家，这是当时的环境造成的。 而如今，中国进行改革开放的深化，这个时候的中国已经发生天翻地覆的变化，此时也对企业家的素质提出了更高的要求。比如在欧美和日本，企业家始终是社会的精英阶层才可以担任。而接下来的中国，如果没有一定的文化素养、理想追求，以及对创新的深刻理解，很难再成为社会的“配置者”。因此，中国的企业家正在更新换代，一些90后创业者纷纷走近我们视野，很多老的企业家也自愿退出历史舞台，这是时代的发展，也是一种必然！ 当然，这些素养也都是可以后天创造的，比尔•盖茨在发家之前已经做了7年的程序员。所有后天的努力，“资源者”完全可以转换到“配置者”。不过，获取财富只是他们成功的标志之一，对事业的忠诚和对社会的责任，才是企业家的“顶峰体验”和不竭动力。 3. 资本家/投资人（幕后掌握） 这个社会的财富，看似是属于分散的“资源者”的，实际上却是归“配置者”享用的。但在本质上，更多的是属于资本家的！ 资本家的定义是：以资本运作为业的人。第二次工业革命后，掌握了科技与运用的企业家们，能迅速的积累起巨额的财富，他们的企业对一个国家产生极大的影响，这些企业组成了这个国家的经济命脉，企业为了获得高额利润，通过相互协议或联合，对一个或几个部门商品的生产、销售和价格进行操纵和控制，于是形成了垄断，而这时的“企业家”开始坐在了幕后操纵这一切，演变成了“资本家”。 “资本家”跟“企业家”的最大区别是：资本家不直接参与企业的经营和管理，而是在幕后操纵企业宏观思路，企业的产品是各类消费品等，而资本家的产品就是各个企业。通过投资、入股、并购、重组的方式，将一个企业的未来把控到自己手中，孙正义投资了马云，成全了阿里巴巴，马云就是企业家，而孙正义就是资本家。孙正义手里有N个马云，成了日本首富。再比如巴菲特专门坐在老家做投资操纵他的布局，他也是资本家。 美国是自由市场经济，但是为什么叫“资本”主义社会呢？而不叫“自有市场主义”社会呢？因为在这样的社会，“资本”是度量和决定一切的标准。在中国的古代，你富甲一方也没用，官员随时能把你家产抄净，你有钱也要去给权力行贿，去买官。而你只要有了权力，哪怕身无分文，一样生活富庶、吃喝不愁，所以那时是官本位。 某公司曾经说过，自己从不做研发，让市场上那些小公司去研发，如果一旦成功，就花钱买过来，如果不卖，就花钱把这个公司的几个核心挖过来。这就是资本主义。（当然无视知识产权是有问题的，正确的做法是花钱买过来） 如果你有了1亿元的资本，你可以花一千万雇上这个国家最聪明的一批人，把你的资本从1亿变成2亿，你躺在床上就赚了九千万。而这一切，只因为你在从事资本运作，你只需要够聪明和有魄力，不需要有力气、不需要花时间、更不需要长得漂亮。 我们需要明白的是：第3种人赚的钱就比第2种人多，第2种人赚的钱比第1种人多。因此，第1种人在努力进化到第2种人，而第二种人在拼命进化到第3种人。 中国天生具有资本的人是极少的，大部分第3种人都是从第1种人或者第2种人进化过来的，虽然目前这种进化已经越来越难了，但还不是没有希望，因为以后会更加的困难。这就是阶级的固化，阶级间流动的减少。 每个人都在玩命探索的方法，有的人成功了，有的人失败了。原因就只有两点：你的头脑有多聪明？或者你积累的资本有多少？ 你想到了一个可以改进手机的idea，而且你觉得这个idea可以赚很多钱，那你要问自己，你有没有这个资金去运作这个idea？同样的idea，三星华为都可以支配更多的资金，去雇佣更好的工程师，去更好的推广，你确定不是去给这些资本拥有者蹚雷？或者是正在走向一条已经无数人走过的死胡同？具体举个例子，你做软件开发，天使投资人会不会问你一句话：“如果某巨头山寨你怎么办？” 答案是：你不打工你能干啥？你以为你出来干别的就能赚钱？几年前网上疯传送快递赚的多，我就嗤之以鼻，这种没有门槛的行业是不可能赚的多的。你愿意赚1万干这个，我分分钟找一个赚九千就干的，我再找一个赚八千的你信不信。最后，无论你是送快递还是摆摊，无论你是卖肉夹馍还是搞IT，你都会被拉到一个门槛平均收入。因为IT需要学习，赚的多一些；快递比较辛苦，赚的比IT少，可是还是比打扫卫生的多一些，就是这样。 那到底怎么样从第1种人进化到第3种人？ 第一步，你要进行资本积累，你愿意打工也好，愿意自己做产品也好（有的人就自认为在创业了），先完成资本积累。这一步最重要，也是发挥大家的想象力和实力的时候了，摆地摊、开淘宝、做网站、做APP、炒股票、海外代购、开设计工作室、卖肉夹馍、给幼儿园摄影的，等等等等，没有最好只有更好。一句话，这步就是出卖你的个人资源，就看你卖不卖的上价了，多学习吧，即使不为了文凭；多辛苦吧，只要不是出卖健康。 第二步、善用资本，用资本赚钱。怎么用资本赚钱？问你们个问题你们就明白了。如果你家开了个小饭店，每个月能赚1万，但是需要个厨师。你自己炒菜水平很高，如果自己当厨师，饭店每月净赚1万；如果雇佣一个厨师，每月花8千，饭店净赚2千。你怎么选择？ 答案：雇一个厨师！这样你只要能用每月一千利息的贷款，再盘下一个饭店，那个饭店也能净赚一千了。（补充：这个饭店赚两千，还利息一千，净赚一千，数学不好的不要再给我留言了好不，知乎跟微博一个水平么）。而你，只需要这样盘下100个饭店，每个月就能净赚10万，而你这时，却在国外旅游，成了第3种人。 很多人一直在打工，他们没有成为第3种人，很好理解。但是改革开放之后做买卖的，也有很多人还是没有钱，就是因为，他们自己做厨师，自己的妹妹做服务员，自己的老妈管收银，仅此而已。 所以，以后问自己怎么成为第3种人，就是一句话：“不要自己炒菜，雇一个厨师”。如果能用资本去赚1块钱，也比用出售自己的体力赚100块钱更符合金融思维。 另外，聪明和资本，如果你只具有其中一点，记得，要找只有另一点的人去合作，他们也在等着你！ 再另外，即使是具有同样特点的人，其财富也是有差别的。同样出卖自己劳动力或者具有同样资本的人，其付出的脑力、体力不一样，所获得的收益也是不同的。就是说，两个一模一样的打工仔或者超级富二代，一个努力思考、肯付出辛苦，另一个成天打游戏睡觉，前一类还是要比后一类财富来的多的。但是聪明刻苦的打工仔总与打游戏睡觉的超级富二代比，就是给自己的人生添堵而已。 富人：是想到某些事儿，目标定下了，并为之开始筹措资源。因为这样的思维，没什么可以拦住他们做事，没钱可以借，没人可以请，不懂可以外包，限制可以规避，敌人可以和好，对手可以买通。 所谓，性非异也，善假于物也。 普通人的提升 同时，再强调一点，如果你是个普通人，或者自认是个普通人，但是又有上进心，不如务实一点，脚踏实地的往前走。 曾经有个公司的公关部经理，儿子已经5岁，她每天要上班、做家务、带孩子。但她拥有人事部二级口译证书，每个月都有天南海北的会议翻译任务，还兼任这家口译中心的导师。 打开她的博客，已经更新了500多页，有2000多个帖子，全部都是每天她自己做口译练习的文章，平均每天两篇长的一篇短的。她坚持做这件事已经快10年了，非专业出身的她因为爱好英语而一直努力。 她说，10年前，她曾经看到一份调查报告，一个人如果要掌握一项技能，成为专家，需要不间断地练习10000个小时。当时她算了一笔账，如果每天练习5个小时，每年300天的话，那么需要7年的时间，一个人才能掌握这项技能。 她说：“幸运的是，我知道自己想掌握什么技能，我只需要立马投入干起来就行了，我没有5个小时的时间，我每天只能学习3个小时，现在已经快10年了，我觉得自己差不多已经掌握了这个技能吧。” 再比如，披头士乐队在成名前已经参加过1200场演出。可是为什么你做了10年公务员还只是一名小职员？为什么在家里做了7年的饭，没变成特级大厨，反而发现婚姻到了7年之痒呢？ 那是因为，你没有投入精力和热情来练习一项技能。每天上班只是看报纸、上网、应付各种琐碎任务，每天做饭只是为了让家庭正常运转，并不用专业的眼光看待这件事。 不要再哀叹大学毕业之后专业就丢了。如果从初中开始算起，12年的学校教育，就算每天学习一门技能2小时，一年300天，你也只有7200小时，还有2800小时的缺口；就算你毕业后每天坚持练习1小时，你需要10年。 为什么理工科的人更容易成功？只要他们毕业后专业对口，还是做的那点事，那么他们就等于1天8小时都在练习。这2800小时，只需要1年多就填补了。可我们很多人，工作的内容并不是在练习技能，大部分是应对琐碎的人和事，实际上，是在荒废人生。 也许你会说，我是平凡人，我不想成为什么家，只想安安分分过日子。那只是你的错觉，时间在流逝，你每天重复重复再重复的那些行为，就是在塑造你，你不想成为什么人，可是你注定会成为什么人。 每天5个小时，如果你是用来看韩剧、翻手机、玩游戏，那么7年后，你会变成一个生活的旁观者，你最擅长的就是如数家珍地说起别人的成功和失败，自己身上找不到任何可说的东西。 花1分钟想一想，曾经最想做的事情是什么，然后每天去做这件事。7年后，你会发现你已经可以靠这件事出去混饭吃了。 哪怕你喜欢逛街呢，你规定自己每天逛街3小时试试？可能一开始你觉得很高兴，每天如此，你会发现无聊。再坚持下去，你就开始琢磨了，我逛街还能发现点什么？还能搞出点什么花样？坚持下去，7年之后，你可能会成为时尚达人、形象设计专家、街拍摄影师、服装买手…… 发自我的华为手机","categories":[],"tags":[{"name":"乱七八糟","slug":"乱七八糟","permalink":"https://vlwq.github.io/tags/%E4%B9%B1%E4%B8%83%E5%85%AB%E7%B3%9F/"}]},{"title":"自由恋爱","slug":"2015/20151123","date":"2015-11-23T02:36:00.000Z","updated":"2017-08-27T05:10:53.537Z","comments":true,"path":"2015/11/23/2015/20151123/","link":"","permalink":"https://vlwq.github.io/2015/11/23/2015/20151123/","excerpt":"恋爱对于人类来说存在着负反馈机制： 一，人类的活动总体遵循着一分耕耘一分收获的原则。但恋爱则不然。你在恋爱中投入得越多，对方往往越不会在乎你，甚至还会觉得你很粘很烦。这是几乎任何其他社会活动所不具有的特质。有人说爱情需要经营，这也是纸上谈兵，你真的去谈几场恋爱就会发现所谓经营很多时候是无用功甚至负作用。你很难把握正确的度。这也是为什么情侣之间吵架如此普遍频繁的原因之一。 二，越有趣、有才、有能力的人，在恋爱市场上越抢手。然而，一旦这个人沉迷于恋爱的卿卿我我，他的智商、能力、才华都会下降（除了写诗的才华）。所以，恋爱行为对于社会来讲收益是负的。 三，同样是追求快感，很多时候追求自身的发展、完善、体验，要比恋爱的快感更大；而恋爱的快感总体是边际效应递减的，初恋快感最大，恋爱开始时几天快感最大，之后迅速衰减。这和通常社会活动那种越钻研深入越有快感的现象，又是相反的。当然，饮食等满足生理需要的行为也存在边际效应递减。","text":"恋爱对于人类来说存在着负反馈机制： 一，人类的活动总体遵循着一分耕耘一分收获的原则。但恋爱则不然。你在恋爱中投入得越多，对方往往越不会在乎你，甚至还会觉得你很粘很烦。这是几乎任何其他社会活动所不具有的特质。有人说爱情需要经营，这也是纸上谈兵，你真的去谈几场恋爱就会发现所谓经营很多时候是无用功甚至负作用。你很难把握正确的度。这也是为什么情侣之间吵架如此普遍频繁的原因之一。 二，越有趣、有才、有能力的人，在恋爱市场上越抢手。然而，一旦这个人沉迷于恋爱的卿卿我我，他的智商、能力、才华都会下降（除了写诗的才华）。所以，恋爱行为对于社会来讲收益是负的。 三，同样是追求快感，很多时候追求自身的发展、完善、体验，要比恋爱的快感更大；而恋爱的快感总体是边际效应递减的，初恋快感最大，恋爱开始时几天快感最大，之后迅速衰减。这和通常社会活动那种越钻研深入越有快感的现象，又是相反的。当然，饮食等满足生理需要的行为也存在边际效应递减。 自由恋爱在中国历史上的地位几乎是昙花一现： 一，在传统社会一直持续到改革开放之前，基本都是封建包办婚姻、党组织包办婚姻，自由恋爱只是极少数人的奢侈品，而不属于广大人民群众。 二，在改革开放一直到现在，自由恋爱开始逐渐普及，然而： 三，之后的发展趋势是自由恋爱逐渐衰竭。因为人们越来越看重性、财富地位。房产这座大山导致很多人的婚姻都不是基于自由恋爱。自由恋爱逐渐萎缩，基本只存在于学校和办公室角落——如果偷情也能叫恋爱的话。微信陌陌聊天约炮一夜情能叫恋爱吗？那是赤裸裸的性。 不可否认，性和吃饭睡觉一样是人类的本能。但有些人认识到了这种负反馈机制，也认识到了社会外在因素给自由恋爱带来的局限性和枷锁。所以自然就逐渐丧失了对于恋爱的需求，只剩下了性的原始本能。","categories":[],"tags":[{"name":"乱七八糟","slug":"乱七八糟","permalink":"https://vlwq.github.io/tags/%E4%B9%B1%E4%B8%83%E5%85%AB%E7%B3%9F/"}]},{"title":"过去","slug":"2015/20150701","date":"2015-07-01T02:36:00.000Z","updated":"2017-08-27T05:10:25.069Z","comments":true,"path":"2015/07/01/2015/20150701/","link":"","permalink":"https://vlwq.github.io/2015/07/01/2015/20150701/","excerpt":"不要害怕，很多你怕的事情并不会发生。不要想太多，很多事情你永远想不到。没事别给自己找事，有事不要怕事。直接行动会带来比设想万全计划带来更直接的改变。因为行动会构成既定现实的一部分，而想一堆不会。","text":"不要害怕，很多你怕的事情并不会发生。不要想太多，很多事情你永远想不到。没事别给自己找事，有事不要怕事。直接行动会带来比设想万全计划带来更直接的改变。因为行动会构成既定现实的一部分，而想一堆不会。 能处理事情，需要复杂。能过得开心，需要简单。如果处理不了事情，那就复杂一些。如果过得不快乐，那就丢掉一些。 如果焦虑或者烦躁，就减少日程。计划排的太满超出自我能力后，会进入拖延什么也做不了。 如果你觉得社交很累很有负担很麻烦，一群很low的人说着很low的话。那你可以尝试着把社交变为一种放松的方式。别把社交当舞台当工作，拼命想要表现好，你就当你是去玩的就好了。把平常很多想说的废话说了，大家一起low一会儿，开心完了放松了就可以开始死正经的工作啦。 想当社交核心，你不用表现出社交达人的样子，你只需要一个一个拿下。跟一个一个人慢慢处理好关系，当你和人群中大多数的人一步一步建立起关系的时候，你就是核心。 一定要给自己放松和休息留出时间。人是需要一些时间用来发呆，睡觉，说废话，拖延的。如果你连这些时间都想要压榨用来努力，你的心理生理平衡会被打破。不按时定期娱乐和放松，时间久了，你会付出一直高速运转带来的代价。那就是整个人状态的下滑和效率降低。 哪怕对自己的能力很自信，也不要一开始就上最大强度最高难度。循序渐进会让你走的更稳。想一步登天会直接挫伤你的自信。 一鼓作气，再而衰，三而竭。做到一半了，千万别放弃太久。不断重启很耗电的～ 通过情绪进行自我检查。一般能特别触动你负面情绪的事情，指向些你内心的伤口或者不合理的观点。比如有人攻击了你，你非常愤怒。很可能意味着，你的想法在一定程度上被他说中了。 如果你遇到了挫折，不用全部否定自己的努力和成果。也不用改掉自己所有的缺点，更不用颠覆自己本有的个性。你只需要做出一丁点的调整，你的缺点就能变成你独有的优势。 不要自责。很多事情的发生并不是你的错。只有保护好自己的自信，不陷入自我怀疑，你才有力量重新站起来。对自己好一点，你自己是一切的开始。 不要拉低自己的底线。不要在灰色地带游走。出卖掉的东西，想要再买回来就很难了。有的时候你会遇到一些拉低自己底线而获得一些利益的人。他们看似没有付出什么代价就得到了一些本不该得到的东西。好像坏人也并没有收到惩罚。但坏的行事手段，会加大坏的结果出现的概率。一次两次三次，也许谁都没发现。十次八次九次，次次幸免于难怎么可能？同样，做好事也是一样的道理，也许一次两次三次你并没有获得什么好处。十次八次九次，做的越多，概率越大。你会更容易遇到幸福。 目标是类似于月亮的东西。在你累的时候，抬头看看月亮，可以重新鼓起勇气。月亮的光芒会一直照着你前进的路。不要一直仰望着它，脖子会酸，会停住脚步，会掉进坑里。更不要把月亮背在身上，你会被压垮。 对一个人好的最佳方式，就是努力。你成功了，有能力了，你收益，所有的人也跟着你收益。而停下自己的脚步用已有的东西低效的付出，不仅你会累垮，周围的人对同样的东西的一再刺激也会麻木不知感恩。 挫折无法避免。挫折是常态。适当的挫折和压力会让你整个人趋于平稳。放心吧，不会只有你一个人那么惨的，大家都是这样。很多人看似一帆风顺，只不过是因为他们没有把那些事说出来罢了。挫折只是个小路障，不要一直对这个障碍物发火，或者怀疑自己怎么会遇到这种事。你要做的就是绕开它，处理它，处理掉你就又可以一帆风顺。 不要太计较。不要觉得别人心机重心思多，能活到现在这个岁数的人，多多少少都会有些自己的算盘和想法。这是正常的。你也有。太单纯的人，是活不下去的。 无论是多么开心的事情，最多过两个月，你就没那么开心了。无论是多么难过的事情，最多过两月，你也会好很多。所以，开心的时候就尽情的开心吧，因为它很快就会过去，所以才值得珍惜。悲伤的时候也不要害怕，因为它也会很快的过去。 我有一个独家小秘方，能让你更快乐。那就是写日记。写你最悲伤的，最痛苦的，最羞于启齿的，最无法接受的痛苦的事。重复写一件事也可以，换着事儿写也可以。以前发生的也行，最近发生的也行。每天写一会儿，到第四天左右，你可能觉得更糟糕了。因为你在重新面对这些事情。到一周以后，通过这样的过程，你的负面能量得到了一个出口，当他们被疏导，发泄后，就不会再影响你了。你的经验也会被提纯，整理，你会有更多的掌控力。在那些痛苦的事情面前，你不再无助和失意，你不仅放下了，走出来了，你还获得了你应该得到的报酬。 负面情绪和正面情绪是同一种机制在运作的。你压抑了自己痛苦的同时，你快乐的情绪也会被压制。所以，允许自己成为一个人吧。编辑于 2015-06-23","categories":[],"tags":[{"name":"乱七八糟","slug":"乱七八糟","permalink":"https://vlwq.github.io/tags/%E4%B9%B1%E4%B8%83%E5%85%AB%E7%B3%9F/"}]}],"categories":[],"tags":[{"name":"node","slug":"node","permalink":"https://vlwq.github.io/tags/node/"},{"name":"docker","slug":"docker","permalink":"https://vlwq.github.io/tags/docker/"},{"name":"base","slug":"base","permalink":"https://vlwq.github.io/tags/base/"},{"name":"js","slug":"js","permalink":"https://vlwq.github.io/tags/js/"},{"name":"linux","slug":"linux","permalink":"https://vlwq.github.io/tags/linux/"},{"name":"mongoose","slug":"mongoose","permalink":"https://vlwq.github.io/tags/mongoose/"},{"name":"html5","slug":"html5","permalink":"https://vlwq.github.io/tags/html5/"},{"name":"高程","slug":"高程","permalink":"https://vlwq.github.io/tags/%E9%AB%98%E7%A8%8B/"},{"name":"nginx","slug":"nginx","permalink":"https://vlwq.github.io/tags/nginx/"},{"name":"github","slug":"github","permalink":"https://vlwq.github.io/tags/github/"},{"name":"guagua","slug":"guagua","permalink":"https://vlwq.github.io/tags/guagua/"},{"name":"乱七八糟","slug":"乱七八糟","permalink":"https://vlwq.github.io/tags/%E4%B9%B1%E4%B8%83%E5%85%AB%E7%B3%9F/"},{"name":"健康","slug":"健康","permalink":"https://vlwq.github.io/tags/%E5%81%A5%E5%BA%B7/"}]}