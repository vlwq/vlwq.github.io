<!DOCTYPE html>
<html lang="zh-CN">
<head>
  <meta charset="UTF-8">
<meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=2">
<meta name="theme-color" content="#222">
<meta name="generator" content="Hexo 5.4.1">
  <link rel="apple-touch-icon" sizes="180x180" href="/vlwq/vlwq.github.io/images/apple-touch-icon-next.png">
  <link rel="icon" type="image/png" sizes="32x32" href="/vlwq/vlwq.github.io/images/favicon-32x32-next.png">
  <link rel="icon" type="image/png" sizes="16x16" href="/vlwq/vlwq.github.io/images/favicon-16x16-next.png">
  <link rel="mask-icon" href="/vlwq/vlwq.github.io/images/logo.svg" color="#222">

<link rel="stylesheet" href="/vlwq/vlwq.github.io/css/main.css">


<link rel="stylesheet" href="/vlwq/vlwq.github.io/lib/font-awesome/css/all.min.css">

<script id="hexo-configurations">
    var NexT = window.NexT || {};
    var CONFIG = {"hostname":"vlwq.github.io","root":"/vlwq/vlwq.github.io/","scheme":"Pisces","version":"7.8.0","exturl":false,"sidebar":{"position":"left","display":"post","padding":18,"offset":12,"onmobile":false},"copycode":{"enable":false,"show_result":false,"style":null},"back2top":{"enable":true,"sidebar":false,"scrollpercent":false},"bookmark":{"enable":false,"color":"#222","save":"auto"},"fancybox":false,"mediumzoom":false,"lazyload":false,"pangu":false,"comments":{"style":"tabs","active":null,"storage":true,"lazyload":false,"nav":null},"algolia":{"hits":{"per_page":10},"labels":{"input_placeholder":"Search for Posts","hits_empty":"We didn't find any results for the search: ${query}","hits_stats":"${hits} results found in ${time} ms"}},"localsearch":{"enable":false,"trigger":"auto","top_n_per_article":1,"unescape":false,"preload":false},"motion":{"enable":true,"async":false,"transition":{"post_block":"fadeIn","post_header":"slideDownIn","post_body":"slideDownIn","coll_header":"slideLeftIn","sidebar":"slideUpIn"}}};
  </script>

  <meta name="description" content="高程笔记一">
<meta property="og:type" content="article">
<meta property="og:title" content="高程笔记1">
<meta property="og:url" content="https://vlwq.github.io/2017/06/09/2017/20170609/index.html">
<meta property="og:site_name" content="Andrew的博客">
<meta property="og:description" content="高程笔记一">
<meta property="og:locale" content="zh_CN">
<meta property="article:published_time" content="2017-06-09T02:36:00.000Z">
<meta property="article:modified_time" content="2017-07-16T04:15:32.006Z">
<meta property="article:author" content="Andrew Li">
<meta property="article:tag" content="高程">
<meta name="twitter:card" content="summary">

<link rel="canonical" href="https://vlwq.github.io/2017/06/09/2017/20170609/">


<script id="page-configurations">
  // https://hexo.io/docs/variables.html
  CONFIG.page = {
    sidebar: "",
    isHome : false,
    isPost : true,
    lang   : 'zh-CN'
  };
</script>

  <title>高程笔记1 | Andrew的博客</title>
  






  <noscript>
  <style>
  .use-motion .brand,
  .use-motion .menu-item,
  .sidebar-inner,
  .use-motion .post-block,
  .use-motion .pagination,
  .use-motion .comments,
  .use-motion .post-header,
  .use-motion .post-body,
  .use-motion .collection-header { opacity: initial; }

  .use-motion .site-title,
  .use-motion .site-subtitle {
    opacity: initial;
    top: initial;
  }

  .use-motion .logo-line-before i { left: initial; }
  .use-motion .logo-line-after i { right: initial; }
  </style>
</noscript>

</head>

<body itemscope itemtype="http://schema.org/WebPage">
  <div class="container use-motion">
    <div class="headband"></div>

    <header class="header" itemscope itemtype="http://schema.org/WPHeader">
      <div class="header-inner"><div class="site-brand-container">
  <div class="site-nav-toggle">
    <div class="toggle" aria-label="切换导航栏">
      <span class="toggle-line toggle-line-first"></span>
      <span class="toggle-line toggle-line-middle"></span>
      <span class="toggle-line toggle-line-last"></span>
    </div>
  </div>

  <div class="site-meta">

    <a href="/vlwq/vlwq.github.io/" class="brand" rel="start">
      <span class="logo-line-before"><i></i></span>
      <h1 class="site-title">Andrew的博客</h1>
      <span class="logo-line-after"><i></i></span>
    </a>
      <p class="site-subtitle" itemprop="description">practice makes perfect</p>
  </div>

  <div class="site-nav-right">
    <div class="toggle popup-trigger">
    </div>
  </div>
</div>




<nav class="site-nav">
  <ul id="menu" class="main-menu menu">
        <li class="menu-item menu-item-home">

    <a href="/vlwq/vlwq.github.io/" rel="section"><i class="fa fa-home fa-fw"></i>首页</a>

  </li>
        <li class="menu-item menu-item-tags">

    <a href="/vlwq/vlwq.github.io/tags/" rel="section"><i class="fa fa-tags fa-fw"></i>标签</a>

  </li>
        <li class="menu-item menu-item-archives">

    <a href="/vlwq/vlwq.github.io/archives/" rel="section"><i class="fa fa-archive fa-fw"></i>归档</a>

  </li>
  </ul>
</nav>




</div>
    </header>

    
  <div class="back-to-top">
    <i class="fa fa-arrow-up"></i>
    <span>0%</span>
  </div>


    <main class="main">
      <div class="main-inner">
        <div class="content-wrap">
          

          <div class="content post posts-expand">
            

    
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="https://vlwq.github.io/2017/06/09/2017/20170609/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/vlwq/vlwq.github.io/assets/headimg/lwq.jpg">
      <meta itemprop="name" content="Andrew Li">
      <meta itemprop="description" content="此为博客一枚。">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Andrew的博客">
    </span>
      <header class="post-header">
        <h1 class="post-title" itemprop="name headline">
          高程笔记1
        </h1>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>

              <time title="创建时间：2017-06-09 10:36:00" itemprop="dateCreated datePublished" datetime="2017-06-09T10:36:00+08:00">2017-06-09</time>
            </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
        <p>高程笔记一</p>
<span id="more"></span>

<blockquote>
<p>JavaScript 是一种专为与网页交互而设计的脚本语言，由下列三个不同的部分组成：<br>ECMAScript，由 ECMA-262 定义，提供核心语言功能；<br>文档对象模型（DOM），提供访问和操作网页内容的方法和接口；<br>浏览器对象模型（BOM），提供与浏览器交互的方法和接口。</p>
</blockquote>
<pre><code>JavaScript 的这三个组成部分，在当前五个主要浏览器（IE、Firefox、Chrome、Safari 和 Opera）中都得到了不同程度的支持。其中，所有浏览器对 ECMAScript 第 3 版的支持大体上都还不错，而对ECMAScript 5 的支持程度越来越高，但对 DOM 的支持则彼此相差比较多。对已经正式纳入 HTML5 标准的 BOM 来说，尽管各浏览器都实现了某些众所周知的共同特性，但其他特性还是会因浏览器而异。
</code></pre>
<h4 id="lt-script-gt-定义了下列-6-个属性。"><a href="#lt-script-gt-定义了下列-6-个属性。" class="headerlink" title="&lt;script&gt;定义了下列 6 个属性。"></a><code>&lt;script&gt;</code>定义了下列 6 个属性。</h4><pre><code> async：可选。表示应该立即下载脚本，但不应妨碍页面中的其他操作， 比如下载其他资源或等待加载其他脚本。只对外部脚本文件有效。
 charset：可选。表示通过src属性指定的代码的字符集。由于大多数浏览器会忽略它的值，因此这个属性很少有人用。
 defer：可选。表示脚本可以延迟到文档完全被解析和显示之后再执行。 只对外部脚本文件有效。IE7 及更早版本对嵌入脚本也支持这个属性。
 language：已废弃。原来用于表示编写代码使用的脚本语言（如JavaScript、JavaScript1.2或VBScript）。大多数浏览器会忽略这个属性，因此也没有必要再用了。
 src：可选。表示包含要执行代码的外部文件。
 type：可选。可以看成是language的替代属性；表示编写代码使用的脚本语言的内容类型（也称为 MIME 类型）。虽然 text/javascript 和 text/ecmascript 都已经不被推荐使用，但人们一直以来使用的都还是text/javascript。实际上，服务器在传送JavaScript文件时使用的MIME类型通常是application/x–javascript，但在type中设置这个值却可能导致脚本被忽略。另外，在非IE浏览器中还可以使用以下值：application/javascript和application/ecmascript。考虑到约定俗成和最大限度的浏览器兼容性，目前type属性的值依旧还是text/javascript。不过，这个属性并不是必需的，如果没有指定这个属性，则其默认值仍为text/javascript
</code></pre>
<h4 id="XHTML运行script"><a href="#XHTML运行script" class="headerlink" title="XHTML运行script"></a>XHTML运行script</h4><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">&lt;script type=&quot;text/javascript&quot;&gt;&lt;![CDATA[</span><br><span class="line"> function compare(a, b) &#123;</span><br><span class="line"> if (a &lt; b) &#123;</span><br><span class="line"> alert(&quot;A is less than B&quot;);</span><br><span class="line"> &#125; else if (a &gt; b) &#123;</span><br><span class="line"> alert(&quot;A is greater than B&quot;);</span><br><span class="line"> &#125; else &#123;</span><br><span class="line"> alert(&quot;A is equal to B&quot;);</span><br><span class="line"> &#125;</span><br><span class="line"> &#125;</span><br><span class="line">]]&gt;&lt;/script&gt;</span><br></pre></td></tr></table></figure>



<h4 id="html文档模式"><a href="#html文档模式" class="headerlink" title="html文档模式"></a>html文档模式</h4><blockquote>
<p>标准模式</p>
</blockquote>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">&lt;!-- HTML 4.01 严格型 --&gt;</span><br><span class="line">&lt;!DOCTYPE HTML PUBLIC &quot;-//W3C//DTD HTML 4.01//EN&quot;</span><br><span class="line">&quot;http://www.w3.org/TR/html4/strict.dtd&quot;&gt;</span><br><span class="line">&lt;!-- XHTML 1.0 严格型 --&gt;</span><br><span class="line">&lt;!DOCTYPE html PUBLIC</span><br><span class="line">&quot;-//W3C//DTD XHTML 1.0 Strict//EN&quot;</span><br><span class="line">&quot;http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd&quot;&gt;</span><br><span class="line">&lt;!-- HTML 5 --&gt;</span><br><span class="line">&lt;!DOCTYPE html&gt;</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p>非标准模式</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">&lt;!-- HTML 4.01 过渡型 --&gt;</span><br><span class="line">&lt;!DOCTYPE HTML PUBLIC</span><br><span class="line">&quot;-//W3C//DTD HTML 4.01 Transitional//EN&quot;</span><br><span class="line">&quot;http://www.w3.org/TR/html4/loose.dtd&quot;&gt;</span><br><span class="line">&lt;!-- HTML 4.01 框架集型 --&gt;</span><br><span class="line">&lt;!DOCTYPE HTML PUBLIC</span><br><span class="line">&quot;-//W3C//DTD HTML 4.01 Frameset//EN&quot;</span><br><span class="line">&quot;http://www.w3.org/TR/html4/frameset.dtd&quot;&gt;</span><br><span class="line">&lt;!-- XHTML 1.0 过渡型 --&gt;</span><br><span class="line">&lt;!DOCTYPE html PUBLIC</span><br><span class="line">&quot;-//W3C//DTD XHTML 1.0 Transitional//EN&quot;</span><br><span class="line">&quot;http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd&quot;&gt;</span><br><span class="line">&lt;!-- XHTML 1.0 框架集型 --&gt;</span><br><span class="line">&lt;!DOCTYPE html PUBLIC</span><br><span class="line">&quot;-//W3C//DTD XHTML 1.0 Frameset//EN&quot;</span><br><span class="line">&quot;http://www.w3.org/TR/xhtml1/DTD/xhtml1-frameset.dtd&quot;&gt;</span><br></pre></td></tr></table></figure>



<p>ECMAScript 中有 5 种简单数据类型（也称为基本数据类型）：Undefined、Null、Boolean、Number<br>和 String。</p>
<blockquote>
<p>3 个函数可以把非数值转换为数值：Number()、parseInt()和parseFloat()。第一个函数，即转型函数Number()可以用于任何数据类型，而另两个函数则专门用于把字符串转换成数值。这 3 个函数对于同样的输入会有返回不同的结果。<br>Number()函数的转换规则如下。<br> 如果是 Boolean 值，true 和 false 将分别被转换为 1 和 0。<br> 如果是数字值，只是简单的传入和返回。<br> 如果是 null 值，返回 0。<br> 如果是 undefined，返回 NaN。</p>
</blockquote>
<h2 id="数值转换"><a href="#数值转换" class="headerlink" title="数值转换"></a>数值转换</h2><p>有 3 个函数可以把非数值转换为数值：Number()、parseInt()和 parseFloat()。第一个函数，即转型函数Number()可以用于任何数据类型，而另两个函数则专门用于把字符串转换成数值。这3个函数对于同样的输入会有返回不同的结果。Number()函数的转换规则如下。<br> 如果是 Boolean 值，true 和 false 将分别被转换为 1 和 0。<br> 如果是数字值，只是简单的传入和返回。<br> 如果是 null 值，返回 0。<br> 如果是 undefined，返回 NaN。<br> 如果是字符串，遵循下列规则：</p>
<blockquote>
<p> 如果字符串中只包含数字（包括前面带正号或负号的情况），则将其转换为十进制数值，即”1”会变成1，”123”会变成123，而”011”会变成11（注意：前导的零被忽略了）；<br> 如果字符串中包含有效的浮点格式，如”1.1”，则将其转换为对应的浮点数值 同样，也会忽略前导零）；<br> 如果字符串中包含有效的十六进制格式，例如”0xf”，则将其转换为相同大小的 十进制整数值；<br> 如果字符串是空的（不包含任何字符），则将其转换为 0；<br> 如果字符串中包含除上述格式之外的字符，则将其转换为 NaN。<br> 如果是对象，则调用对象的valueOf()方法，然后依照前面的规则转换返回的值。如果转换的结果是NaN，则调用对象的toString()方法，然后再次依照前面的规则转换返回的字符串值。根据这么多的规则使用Number()把各种数据类型转换为数值确实有点复杂。下面还是给出几个具体的例子吧。<br>var num1 = Number(“Hello world!”); //NaN<br>var num2 = Number(“”); //0<br>var num3 = Number(“000011”); //11</p>
</blockquote>
<h3 id="parseInt"><a href="#parseInt" class="headerlink" title="parseInt"></a>parseInt</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">var num1 = parseInt(&quot;10&quot;, 2); //2 （按二进制解析）</span><br><span class="line">var num2 = parseInt(&quot;10&quot;, 8); //8 （按八进制解析）</span><br><span class="line">var num3 = parseInt(&quot;10&quot;, 10); //10 （按十进制解析）</span><br><span class="line">var num4 = parseInt(&quot;10&quot;, 16); //16 （按十六进制解析</span><br></pre></td></tr></table></figure>

<h3 id="parseFloat"><a href="#parseFloat" class="headerlink" title="parseFloat"></a>parseFloat</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">var num1 = parseFloat(&quot;1234blue&quot;); //1234 （整数）</span><br><span class="line">var num2 = parseFloat(&quot;0xA&quot;); //0</span><br><span class="line">var num3 = parseFloat(&quot;22.5&quot;); //22.5</span><br><span class="line">var num4 = parseFloat(&quot;22.34.5&quot;); //22.34</span><br><span class="line">var num5 = parseFloat(&quot;0908.5&quot;); //908.5</span><br><span class="line">var num6 = parseFloat(&quot;3.125e7&quot;); //31250000</span><br></pre></td></tr></table></figure>

<h3 id="字符String"><a href="#字符String" class="headerlink" title="字符String"></a>字符String</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">\n 换行</span><br><span class="line">\t 制表</span><br><span class="line">\b 空格</span><br><span class="line">\r 回车</span><br><span class="line">\f 进纸</span><br><span class="line">\\ 斜杠</span><br><span class="line">\&#x27; 单引号（&#x27;），在用单引号表示的字符串中使用。例如：&#x27;He said, \&#x27;hey.\&#x27;&#x27;</span><br><span class="line">\&quot; 双引号（&quot;），在用双引号表示的字符串中使用。例如：&quot;He said, \&quot;hey.\&quot;&quot;</span><br><span class="line">\xnn 以十六进制代码nn表示的一个字符（其中n为0～F）。例如，\x41表示&quot;A&quot;</span><br><span class="line">\unnnn 以十六进制代码nnnn表示的一个Unicode字符（其中n为0～F）。例如，\u03a3表示希腊字符Σ</span><br></pre></td></tr></table></figure>


<h3 id="求模运算"><a href="#求模运算" class="headerlink" title="求模运算"></a>求模运算</h3><blockquote>
<p>求模（余数）操作符由一个百分号（%）表示，用法如下：<br>var result = 26 % 5; // 等于 1<br>与另外两个乘性操作符类似，求模操作符会遵循下列特殊规则来处理特殊的值：<br> 如果操作数都是数值，执行常规的除法计算，返回除得的余数；<br> 如果被除数是无穷大值而除数是有限大的数值，则结果是 NaN；<br> 如果被除数是有限大的数值而除数是零，则结果是 NaN；<br> 如果是 Infinity 被 Infinity 除，则结果是 NaN；<br> 如果被除数是有限大的数值而除数是无穷大的数值，则结果是被除数；<br> 如果被除数是零，则结果是零；<br> 如果有一个操作数不是数值，则在后台调用 Number()将其转换为数值，然后再应用上面的规则。</p>
</blockquote>
<h3 id="减法"><a href="#减法" class="headerlink" title="减法"></a>减法</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">var result1 = 5 - true; // 4，因为 true 被转换成了 1</span><br><span class="line">var result2 = NaN - 1; // NaN</span><br><span class="line">var result3 = 5 - 3; // 2</span><br><span class="line">var result4 = 5 - &quot;&quot;; // 5，因为&quot;&quot; 被转换成了 0</span><br><span class="line">var result5 = 5 - &quot;2&quot;; // 3，因为&quot;2&quot;被转换成了 2</span><br><span class="line">var result6 = 5 - null; // 5，因为 null 被转换成了 0</span><br></pre></td></tr></table></figure>

<h3 id="全等和不全等"><a href="#全等和不全等" class="headerlink" title="全等和不全等"></a>全等和不全等</h3><p>记住：null == undefined 会返回 true，因为它们是类似的值；但 null === undefined 会返回 false，因为它们是不同类型的值</p>
<h4 id="每个主要算术操作符（以及个别的其他操作符）都有对应的复合赋值操作符。这些操作符如下所示："><a href="#每个主要算术操作符（以及个别的其他操作符）都有对应的复合赋值操作符。这些操作符如下所示：" class="headerlink" title="每个主要算术操作符（以及个别的其他操作符）都有对应的复合赋值操作符。这些操作符如下所示："></a>每个主要算术操作符（以及个别的其他操作符）都有对应的复合赋值操作符。这些操作符如下所示：</h4><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"> 乘/赋值（*=）；</span><br><span class="line"> 除/赋值（/=）；</span><br><span class="line"> 模/赋值（%=）；</span><br><span class="line"> 加/赋值（+=）；</span><br><span class="line"> 减/赋值（=）；</span><br><span class="line"> 左移/赋值（&lt;&lt;=）；</span><br><span class="line"> 有符号右移/赋值（&gt;&gt;=）；</span><br></pre></td></tr></table></figure>



<h1 id="for-in语句"><a href="#for-in语句" class="headerlink" title="for-in语句"></a>for-in语句</h1><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">for-in 语句是一种精准的迭代语句，可以用来枚举对象的属性。以下是 for-in 语句的语法：</span><br><span class="line">for (property in expression) statement</span><br><span class="line">下面是一个示例：</span><br><span class="line">for (var propName in window) &#123;</span><br><span class="line"> document.write(propName);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>ECMAScript 对象的属性没有顺序。因此，通过 for-in 循环输出的属性名的顺序是不可预测的。<br>具体来讲，所有属性都会被返回一次，但返回的先后次序可能会因浏览器而异。</p>
<h3 id="js没有重载"><a href="#js没有重载" class="headerlink" title="js没有重载"></a>js没有重载</h3><blockquote>
<p>ECMAScript 函数不能像传统意义上那样实现重载。而在其他语言（如Java）中，可以为一个函数编写两个定义，只要这两个定义的签名（接受的参数的类型和数量）不同即可。如前所述，ECMAScirpt函数没有签名，因为其参数是由包含零或多个值的数组来表示的。而没有函数签名，真正的重载是不可能做到的。</p>
</blockquote>
<h1 id="基本类型和引用类型的值"><a href="#基本类型和引用类型的值" class="headerlink" title="基本类型和引用类型的值"></a>基本类型和引用类型的值</h1><blockquote>
<p>ECMAScript 变量可能包含两种不同数据类型的值：<strong>基本类型值和引用类型值</strong>。基本类型值指的是简单的数据段，而引用类型值指那些可能由多个值构成的对象。在将一个值赋给变量时，解析器必须确定这个值是基本类型值还是引用类型值。第 3 章讨论了 5 种基本数据类型：<strong>Undefined、Null、Boolean、Number 和 String</strong>。这 5 种基本数据类型是按值访问的，因为可以操作保存在变量中的实际的值。<br><strong>引用类型的值是保存在内存中的对象</strong>。与其他语言不同，JavaScript不允许直接访问内存中的位置，也就是说不能直接操作对象的内存空间。在操作对象时，实际上是在操作对象的引用而不是实际的对象。为此，引用类型的值是按引用访问的①。</p>
</blockquote>
<h2 id="在-Web-浏览器中，全局执行环境被认为是-window-对象"><a href="#在-Web-浏览器中，全局执行环境被认为是-window-对象" class="headerlink" title="在 Web 浏览器中，全局执行环境被认为是 window 对象"></a>在 Web 浏览器中，全局执行环境被认为是 window 对象</h2><h3 id="数组的栈方法"><a href="#数组的栈方法" class="headerlink" title="数组的栈方法"></a>数组的栈方法</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">var colors = new Array(); // 创建一个数组</span><br><span class="line">var count = colors.push(&quot;red&quot;, &quot;green&quot;); // 推入两项</span><br><span class="line">alert(count); //2</span><br><span class="line">count = colors.push(&quot;black&quot;); // 推入另一项</span><br><span class="line">alert(count); //3</span><br><span class="line">var item = colors.pop(); // 取得最后一项</span><br><span class="line">alert(item); //&quot;black&quot;</span><br><span class="line">alert(colors.length); //2</span><br></pre></td></tr></table></figure>

<h3 id="数组的重排序方法"><a href="#数组的重排序方法" class="headerlink" title="数组的重排序方法"></a>数组的重排序方法</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line">数组中已经存在两个可以直接用来重排序的方法：reverse()和 sort()。有读者可能猜到了，</span><br><span class="line">reverse()方法会反转数组项的顺序。请看下面这个例子。</span><br><span class="line">var values = [1, 2, 3, 4, 5];</span><br><span class="line">values.reverse();</span><br><span class="line">alert(values); //5,4,3,2,1</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">//自定义排序</span><br><span class="line">function compare(value1, value2) &#123;</span><br><span class="line"> if (value1 &lt; value2) &#123;</span><br><span class="line"> return 1;</span><br><span class="line"> &#125; else if (value1 &gt; value2) &#123;</span><br><span class="line"> return -1;</span><br><span class="line"> &#125; else &#123;</span><br><span class="line"> return 0;</span><br><span class="line"> &#125;</span><br><span class="line">&#125;</span><br><span class="line">var values = [0, 1, 5, 10, 15];</span><br><span class="line">values.sort(compare);</span><br><span class="line">alert(values); // 15,10,5,1,0</span><br></pre></td></tr></table></figure>
<h3 id="数组的splice"><a href="#数组的splice" class="headerlink" title="数组的splice"></a>数组的splice</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">var colors = [&quot;red&quot;, &quot;green&quot;, &quot;blue&quot;];</span><br><span class="line">var removed = colors.splice(0,1); // 删除第一项</span><br><span class="line">alert(colors); // green,blue</span><br><span class="line">alert(removed); // red，返回的数组中只包含一项</span><br><span class="line">removed = colors.splice(1, 0, &quot;yellow&quot;, &quot;orange&quot;); // 从位置 1 开始插入两项</span><br><span class="line">alert(colors); // green,yellow,orange,blue</span><br><span class="line">alert(removed); // 返回的是一个空数组</span><br><span class="line">removed = colors.splice(1, 1, &quot;red&quot;, &quot;purple&quot;); // 插入两项，删除一项</span><br><span class="line">alert(colors); // green,red,purple,orange,blue</span><br><span class="line">alert(removed); // yellow，返回的数组中只包含一项</span><br></pre></td></tr></table></figure>

<h3 id="数组迭代方法"><a href="#数组迭代方法" class="headerlink" title="数组迭代方法"></a>数组迭代方法</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"> every()：对数组中的每一项运行给定函数，如果该函数对每一项都返回 true，则返回 true。</span><br><span class="line"> filter()：对数组中的每一项运行给定函数，返回该函数会返回 true 的项组成的数组。</span><br><span class="line"> forEach()：对数组中的每一项运行给定函数。这个方法没有返回值。</span><br><span class="line"> map()：对数组中的每一项运行给定函数，返回每次函数调用的结果组成的数组。</span><br><span class="line"> some()：对数组中的每一项运行给定函数，如果该函数对任一项返回 true，则返回 true。</span><br><span class="line"></span><br><span class="line">var numbers = [1,2,3,4,5,4,3,2,1];</span><br><span class="line">var everyResult = numbers.every(function(item, index, array)&#123;</span><br><span class="line"> return (item &gt; 2);</span><br><span class="line">&#125;);</span><br><span class="line">alert(everyResult); //false</span><br><span class="line">var someResult = numbers.some(function(item, index, array)&#123;</span><br><span class="line"> return (item &gt; 2);</span><br><span class="line">&#125;);</span><br><span class="line">alert(someResult); //true</span><br></pre></td></tr></table></figure>

<h3 id="数组的归并方法"><a href="#数组的归并方法" class="headerlink" title="数组的归并方法"></a>数组的归并方法</h3><blockquote>
<p>这两个方法都接收两个参数：一个在每一项上调用的函数和（可选的）作为归并基础的初始值。传给reduce()和 reduceRight()的函数接收4个参数：前一个值、当前值、项的索引和数组对象。这个函数返回的任何值都会作为第一个参数自动传给下一项。第一次迭代发生在数组的第二项上，因此第一个参数是数组的第一项，第二个参数就是数组的第二项。</p>
</blockquote>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">使用 reduce()方法可以执行求数组中所有值之和的操作，比如：</span><br><span class="line">var values = [1,2,3,4,5];</span><br><span class="line">var sum = values.reduce(function(prev, cur, index, array)&#123;</span><br><span class="line"> return prev + cur;</span><br><span class="line">&#125;);</span><br><span class="line">alert(sum); //15</span><br></pre></td></tr></table></figure>


<h3 id="js没有重载（深入理解）"><a href="#js没有重载（深入理解）" class="headerlink" title="js没有重载（深入理解）"></a>js没有重载（深入理解）</h3><p>将函数名想象为指针，也有助于理解为什么 ECMAScript 中没有函数重载的概念。以下是曾在第 3<br>章使用过的例子。</p>
<h3 id="函数声明与函数表达式"><a href="#函数声明与函数表达式" class="headerlink" title="函数声明与函数表达式"></a>函数声明与函数表达式</h3><blockquote>
<p>本节到目前为止，我们一直没有对函数声明和函数表达式加以区别。而实际上，解析器在向执行环<br>境中加载数据时，对函数声明和函数表达式并非一视同仁。解析器会率先读取函数声明，并使其在执行<br>任何代码之前可用（可以访问）；至于函数表达式，则必须等到解析器执行到它所在的代码行，才会真<br>正被解释执行。</p>
</blockquote>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">alert(sum(10,10));</span><br><span class="line">function sum(num1, num2)&#123;</span><br><span class="line"> return num1 + num2;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">下面这个报错</span><br><span class="line">alert(sum(10,10));</span><br><span class="line">var sum = function(num1, num2)&#123;</span><br><span class="line"> return num1 + num2;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<h3 id="作为值的函数"><a href="#作为值的函数" class="headerlink" title="作为值的函数"></a>作为值的函数</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">function callSomeFunction(someFunction, someArgument)&#123;</span><br><span class="line"> return someFunction(someArgument);</span><br><span class="line">&#125;</span><br><span class="line">这个函数接受两个参数。第一个参数应该是一个函数，第二个参数应该是要传递给该函数的一个值。</span><br><span class="line">然后，就可以像下面的例子一样传递函数了。</span><br><span class="line">function add10(num)&#123;</span><br><span class="line"> return num + 10;</span><br><span class="line">&#125;</span><br><span class="line">var result1 = callSomeFunction(add10, 10);</span><br><span class="line">alert(result1); //20</span><br></pre></td></tr></table></figure>

<h3 id="递归"><a href="#递归" class="headerlink" title="递归"></a>递归</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">function factorial(num)&#123;</span><br><span class="line"> if (num &lt;=1) &#123;</span><br><span class="line"> return 1;</span><br><span class="line"> &#125; else &#123;</span><br><span class="line"> return num * factorial(num-1)</span><br><span class="line"> &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">为了消除这种紧密耦合的现象，可以像下面这样使用 arguments.callee。</span><br><span class="line">function factorial(num)&#123;</span><br><span class="line"> if (num &lt;=1) &#123;</span><br><span class="line"> return 1;</span><br><span class="line"> &#125; else &#123;</span><br><span class="line"> return num * arguments.callee(num-1)</span><br><span class="line"> &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>


<h3 id="函数的apply和bind"><a href="#函数的apply和bind" class="headerlink" title="函数的apply和bind"></a>函数的apply和bind</h3><blockquote>
<p>每个函数都包含两个非继承而来的方法：apply()和 call()。这两个方法的用途都是在特定的作<br>用域中调用函数，实际上等于设置函数体内 this 对象的值。首先，apply()方法接收两个参数：一个<br>是在其中运行函数的作用域，另一个是参数数组。其中，第二个参数可以是 Array 的实例，也可以是<br>arguments 对象。例如：</p>
</blockquote>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">function sum(num1, num2)&#123;</span><br><span class="line"> return num1 + num2;</span><br><span class="line">&#125;</span><br><span class="line">function callSum1(num1, num2)&#123;</span><br><span class="line"> return sum.apply(this, arguments); // 传入 arguments 对象</span><br><span class="line">&#125;</span><br><span class="line">function callSum2(num1, num2)&#123;</span><br><span class="line"> return sum.apply(this, [num1, num2]); // 传入数组</span><br><span class="line">&#125;</span><br><span class="line">alert(callSum1(10,10)); //20</span><br><span class="line">alert(callSum2(10,10)); //20</span><br></pre></td></tr></table></figure>
<blockquote>
<p>call()方法与 apply()方法的作用相同，它们的区别仅在于接收参数的方式不同。对于 call()<br>方法而言，第一个参数是 this 值没有变化，变化的是其余参数都直接传递给函数。换句话说，在使用<br>call()方法时，传递给函数的参数必须逐个列举出来，如下面的例子所示。</p>
</blockquote>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">function sum(num1, num2)&#123;</span><br><span class="line"> return num1 + num2;</span><br><span class="line">&#125;</span><br><span class="line">function callSum(num1, num2)&#123;</span><br><span class="line"> return sum.call(this, num1, num2);</span><br><span class="line">&#125;</span><br><span class="line">alert(callSum(10,10)); //20</span><br></pre></td></tr></table></figure>
<blockquote>
<p>能够扩充函数赖以运行的作用域</p>
</blockquote>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">window.color = &quot;red&quot;;</span><br><span class="line">var o = &#123; color: &quot;blue&quot; &#125;;</span><br><span class="line">function sayColor()&#123;</span><br><span class="line"> alert(this.color);</span><br><span class="line">&#125;</span><br><span class="line">sayColor(); //red</span><br><span class="line">sayColor.call(this); //red</span><br><span class="line">sayColor.call(window); //red</span><br><span class="line">sayColor.call(o); //blue</span><br></pre></td></tr></table></figure>
<blockquote>
<p>ECMAScript 5 还定义了一个方法：bind()。这个方法会创建一个函数的实例，其 this 值会被绑<br>定到传给 bind()函数的值。例如：</p>
</blockquote>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">window.color = &quot;red&quot;;</span><br><span class="line">var o = &#123; color: &quot;blue&quot; &#125;;</span><br><span class="line">function sayColor()&#123;</span><br><span class="line"> alert(this.color);</span><br><span class="line">&#125;</span><br><span class="line">var objectSayColor = sayColor.bind(o);</span><br><span class="line">objectSayColor(); //blue</span><br><span class="line"></span><br><span class="line">在这里，sayColor()调用 bind()并传入对象 o，创建了 objectSayColor()函数。objectSayColor()函数的</span><br><span class="line">this 值等于 o，因此即使是在全局作用域中调用这个函数，也会看到&quot;blue&quot;。</span><br></pre></td></tr></table></figure>

<h2 id="基本包装类型"><a href="#基本包装类型" class="headerlink" title="基本包装类型"></a>基本包装类型</h2><blockquote>
<p>ECMAScript 还提供了 3 个特殊的引用类型：Boolean、Number 和String。<br>Object 构造函数也会像工厂方法一样，根据传入值的类型返回相应基本包装类型的实例。例如：<br>var obj = new Object(“some text”);<br>alert(obj instanceof String); //true</p>
</blockquote>
<blockquote>
<p>Number 类型还提供了一些用于将数值格式化为字符串的方法。<br>其中，toFixed()方法会按照指定的小数位返回数值的字符串表示，例如：<br>var num = 10;<br>alert(num.toFixed(2)); //“10.00”<br>toFixed()方法可以表示带有 0 到 20 个小数位的数值。但这只是标准实现的范<br>围，有些浏览器也可能支持更多位数</p>
</blockquote>
<blockquote>
<p>var num = 10;<br>alert(num.toExponential(1)); //“1.0e+1”<br>以上代码输出了”1.0e+1”；不过，这么小的数值一般不必使用 e 表示法。如果你想得到表示某个<br>数值的最合适的格式，就应该使用 toPrecision()方法。<br>var num = 99;<br>alert(num.toPrecision(1)); //“1e+2”<br>alert(num.toPrecision(2)); //“99”<br>alert(num.toPrecision(3)); //“99.0”</p>
</blockquote>
<h3 id="string截取"><a href="#string截取" class="headerlink" title="string截取"></a>string截取</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">var stringValue = &quot;hello world&quot;;</span><br><span class="line">alert(stringValue.slice(3)); //&quot;lo world&quot;</span><br><span class="line">alert(stringValue.substring(3)); //&quot;lo world&quot;</span><br><span class="line">alert(stringValue.substr(3)); //&quot;lo world&quot;</span><br><span class="line">alert(stringValue.slice(3, 7)); //&quot;lo w&quot;</span><br><span class="line">alert(stringValue.substring(3,7)); //&quot;lo w&quot;</span><br><span class="line">alert(stringValue.substr(3, 7)); //&quot;lo worl&quot;</span><br></pre></td></tr></table></figure>
<blockquote>
<p>在传递给这些方法的参数是负值的情况下，它们的行为就不尽相同了。其中，slice()方法会将传入的负值与字符串的长度相加，substr()方法将负的第一个参数加上字符串的长度，而将负的第二个参数转换为0。最后，substring()方法会把所有负值参数都转换为 0。下</p>
</blockquote>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">var stringValue = &quot;hello world&quot;;</span><br><span class="line">alert(stringValue.slice(-3)); //&quot;rld&quot;</span><br><span class="line">alert(stringValue.substring(-3)); //&quot;hello world&quot;</span><br><span class="line">alert(stringValue.substr(-3)); //&quot;rld&quot;</span><br><span class="line">alert(stringValue.slice(3, -4)); //&quot;lo w&quot;</span><br><span class="line">alert(stringValue.substring(3, -4)); //&quot;hel&quot;</span><br><span class="line">alert(stringValue.substr(3, -4)); //&quot;&quot;（空字符串）</span><br></pre></td></tr></table></figure>
<blockquote>
<p>字符串位置方法<br>var stringValue = “hello world”;<br>alert(stringValue.indexOf(“o”, 6)); //7<br>alert(stringValue.lastIndexOf(“o”, 6)); //4</p>
</blockquote>
<h2 id="Global对象"><a href="#Global对象" class="headerlink" title="Global对象"></a>Global对象</h2><blockquote>
<p>诸如 isNaN()、isFinite()、parseInt()以及 parseFloat()，实际上全都是 Global对象的方法。除此之外，Global 对象还包含其他一些方法。<br>Global 对象的 encodeURI()和 encodeURIComponent()方法可以对 URI（Uniform Resource<br>Identifiers，通用资源标识符）进行编码，以便发送给浏览器。有效的 URI 中不能包含某些字符，例如<br>空格。而这两个 URI 编码方法就可以对 URI 进行编码，它们用特殊的 UTF-8 编码替换所有无效的字符，<br>从而让浏览器能够接受和理解。</p>
</blockquote>
<blockquote>
<p>encodeURI()主要用于整个URI（例如，<a target="_blank" rel="noopener" href="http://www.wrox.com/illegalvalue.htm%EF%BC%89%EF%BC%8C%E8%80%8CencodeURIComponent()%E4%B8%BB%E8%A6%81%E7%94%A8%E4%BA%8E%E5%AF%B9URI">http://www.wrox.com/illegalvalue.htm），而encodeURIComponent()主要用于对URI</a> 中的某一段（例如前面URI中的illegal value.htm）进行编码。它们的主要区别在于，encodeURI()不会对本身属于URI的特殊字符进行编码，例如冒号、正斜杠、问号和井字号；而encodeURIComponent()则会对它发现的任何非标准字符进行编码。</p>
</blockquote>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">var uri = &quot;http://www.wrox.com/illegal value.htm#start&quot;;</span><br><span class="line">//&quot;http://www.wrox.com/illegal%20value.htm#start&quot;</span><br><span class="line">alert(encodeURI(uri));</span><br><span class="line">//&quot;http%3A%2F%2Fwww.wrox.com%2Fillegal%20value.htm%23start&quot;</span><br><span class="line">alert(encodeURIComponent(uri));</span><br><span class="line"></span><br><span class="line">使用 encodeURI()编码后的结果是除了空格之外的其他字符都原封不动，只有空格被替换成了</span><br><span class="line">%20。而 encodeURIComponent()方法则会使用对应的编码替换所有非字母数字字符。这也正是可以</span><br><span class="line">对整个 URI 使用 encodeURI()，而只能对附加在现有 URI 后面的字符串使用 encodeURIComponent()</span><br><span class="line">的原因所在。</span><br></pre></td></tr></table></figure>
<blockquote>
<p>与 encodeURI()和 encodeURIComponent()方法对应的两个方法分别是 decodeURI()和<br>decodeURIComponent()。</p>
</blockquote>
<h3 id="eval-方法"><a href="#eval-方法" class="headerlink" title="eval()方法"></a>eval()方法</h3><p>在 eval()中创建的任何变量或函数都不会被提升，因为在解析代码的时候，它们被包含在一个字<br>符串中；它们只在 eval()执行的时候创建</p>
<h3 id="window-对象"><a href="#window-对象" class="headerlink" title="window 对象"></a>window 对象</h3><blockquote>
<p>另一种取得 Global 对象的方法是使用以下代码：<br>var global = function(){<br> return this;<br>}();</p>
</blockquote>
<h3 id="Math对象"><a href="#Math对象" class="headerlink" title="Math对象"></a>Math对象</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">要找到数组中的最大或最小值，可以像下面这样使用 apply()方法。</span><br><span class="line">var values = [1, 2, 3, 4, 5, 6, 7, 8];</span><br><span class="line">var max = Math.max.apply(Math, values);</span><br></pre></td></tr></table></figure>
<blockquote>
<p>Math.ceil()执行向上舍入，即它总是将数值向上舍入为最接近的整数；<br> Math.floor()执行向下舍入，即它总是将数值向下舍入为最接近的整数；<br> Math.round()执行标准舍入，即它总是将数值四舍五入为最接近的整数（这也是我们在数学课<br>上学到的舍入规则）</p>
</blockquote>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">function selectFrom(lowerValue, upperValue) &#123;</span><br><span class="line"> var choices = upperValue - lowerValue + 1;</span><br><span class="line"> return Math.floor(Math.random() * choices + lowerValue);</span><br><span class="line">&#125;</span><br><span class="line">var num = selectFrom(2, 10);</span><br><span class="line">alert(num); // 介于 2 和 10 之间（包括 2 和 10）的一个数值</span><br><span class="line"></span><br><span class="line">//通过调用 selectFrom(2,10)就可以得到一个介于 2 和 10 之间（包括 2 和 10）的数值了。利用这个函数，可以方便地从数组中随机取出一项</span><br><span class="line">var colors = [&quot;red&quot;, &quot;green&quot;, &quot;blue&quot;, &quot;yellow&quot;, &quot;black&quot;, &quot;purple&quot;, &quot;brown&quot;];</span><br><span class="line">var color = colors[selectFrom(0, colors.length-1)];</span><br><span class="line">alert(color); // 可能是数组中包含的任何一个字符串</span><br></pre></td></tr></table></figure>

<h2 id="js引用类型"><a href="#js引用类型" class="headerlink" title="js引用类型"></a>js引用类型</h2><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line">对象在 JavaScript 中被称为引用类型的值，而且有一些内置的引用类型可以用来创建特定的对象，</span><br><span class="line">现简要总结如下：</span><br><span class="line"> 引用类型与传统面向对象程序设计中的类相似，但实现不同；</span><br><span class="line"> Object 是一个基础类型，其他所有类型都从 Object 继承了基本的行为；</span><br><span class="line"> Array 类型是一组值的有序列表，同时还提供了操作和转换这些值的功能；</span><br><span class="line"> Date 类型提供了有关日期和时间的信息，包括当前日期和时间以及相关的计算功能；</span><br><span class="line"> RegExp 类型是 ECMAScript 支持正则表达式的一个接口，提供了最基本的和一些高级的正则表</span><br><span class="line">达式功能。</span><br><span class="line">函数实际上是 Function 类型的实例，因此函数也是对象；而这一点正是 JavaScript 最有特色的地</span><br><span class="line">方。由于函数是对象，所以函数也拥有方法，可以用来增强其行为。</span><br><span class="line">因为有了基本包装类型，所以 JavaScript 中的基本类型值可以被当作对象来访问。三种基本包装类</span><br><span class="line">型分别是：Boolean、Number 和 String。以下是它们共同的特征：</span><br><span class="line"> 每个包装类型都映射到同名的基本类型；</span><br><span class="line"> 在读取模式下访问基本类型值时，就会创建对应的基本包装类型的一个对象，从而方便了数据</span><br><span class="line">操作；</span><br><span class="line"> 操作基本类型值的语句一经执行完毕，就会立即销毁新创建的包装对象。</span><br><span class="line">在所有代码执行之前，作用域中就已经存在两个内置对象：Global 和 Math。在大多数 ECMAScript</span><br><span class="line">实现中都不能直接访问 Global 对象；不过，Web 浏览器实现了承担该角色的 window 对象。全局变</span><br><span class="line">量和函数都是 Global 对象的属性。Math 对象提供了很多属性和方法，用于辅助完成复杂的数学计算</span><br><span class="line">任务。</span><br></pre></td></tr></table></figure>
    </div>

    
    
    

      <footer class="post-footer">
          <div class="post-tags">
              <a href="/vlwq/vlwq.github.io/tags/%E9%AB%98%E7%A8%8B/" rel="tag"># 高程</a>
          </div>

        


        
    <div class="post-nav">
      <div class="post-nav-item">
    <a href="/vlwq/vlwq.github.io/2017/06/08/2017/20170608/" rel="prev" title="算法">
      <i class="fa fa-chevron-left"></i> 算法
    </a></div>
      <div class="post-nav-item">
    <a href="/vlwq/vlwq.github.io/2017/06/10/2017/20170610/" rel="next" title="高程笔记2-面向对象的程序设计">
      高程笔记2-面向对象的程序设计 <i class="fa fa-chevron-right"></i>
    </a></div>
    </div>
      </footer>
    
  </article>
  
  
  



          </div>
          

<script>
  window.addEventListener('tabs:register', () => {
    let { activeClass } = CONFIG.comments;
    if (CONFIG.comments.storage) {
      activeClass = localStorage.getItem('comments_active') || activeClass;
    }
    if (activeClass) {
      let activeTab = document.querySelector(`a[href="#comment-${activeClass}"]`);
      if (activeTab) {
        activeTab.click();
      }
    }
  });
  if (CONFIG.comments.storage) {
    window.addEventListener('tabs:click', event => {
      if (!event.target.matches('.tabs-comment .tab-content .tab-pane')) return;
      let commentClass = event.target.classList[1];
      localStorage.setItem('comments_active', commentClass);
    });
  }
</script>

        </div>
          
  
  <div class="toggle sidebar-toggle">
    <span class="toggle-line toggle-line-first"></span>
    <span class="toggle-line toggle-line-middle"></span>
    <span class="toggle-line toggle-line-last"></span>
  </div>

  <aside class="sidebar">
    <div class="sidebar-inner">

      <ul class="sidebar-nav motion-element">
        <li class="sidebar-nav-toc">
          文章目录
        </li>
        <li class="sidebar-nav-overview">
          站点概览
        </li>
      </ul>

      <!--noindex-->
      <div class="post-toc-wrap sidebar-panel">
          <div class="post-toc motion-element"><ol class="nav"><li class="nav-item nav-level-4"><a class="nav-link" href="#lt-script-gt-%E5%AE%9A%E4%B9%89%E4%BA%86%E4%B8%8B%E5%88%97-6-%E4%B8%AA%E5%B1%9E%E6%80%A7%E3%80%82"><span class="nav-number">1.</span> <span class="nav-text">&lt;script&gt;定义了下列 6 个属性。</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#XHTML%E8%BF%90%E8%A1%8Cscript"><span class="nav-number">2.</span> <span class="nav-text">XHTML运行script</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#html%E6%96%87%E6%A1%A3%E6%A8%A1%E5%BC%8F"><span class="nav-number">3.</span> <span class="nav-text">html文档模式</span></a></li></ol></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E6%95%B0%E5%80%BC%E8%BD%AC%E6%8D%A2"><span class="nav-number"></span> <span class="nav-text">数值转换</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#parseInt"><span class="nav-number"></span> <span class="nav-text">parseInt</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#parseFloat"><span class="nav-number"></span> <span class="nav-text">parseFloat</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E5%AD%97%E7%AC%A6String"><span class="nav-number"></span> <span class="nav-text">字符String</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E6%B1%82%E6%A8%A1%E8%BF%90%E7%AE%97"><span class="nav-number"></span> <span class="nav-text">求模运算</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E5%87%8F%E6%B3%95"><span class="nav-number"></span> <span class="nav-text">减法</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E5%85%A8%E7%AD%89%E5%92%8C%E4%B8%8D%E5%85%A8%E7%AD%89"><span class="nav-number"></span> <span class="nav-text">全等和不全等</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#%E6%AF%8F%E4%B8%AA%E4%B8%BB%E8%A6%81%E7%AE%97%E6%9C%AF%E6%93%8D%E4%BD%9C%E7%AC%A6%EF%BC%88%E4%BB%A5%E5%8F%8A%E4%B8%AA%E5%88%AB%E7%9A%84%E5%85%B6%E4%BB%96%E6%93%8D%E4%BD%9C%E7%AC%A6%EF%BC%89%E9%83%BD%E6%9C%89%E5%AF%B9%E5%BA%94%E7%9A%84%E5%A4%8D%E5%90%88%E8%B5%8B%E5%80%BC%E6%93%8D%E4%BD%9C%E7%AC%A6%E3%80%82%E8%BF%99%E4%BA%9B%E6%93%8D%E4%BD%9C%E7%AC%A6%E5%A6%82%E4%B8%8B%E6%89%80%E7%A4%BA%EF%BC%9A"><span class="nav-number">1.</span> <span class="nav-text">每个主要算术操作符（以及个别的其他操作符）都有对应的复合赋值操作符。这些操作符如下所示：</span></a></li></ol></li></ol></li></ol></li><li class="nav-item nav-level-1"><a class="nav-link" href="#for-in%E8%AF%AD%E5%8F%A5"><span class="nav-number"></span> <span class="nav-text">for-in语句</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#js%E6%B2%A1%E6%9C%89%E9%87%8D%E8%BD%BD"><span class="nav-number"></span> <span class="nav-text">js没有重载</span></a></li></ol></li></ol></li><li class="nav-item nav-level-1"><a class="nav-link" href="#%E5%9F%BA%E6%9C%AC%E7%B1%BB%E5%9E%8B%E5%92%8C%E5%BC%95%E7%94%A8%E7%B1%BB%E5%9E%8B%E7%9A%84%E5%80%BC"><span class="nav-number"></span> <span class="nav-text">基本类型和引用类型的值</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#%E5%9C%A8-Web-%E6%B5%8F%E8%A7%88%E5%99%A8%E4%B8%AD%EF%BC%8C%E5%85%A8%E5%B1%80%E6%89%A7%E8%A1%8C%E7%8E%AF%E5%A2%83%E8%A2%AB%E8%AE%A4%E4%B8%BA%E6%98%AF-window-%E5%AF%B9%E8%B1%A1"><span class="nav-number"></span> <span class="nav-text">在 Web 浏览器中，全局执行环境被认为是 window 对象</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#%E6%95%B0%E7%BB%84%E7%9A%84%E6%A0%88%E6%96%B9%E6%B3%95"><span class="nav-number"></span> <span class="nav-text">数组的栈方法</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E6%95%B0%E7%BB%84%E7%9A%84%E9%87%8D%E6%8E%92%E5%BA%8F%E6%96%B9%E6%B3%95"><span class="nav-number"></span> <span class="nav-text">数组的重排序方法</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E6%95%B0%E7%BB%84%E7%9A%84splice"><span class="nav-number"></span> <span class="nav-text">数组的splice</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E6%95%B0%E7%BB%84%E8%BF%AD%E4%BB%A3%E6%96%B9%E6%B3%95"><span class="nav-number"></span> <span class="nav-text">数组迭代方法</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E6%95%B0%E7%BB%84%E7%9A%84%E5%BD%92%E5%B9%B6%E6%96%B9%E6%B3%95"><span class="nav-number"></span> <span class="nav-text">数组的归并方法</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#js%E6%B2%A1%E6%9C%89%E9%87%8D%E8%BD%BD%EF%BC%88%E6%B7%B1%E5%85%A5%E7%90%86%E8%A7%A3%EF%BC%89"><span class="nav-number"></span> <span class="nav-text">js没有重载（深入理解）</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E5%87%BD%E6%95%B0%E5%A3%B0%E6%98%8E%E4%B8%8E%E5%87%BD%E6%95%B0%E8%A1%A8%E8%BE%BE%E5%BC%8F"><span class="nav-number"></span> <span class="nav-text">函数声明与函数表达式</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E4%BD%9C%E4%B8%BA%E5%80%BC%E7%9A%84%E5%87%BD%E6%95%B0"><span class="nav-number"></span> <span class="nav-text">作为值的函数</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E9%80%92%E5%BD%92"><span class="nav-number"></span> <span class="nav-text">递归</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E5%87%BD%E6%95%B0%E7%9A%84apply%E5%92%8Cbind"><span class="nav-number"></span> <span class="nav-text">函数的apply和bind</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E5%9F%BA%E6%9C%AC%E5%8C%85%E8%A3%85%E7%B1%BB%E5%9E%8B"><span class="nav-number"></span> <span class="nav-text">基本包装类型</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#string%E6%88%AA%E5%8F%96"><span class="nav-number"></span> <span class="nav-text">string截取</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#Global%E5%AF%B9%E8%B1%A1"><span class="nav-number"></span> <span class="nav-text">Global对象</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#eval-%E6%96%B9%E6%B3%95"><span class="nav-number"></span> <span class="nav-text">eval()方法</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#window-%E5%AF%B9%E8%B1%A1"><span class="nav-number"></span> <span class="nav-text">window 对象</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#Math%E5%AF%B9%E8%B1%A1"><span class="nav-number"></span> <span class="nav-text">Math对象</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#js%E5%BC%95%E7%94%A8%E7%B1%BB%E5%9E%8B"><span class="nav-number"></span> <span class="nav-text">js引用类型</span></a></div>
      </div>
      <!--/noindex-->

      <div class="site-overview-wrap sidebar-panel">
        <div class="site-author motion-element" itemprop="author" itemscope itemtype="http://schema.org/Person">
    <img class="site-author-image" itemprop="image" alt="Andrew Li"
      src="/vlwq/vlwq.github.io/assets/headimg/lwq.jpg">
  <p class="site-author-name" itemprop="name">Andrew Li</p>
  <div class="site-description" itemprop="description">此为博客一枚。</div>
</div>
<div class="site-state-wrap motion-element">
  <nav class="site-state">
      <div class="site-state-item site-state-posts">
          <a href="/vlwq/vlwq.github.io/archives/">
        
          <span class="site-state-item-count">81</span>
          <span class="site-state-item-name">日志</span>
        </a>
      </div>
      <div class="site-state-item site-state-tags">
            <a href="/vlwq/vlwq.github.io/tags/">
          
        <span class="site-state-item-count">13</span>
        <span class="site-state-item-name">标签</span></a>
      </div>
  </nav>
</div>
  <div class="links-of-author motion-element">
      <span class="links-of-author-item">
        <a href="mailto:xiyun0769@fomail.com" title="E-Mail → mailto:xiyun0769@fomail.com" rel="noopener" target="_blank"><i class="fa fa-envelope fa-fw"></i>E-Mail</a>
      </span>
  </div>


  <div class="links-of-blogroll motion-element">
    <div class="links-of-blogroll-title"><i class="fa fa-link fa-fw"></i>
      Links
    </div>
    <ul class="links-of-blogroll-list">
        <li class="links-of-blogroll-item">
          <a href="http://shequ.liweiqiang.vip/" title="http:&#x2F;&#x2F;shequ.liweiqiang.vip" rel="noopener" target="_blank">个人社区</a>
        </li>
    </ul>
  </div>

      </div>

    </div>
  </aside>
  <div id="sidebar-dimmer"></div>


      </div>
    </main>

    <footer class="footer">
      <div class="footer-inner">
        

        

<div class="copyright">
  
  &copy; 
  <span itemprop="copyrightYear">2022</span>
  <span class="with-love">
    <i class="fa fa-heart"></i>
  </span>
  <span class="author" itemprop="copyrightHolder">Andrew Li</span>
</div>
  <div class="powered-by">由 <a href="https://hexo.io/" class="theme-link" rel="noopener" target="_blank">Hexo</a> & <a href="https://pisces.theme-next.org/" class="theme-link" rel="noopener" target="_blank">NexT.Pisces</a> 强力驱动
  </div>

        








      </div>
    </footer>
  </div>

  
  <script src="/vlwq/vlwq.github.io/lib/anime.min.js"></script>
  <script src="/vlwq/vlwq.github.io/lib/velocity/velocity.min.js"></script>
  <script src="/vlwq/vlwq.github.io/lib/velocity/velocity.ui.min.js"></script>

<script src="/vlwq/vlwq.github.io/js/utils.js"></script>

<script src="/vlwq/vlwq.github.io/js/motion.js"></script>


<script src="/vlwq/vlwq.github.io/js/schemes/pisces.js"></script>


<script src="/vlwq/vlwq.github.io/js/next-boot.js"></script>




  















  

  

</body>
</html>
